

# 事件相关

### 事件简介

#### 1. 事件类型

#### 2. 事件的绑定

- HTML标签直接写
- DOM元素 获取dom元素，elem.on<event>绑定
- 使用addEventListener添加方法，elem.addEventListener(事件，回调)

#### 3. 事件对象

- event.type, event.currentTarget.....

### 冒泡和捕获



#### 1. 冒泡

##### 1.1 事件冒泡含义

当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。

##### 1.2 冒泡传递过程中event事件

父元素上的处理程序始终可以获取事件实际发生位置的详细信息。

**引发事件的那个嵌套层级最深的元素被称为目标元素,可以通过 `event.target` 访问。**

注意与 `this`（=`event.currentTarget`）之间的区别：

- `event.target` —— 是引发事件的“目标”元素，它在冒泡过程中不会发生变化。
- `this` —— 是“当前”元素，其中有一个当前正在运行的处理程序。

#### 2. 捕获

### 事件委托

### 事件循环

### 面试题

#### 1. 事件冒泡和事件捕获

事件冒泡和捕获是两种不同的事件传播方式，它们描述了当一个元素触发事件时，这个事件如何在它的父元素和子元素之间传递。

事件冒泡是指当一个元素触发事件时，这个事件会从最内层的元素开始，逐层向外传播，直到最外层的元素。也就是说，先触发当前元素的事件处理函数，然后再触发它的父元素的事件处理函数，依次类推，直到 document 对象。

事件捕获是指当一个元素触发事件时，这个事件会从最外层的元素开始，逐层向内传播，直到最内层的元素。也就是说，先触发 document 对象的事件处理函数，然后再触发它的子元素的事件处理函数，依次类推，直到当前元素。

事件冒泡和捕获都是为了实现事件委托，即利用事件在 DOM 树中的传播机制，让父元素或祖先元素代替子元素或后代元素处理事件，从而减少事件监听器的数量，提高性能。

我们可以使用 addEventListener 方法来为元素添加事件监听器，并指定第三个参数 useCapture 来决定是在冒泡阶段还是捕获阶段执行事件处理函数。默认情况下，useCapture 为 false，表示在冒泡阶段执行。如果设置为 true，则表示在捕获阶段执行。

我们也可以使用 stopPropagation 方法来阻止事件的进一步传播，即在当前元素执行完事件处理函数后，不再向外或向内传递。这样可以避免一些不必要的冲突或重复操作。

#### 2. 说一下事件委托

事件委托的原理是基于事件的传播机制，即当一个元素触发事件时，这个事件会在它的父元素和子元素之间传递。我们可以利用这个特性，让一个元素代替它的子元素或后代元素处理事件，从而减少事件监听器的数量，提高性能。

例如，如果我们有一个 ul 元素，里面有很多个 li 元素，我们想要给每个 li 元素添加点击事件。如果我们直接为每个 li 元素都添加事件监听器，那么会占用很多内存，并且如果动态添加或删除 li 元素，还需要更新事件监听器。但是如果我们利用事件委托，只为 ul 元素添加一个事件监听器，然后在事件处理函数中判断触发事件的元素是哪个 li 元素，就可以实现同样的效果，而且更加灵活和高效。

**优点**

- 减少事件监听器的数量，节省内存和提高性能。
- 动态添加或删除子元素或后代元素时，无需更新事件监听器，更加灵活和高效。

**局限性**

- 事件必须能够冒泡
- 其次，委托可能会增加 CPU 负载，因为容器级别的处理程序会对容器中任意位置的事件做出反应，而不管我们是否对该事件感兴趣。

#### Cookie

本质上是由服务器对浏览器的设置，一段json格式的字符串，存储在浏览器中。

服务器可以对一次请求设置Cookie。如果请求中存在Cookie，可以读取或者删除。

#### Session

##### 1. session原理

浏览器与服务器之间通信，这个过程称之为一次会话:session。

- 浏览器向服务器发送请求。
- 如果之前没通信过，服务器会记录当前用户的信息(有用信息)，并将信息存储到数据库中，并对应着一个id。
  - 响应体中包含sessionid，设置 Set-Cookie 头的方式响应给客户端
- 浏览器会将sessionId记录在Cookie中。
- 浏览器再次通信，Cookie中包含着sessionId，那么服务器就可以通过id找到用户信息，进而进行操作。

##### 2. 关于session的注意点

session只是保存、传输信息的工具，本身不具有校验功能，校验、查找等功能写在代码里。

**例子：判断用户登陆状态？**

- 如果存在sessionId，我们可以获取session中的信息，判断是谁登陆的。然后返回相应的数据
- 因此在访问相同域名的情况下，Cookie相同，sessionid是相同的，因此可以通过sessionid判断信息，让用户访问同域名的其他网页。

##### 3. 关于重新登陆

如果设置了：登陆就设置session：

- 如果Cookie中存在session，并且和数据库的相同，那么该sessionid不会修改。而是使用原来的session对象，进行增删改查。
- 如果退出登陆就销毁session，那么重新登陆意味着重新生成session对象

#### Token

服务器->浏览器的加密字符换。

和cookie类似，不过请求头是token。token是手动发送（从浏览器到服务的时候是主动的），cookie是自动的。

#### Cookie、Session、Token对比

Cookie和session本质是类似的，只不过，cookie是记录的所有数据，而session设置的是一个id，最终由服务器存储。





