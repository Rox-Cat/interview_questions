# Nuxt博客网站

## 项目功能与亮点

### 响应式布局实现

在本网站中，我采用了先进的响应式设计方法，以确保内容在各种设备和屏幕尺寸上都能实现优化展示。

#### 媒体查询和设备适配

为了适配从小屏幕手机到大屏幕桌面的不同设备，我使用了媒体查询 (`@media`) 来监听屏幕尺寸的变化，并相应地调整CSS规则。这些规则影响元素的尺寸、字体大小和显示属性等，以保持布局的流体性和可访问性。

媒体查询断点定义如下：

- 大屏: `min-width: 1248px`
- 中屏: `min-width: 768px` 和 `max-width: 1247px`
- 小屏: `max-width: 767px`

#### Grid布局与媒体查询

Grid布局的强大之处在于能够为页面元素提供二维的网格排布。通过定义列（`grid-template-columns`）、行（`grid-template-rows`）以及距（`gap`），可以创建精细调控的网格结构。根据屏幕尺寸的不同，我会调整网格的列数来适应内容显示，例如：

- 大屏显示3列
- 中屏显示2列
- 小屏显示1列

CSS示例：

css

```css
.blogs {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 1.5rem;
}

@media (max-width: 1248px) {
    .blogs {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 1rem;
    }
}

@media (max-width: 768px) {
    .blogs {
        grid-template-columns: repeat(1, minmax(0, 1fr));
        gap: 0.5rem;
    }
}
```

#### Flex布局与媒体查询

使用Flexbox布局，页面元素能在单行或列中灵活布局。我通过调整 `flex-direction`, `justify-content`, 和 `align-items` 等属性确保在不同设备尺寸下都能保持良好视觉排版和可读性。

在桌面视口下，首页布局采用侧边导航和主内容区的双栏布局。而在移动设备上，此布局会转变为单列布局，以优化空间使用和触控操作。

CSS示例：

css

```css
.homepage {
    display: flex;
    flex-direction: row;
}

@media (max-width: 768px) {
    .homepage {
        flex-direction: column;
    }
}
```

此响应式设计的实践确保了用户无论在何种设备上访问，都能得到最佳的浏览体验。

## 性能优化

### 渲染优化

#### 预渲染

当面试官询问您在性能优化方面所做的工作时，提及您在项目中实施了预渲染（Prerendering）是完全合适的。以下是您可以有条理地说明预渲染所做的性能优化的方法：

1. 首先，你可以简要地说明预渲染的概念：

“在我们的 Nuxt 项目中，我实施了预渲染，用以优化页面的加载速度和改善搜索引擎优化（SEO）。”

2. 然后深入解释预渲染的原理和好处：

“预渲染，指的是在构建阶段就生成页面的静态 HTML 文件。与传统的服务端渲染（SSR）相比，预渲染不需要服务器在每个请求时动态地构建 HTML，从而减少了服务器的计算负担和响应时间。”

3. 描述预渲染对性能优化的影响：

“预渲染提供了以下几个性能优化的优势：

1. **减少了首屏加载时间**：预渲染的页面可以直接从服务器快速传递到客户端，无需等待 JS 框架的启动和页面的构建，从而显著加快了页面的可见和交互时间。
2. **减轻服务器负担**：由于 HTML 是预先生成的，这降低了对服务端资源的需求，特别是在高流量情况下，可以避免服务器因动态渲染页面而成为性能瓶颈。
3. **改善SEO**：预渲染生成的页面包含所有必要的SEO元数据和内容，易于搜索引擎爬取和索引，这对内容驱动型网站尤其重要。”

4. 最后，为面试官展示您对于预渲染页面选择的策略：

“通常，哪些内容不经常改变、用户访问频率高的页面是预渲染的最佳选择，例如首页、博客文章列表和营销页面。这些页面的内容在构建时已确定，不需要实时的用户或数据交互，因此预渲染可以最大化这些页面的性能和SEO效果。”

结合以上几点，您可以向面试官展示您对性能优化的关注点及对相关技术的理解和实施策略。记得提及预渲染也有其局限性 - 对于需要频繁更新的内容或是用户交互度较高的应用部分，动态渲染可能更为适合。这种全面且平衡的讨论会展示出您作为开发者的深度和见解。

### 打包优化

#### CSS打包优化

通过压缩CSS文件大小来提高页面加载速度。现在的构建工具，如webpack、gulp/grunt、rollup等也都支持CSS压缩功能。压缩后的文件能够明显减小，可以大大降低了浏览器的加载时间。

## 项目遇到的问题

### 客户端和服务端的差异带来的问题

#### 组件生命周期问题

因为在服务端渲染的时候，组件的生命周期与客户端是不一样的，组件没有挂载、更新、卸载相关的生命周期，在服务端只会执行`setup`中的代码。

有一次，我在组件中的setup中开启了一个定时器，用来执行某个回调任务，并且在组件销毁的生命周期中，清除了定时器。但是在实际中，发现服务端占用的内存逐渐升高，反应变慢，后来经过了解Nuxt中关于服务端渲染的问题后，才明白了问题所在，因为组件在服务端渲染的时候，只需要获取它的虚拟DOM，并将它的虚拟DOM，转为对应的HTML字符串，拼接起来即可，不包含着组件的挂载、卸载的操作。所以在执行setup的时候，定时器开启了，但是服务端并没有组件卸载的生命周期，所以定时器一直没关闭，就导致了服务端出现了内存泄漏。

```ts
const timer1 = setInterval(() => {
	console.log('timer1')
}, 1000);

onBeforeUnmount(() => {
    clearTimeout(timer1)
})
```

解决的方案就是，因为本质上，我们做的内容是在客户端的，所以在服务端是无需开启定时器的，那么有两种方案：

1. 将定时器的开始移动到onMounted中
2. 添加判断条件。

#### 跨平台API问题

有的时候会在代码中使用window或者document对象，但是这两个对象在服务端是不存在的，所以我采用的方式就是使用`import.meta.env.SSR`来判断当前所处的是服务端还是客户端，进而执行不同的代码逻辑。

### 懒加载的不成功

#### 遗留直接导入导致目标模块没有被拆分

第一类问题的表现是：修改为动态导入`import()`后不生效，打包构建的产物中，目标模块没有被拆分为独立文件。

这个问题常见的原因是目标模块有多处直接导入（`import * from 'module'`），只改了部分目标模块的直接导入，仍然遗留了部分。

解决方案可以考虑：直接在目标模块中加`debugger`断点，在开发环境运行后，根据调用栈，排查哪些组件有导入目标模块。


例如，下图中，直接在`content.tsx`中写上`debugger`，在项目运行时，用Devtool的源代码标签页（Source）排查调用栈（Call Stack），一层层检查哪些文件调用了这个目标模块。

确认有没有遗漏的直接导入后，有的话，全部改成动态导入。

![image-20240419225353076](https://one-dinosaur.oss-cn-hangzhou.aliyuncs.com/typora/image-20240419225353076.png)

## 原理篇

### 为什么选择Nuxt

1. 想搭建博客网站，因为博客需要SSR，在调查了一遍Vue生态之后，发现Nuxt3是一个不错的选择；
2. 首先它是支持同构渲染，说说同构渲染的优点...，比较适合做博客网站
3. 一个支持全栈开发网站的框架，并且支持Vue，对于熟悉Vue的人比较友好
4. 继承了很多的自带的优化方法，可以放心的使用
5. 最后就开始学Nuxt，一边学，一般搭建项目

### CSR

#### CSR 流程

1. **请求页面**：
   用户浏览器向服务器发起页面请求。
2. **下载资源**：
   服务器响应请求并发送最小的 HTML 模板文件，通常会包括引用 CSS 文件和 JavaScript 代码的链接。
3. **浏览器解析**：
   浏览器接收并解析 HTML 文件，然后请求并下载 CSS 文件和 JavaScript 代码。
4. **渲染页面**：
   JavaScript 代码在浏览器中执行，通常是使用如 React 或 Vue 这样的现代 JavaScript 框架，它们会动态生成页面内容并更新 DOM。
5. **交互**：
   页面加载完成后，用户可以开始和页面进行交云动作，若有需要，JavaScript 还会继续通过 Ajax 发起数据请求更新页面内容。
6. **后续的页面导航**：
   对其他页面的访问通常不再需要从服务器请求整个新页面，JavaScript 代码可以处理路由并动态地更改展示的页面内容。

#### CSR 优点

- **灵活的交互**：因为所有的渲染都在客户端进行，这允许进行更加丰富和复杂的用户界面交互。
- **减轻服务器负载**：服务器不需要执行渲染逻辑，因此可以处理更多的客户端请求。
- **更好的用户体验**：一旦应用加载完毕，页面间的导航和交云动作响应通常很快，没有完整页面刷新。
- **集中式更新**：更新单页面应用通常只需要部署新的 JavaScript 代码，所有的用户都能获取到最新版本。

#### CSR 缺点

- **SEO 问题**：搜索引擎抓取可能无法完全等待异步加载的内容，这可能影响 SEO。
- **首屏延迟**：用户需要下载完整的 JavaScript 代码并等待应用执行完成才能看到完整页面，这会增加首屏时间。
- **浏览器兼容性**：依赖现代浏览器的 JavaScript 执行能力，过于陈旧的浏览器可能不支持。
- **JavaScript 文件大小**：应用复杂度增加意味着更大的 JavaScript 文件，需要良好的代码拆分和延迟加载策略。

在确定是否选择客户端渲染时，需要考虑的主要因素是应用的需求，包括 SEO、首屏加载时间以及所需的交互复杂度等。客户端渲染适合于交云动作非常丰富、不对 SEO 有强依赖的现代 Web 应用。一些单页面应用（SPA）框架，如 Angular、React（配合如 Create React App）和 Vue，天然支持这种渲染方式。

### SSR

服务端渲染（Server-Side Rendering, SSR）是 Web 开发中的一种常见技术，它的主要流程和优缺点如下：

#### SSR 流程

1. **请求处理**：
   客户端（通常是浏览器）发起一个页面请求。
2. **服务器渲染**：
   服务器接收到请求后，进行页面逻辑的处理，这包括数据库查询、API 调用等数据获取操作。
3. **HTML 生成**：
   服务器执行模板引擎或框架代码，并将数据渲染成完整的 HTML 字符串。
4. **发送响应**：
   服务器将生成的 HTML 作为响应发送回客户端。
5. **浏览器处理**：
   浏览器接收到 HTML 后构建 DOM，下载并执行附带的 CSS、JavaScript 等静态资源。
6. **客户端渲染过渡**：
   页面上相关的 JavaScript 代码在浏览器端执行，为页面添加交互性，这可能涉及到状态管理和事件监听的初始化。
7. **客户端激活/混合模式**：
   现代框架如 React、Vue、Angular 支持在服务端渲染的基础上进行客户端混合，以便进一步更新和处理用户交互。

#### SSR 优点

- **更快的首屏加载**：用户能更快地看到页面的第一屏内容，这对于提升用户体验非常关键。
- **SEO 友好**：搜索引擎可以直接获取到完整渲染的页面，这有助于改善 SEO。
- **共享代码基**：允许在服务器和客户端之间共享某些代码逻辑，特别是在使用现代 JavaScript 框架时。

#### SSR 缺点

- **服务器负载**：所有页面都需要服务器实时渲染，对于高流量站点，可能需要更多的服务器资源和优化。
- **首次交互延迟**：虽然用户能快速看到内容，但交云动作的响应可能要等到 JavaScript 文件下载和执行完成。
- **开发限制**：需要处理服务器和客户端代码，可能会遇到一些环境特定的开发限制。
- **缓存策略**：因为内容是动态生成的，所以缓存策略可能会更加复杂。

服务端渲染和传统的完全客户端渲染（Client-Side Rendering, CSR）相比，每种方式都有适用的场景。选择 SSR 还是 CSR 通常取决于应用需要优先解决的问题，比如是否需要优化 SEO、是否追求最快的首屏渲染时间等。现代化的 web 开发常常采用 SSR 结合客户端混合的方式，取两者之长，如 Next.js（用于 React）和 Nuxt.js（用于 Vue）。

### 同构渲染

同构渲染（Isomorphic Rendering）是一种前端渲染策略，同时利用了服务器端渲染（SSR）和客户端渲染（CSR）的优势。它使得代码可以在服务器和客户端上执行，提供更快的首屏加载时间和更好的搜索引擎优化（SEO）。以下是同构渲染的流程和优缺点：

#### 同构渲染流程

1. **请求页面**：
   用户的浏览器向服务器发送页面请求。
2. **服务器处理**：
   服务器接收请求，根据 URL 加载相应的页面组件，可能还会进行路由匹配、数据预取等操作。
3. **服务器渲染页面**：
   服务器执行相应的 JavaScript 框架或模板引擎代码，渲染完整的页面 HTML。
4. **发送响应**：
   服务器将渲染好的 HTML 页面内容发送到客户端。
5. **浏览器显示页面**：
   浏览器显示服务器渲染的 HTML，用户可以看到页面的初始展示。
6. **加载JavaScript**：
   浏览器下载并执行页面相关的 JavaScript。在现代 Web 开发中，这通常包括由 webpack 等工具打包后的文件。
7. **客户端激活**：
   JavaScript 运行时，客户端应用程序“激活”，客户端框架接管页面，使其变得交云动性。
8. **客户端路由与交互**：
   后续的页面导航和用户交云动作通过客户端路由处理，无需从服务器获取新的页面。

#### 同构渲染优点

- **快速的首屏显示**：用户不需要等待所有的 JavaScript 加载和执行即可看到完全渲染的页面。
- **SEO 友好**：预渲染的页面有助于提升内容在搜索引擎上的可索引性。
- **代码复用**：服务器和客户端可以共享某些代码（如路由逻辑、状态管理），简化应用架构。
- **改善性能**：适当的同构策略有助于降低延迟，提高网站的响应速度。

#### 同构渲染缺点

- **复杂性增加**：需要管理两套渲染逻辑（服务器和客户端）以及它们之间状态的同步。
- **服务器负担**：服务器在响应每个请求时都需要进行页面渲染，可能增加了服务器的性能压力。
- **冷启动时间增长**：客户端 JavaScript 文件必须等到下载并执行完成才能完全交云动化，可能造成更慢的交互准备时间。
- **开发限制**：某些浏览器特定的 API 在服务器端无法使用，需要额外的环境判断和处理。

同构渲染综合了 SSR 和 CSR 的优势，适用于追求快速加载、SEO 和高交互性的 Web 应用。然而，在选择此方法时需要考虑增加的复杂度以及对服务器资源的需求，确保这些权衡符合项目的长期目标和维护策略。

### 同构渲染 - 服务端渲染

1. **接收请求**：服务器接收到来自客户端的页面请求。

2. **路由处理**：服务器解析请求的 URL，并确定要渲染的页面组件或路由。

3. **数据获取**：在渲染页面内容之前，服务器可能需要获取外部数据。这通常涉及对数据库的查询或调用 API。

4. **组件渲染**：服务器使用相应的模板引擎或框架（如 Vue、React 或 Angular）执行应用逻辑，将数据渲染进 HTML 模板中，在Nuxt3中，Vue会获取一般不包括事件的绑定等内容，同时会将虚拟dom的key等内容清除。

   关于组件的渲染与客户端不同，我们只需要获取到组件利用的数据即执行`setup`，然后执行`render`获取对应的虚拟DOM，然后将虚拟DOM转换为HTML字符串即可，我们不需要进行真实DOM的更新与挂载等内容，因为不要收集副作用函数。

5. **生成 HTML**：渲染完成后，服务器生成完成的 HTML 页面，这通常涉及渲染框架所管理的组件树的递归处理。

6. **发送响应**：服务器将生成的 HTML 页面作为响应发送回客户端，此时包括了预渲染的页面内容。

7. **内嵌状态**：如果渲染涉及到一些应用状态，服务器会将这些状态序列化并内嵌在 HTML 中，以便浏览器可以在客户端激活时重用这些状态。

8. **静态资源引用**：服务器在 HTML 中附上必要的静态资源引用，如 JavaScript 打包文件、CSS 样式表、图像文件等链接。

### 同构渲染 - 客户端激活

同构渲染中的客户端激活（Client-Side Hydration）是指在浏览器中补充服务器端已渲染的静态 HTML 以实现完整的客户端应用程序功能的过程。这个过程有助于缩短可交互时间（Time To Interactive, TTI），因为用户可以更快看到页面的内容。以下是客户端激活的基本步骤：

1. **服务器端渲染**：
   初始的页面请求由服务器处理，服务器对视图进行渲染，生成静态的 HTML，并将其作为响应发送到客户端。

2. **加载静态标记**：
   浏览器接收到服务器提供的 HTML，开始加载页面，并展示给用户。

3. **下载 JavaScript 文件**：
   浏览器解析 HTML 中的 `<script>` 标签，并下载必要的 JavaScript 文件。

4. **执行 JavaScript**：
   一旦 JavaScript 文件下载完成，浏览器执行这些脚本。对于使用 Vue.js、React 或 Angular 等现代 JavaScript 框架的应用，这些脚本包括客户端应用程序的代码。

5. **绑定事件和交互**：
   在执行脚本的过程中，代码会做两件事：

   - Vue会建立虚拟DOM与真实DOM之间的连接，用于后续的页面内容的控制与更新。

   - 会在对应的 DOM 元素上绑定事件监听，激活相关的 Vue 组件或 React 组件等，实现各种交互动作。

6. **状态同步**：
   如果服务器端渲染的应用附带了初始状态（例如，通过内嵌脚本注入），这个状态将被同步到客户端应用以确保一致性。

7. **客户端渲染接管**：
   完成激活后，页面上的进一步用户交云动作将由客户端处理。客户端路由开始工作，新的页面视图将由浏览器直接生成，不再需要服务器渲染。

8. **后续的客户端导航**：
   用户继续浏览其他页面时，路由变化将完全在客户端处理，无需额外的服务器端渲染，实现无刷新导航。

客户端激活是同构应用核心的一个方面，因为它使同构应用既可以提供服务器渲染带来的好处（如 SEO 和首屏加载时间优化），又能提供客户端应用的丰富交互和动态特性。它确保了无论用户访问路径如何（直接访问或客户端路由导航），最终用户的体验都是一致的。

### 客户端激活原理

#### 要做的事情

1. Vue会建立虚拟DOM与真实DOM之间的连接，用于后续的页面内容的控制与更新。

2. 会在对应的 DOM 元素上绑定事件监听，激活相关的 Vue 组件，实现各种交互动作。

#### 原理

1. Vue会获取真实的DOM元素，进入`renderer.render(vnode, container)`，其中vnode是组件的虚拟DOM，在服务端也会被用到，container是对应的组件的真实DOM。
2. 递归的遍历，挂载到`vnode.el = node`，这样建立了vnode与真实DOM的连接。
3. 如果此时vnode是组件，那么进入组件挂载函数
4. 如果此时vnode是普通元素， 就进入普通的元素水合函数

在元素水合函数中，我们需要把对应的事件挂载到真实DOM上即可；

在组件挂载函数中，会有一个判断是否挂载以及vnode.el是否存在的条件，如果满足条件，说明是在水合阶段，然后直接进行后续的水合节点即可，也就是递归遍历组件的子节点，然后重复上述过程。