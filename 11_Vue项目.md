# 项目相关面试题

## 1. 项目难点



## 2.项目中学习到的新东西



## 3. 做的一些项目中，你觉得哪些项目点做的比较好，可以详细描述下

## 4. 遇到什么难点，怎么解决的

# 项目配置相关

## Aixos二次封装

- 首先，我创建了一个新的axios实例，用来设置请求的基础路径baseURL、超时时间timeout、响应类型resonseType等
- 然后，我定义了请求拦截器：
  - 请求头添加了token信息
- 响应的拦截器：
  - 如果成功就返回响应数据
  - 失败，使用ELMessage提示异常，并返回失败的Promise
- 对外暴露请求示例 

这样，我就完成了对axios的二次封装，使得我可以更方便地使用axios进行网络请求。

## LocalStore二次封装

用于获取localStore中的token

## API封装

- 导入了axios实例
- TS编写了请求的参数类型和响应的参数类型
- 封装了不同的请求方法，需要用的地方直接导入即可。

## 路由配置



# 用户登陆

## 一、静态页面

- el-row -> 24列分布

  - el-col -> 占据12列

  - el-col -> 12列

    - el-form 表单信息

      - el-form-item -> input -> 用户名
      - el-form-itme -> input, type = password -> 密码 
      - el-form-itme -> button 登录按钮

      v-model将上面两项双向数据绑定到reactive变量上

## 二、登陆功能

> 点击登陆 -> 发送请求 -> 处理响应数据

### 1. 逻辑描述

点击登陆之后，发送Ajax请求，接收数据，如果成功，保存验证信息，反之提示信息。

==重点==：验证信息的表示，存储，销毁

#### 点击登录

在登录按钮上绑定点击事件，点击之后，执行异步函数

#### 发送请求

使用pinia中封装的登录请求方法，将pinia仓库导入到文件中

- async/await来实现，这里是等待pinia中的异步函数

- try...catch处理

  - 成功（数据）：保存token信息（使用封装的token报错函数），路由跳转

    导入路由器$router，跳转到指定页面

  - 失败（失败的promise）：提示错误信息

#### Pinia保存信息

+ state中为Token
+ action
  + 异步请求的函数，async/await来实现，使用封装的API请求方法，根据状态码判断成功失败
    + 成功：返回数据
    + 失败：返回失败的promise

## 三、TS类型标注



## 四、表单验证

#### 基本配置

在el-form上，添加三个属性：

- :model="loginForm"："双向数据绑定的数据"，整个表单的存储value的对象
- :rules="rules", rules是个对象，key=表单项名称，value：数组包含表单验证规则
- ref="loginForms"，获取表单组件的实例，可是使用它的数据或者方法

#### 验证规则

使用已封装的

```js
const rules = reactive({
    "username": [
        "required": 是否必填,
        "min/max": 最小最大长度
        "message": 错误信息
        "trigger": 触发时机，change: 文本变化，blur：失去焦点
    ]
})
```

自定义校验规则

使用实例上value中的校验函数

```js
const rules = reactive({
	"username" = [
    	{
    		"vaildator": validatorFunc， 校验函数
    		"trigger": 触发时机
		}
    ]
})

function validator(rule, value, callback) => {
    	rule: 数组的校验规则对象，打印后即可明确
        value: 表示对于表单元素的value，也就是loginForm.xxx属性
        callback: 如果符合条件，通过callback放行，即为通过，反之注入错误提示信息 
}
```

# 首页

### 1. 页面布局及功能

- 左侧为菜单栏
  - 菜单展示
  - 实现多级菜单的展开
  - 点击后路由的跳转
- 顶部导航栏
  - 面包屑展示
  - 用户信息展示

- 核心页面
  - 展示跳转之后的路由，该区域为路由显示的地方

### 2. 实现

分别使用三个div包裹

# 左侧菜单栏

### 1. 菜单栏的静态

菜单功能通过el-menu组件实现：

- el-menu-item: 无子菜单
- el-sub-menu: 存在子菜单
- `<template #title>Workspace</template>`:插槽，将该标签内的内容替换组件的信息【插槽的应用】

### 2. 获取用户路由

菜单栏的信息是由路由来确定的，因此需要知道路由信息。一个疑问？路由不是静态的吗？

注：不能通过router = useRouter()来获取

#### 通过pinia来管理路由信息

==自己添加一个路由响应？==

在pinia中导入路由文件，报错在状态state中。

#### Layout组件传递路由信息

在Layout组件中，获取路由信息，并通过props传递给Menu组件

### 3. 动态生成菜单信息

通过v-for来遍历，路由信息

#### 没有子路由

直接当作一级菜单显示

#### 存在子路由

设置一级子路由之后，将子路由传递给Menu组件，递归实现内容。

### 4. 路由跳转

在el-menu-item上绑定点击事件，传递的参数是事件对象，我们在给el-menu-item设置index的时候，将其设置为路由的路径。

进而使用router.push()进行跳转

## 四、顶部导航栏

### 1. 静态页面布局

#### 1. 整体布局

左侧面包屑，右侧登录信息

设置flex布局，左右两侧的盒子，顶到头

#### 2. 左侧布局

一个折叠图标组件，一个面包屑组件

#### 3. 右侧布局

设置刷新图标，全屏图标，设置图标，用户头像，下拉菜单

### 2. 菜单折叠效果

点击折叠按钮之后，菜单折叠，主页面和顶部导航栏扩大；

**思路**

设置双栏布局，菜单使用scss来调整宽度，然后右侧使用flex自动填充；

**实际**

左侧宽度固定，点击之后，宽度调整。

右侧设置width: 100% - 左侧宽度。

- 导航栏使用固定定位
- 核心页面，使用margin-top和margin-left

#### 1. 记录是否折叠

在pinia中，设置一个变量，是否折叠

#### 2. 实现折叠效果

#### 事件触发

在面包屑组件中，绑定折叠效果的事件，点击之后修改折叠变量

#### 组件折叠

在三个组件上绑定折叠属性，利用scss来切换来css样式。

同时在el-menu上绑定一个属性collapse，结合组件自身功能设置折叠效果。

## 三、实现面包屑效果

### 1. 功能概述

**功能描述**

点击组件，面包屑更新： 首页

多级组件，面包屑继续显示: 首页>用户管理>xxx

点击面包屑的某一项，跳转到指定路由

**我的思路**

$route为当前路由的信息，其中有个matched数组，包含了当前加载的路由信息，例如当前是/product/attr，那么数组中就会有，/product路由信息和/product/attr信息，每个路由的meta中有着路由元信息。其中有属性名和icon等。

我们可以遍历该数组，v-for，生成多个普通的item，并且绑定点击事件，点击之后，跳转到指定路由中。

**实际实现**

见下面几个步骤

### 2. 动态显示

#### 面包屑的动态更新

- 使用useRoute获取当前路由信息；
- $route.matched 获取匹配到的路由信息，从一级路由到当前路由的信息都存储在该数组中；
- 对于面包屑的item，使用v-for来遍历显示内容
- 对于home路由，只想显示首页而不是显示layout（layout是父路由）
  - 使用v-show来判断当前item是否显示

```html
    <el-breadcrumb separator-icon="ArrowRight">
        <!-- 面包屑动态展示路由的图标与标题 -->
        <el-breadcrumb-item v-for="(item, index) in $route.matched" :key='index' v-show="item.meta.title" :to="item.path">
            <el-icon style="margin-right: 5px;">
                <component :is="item.meta.icon"></component>
            </el-icon>
            <span>{{ item.meta.title }}</span>
        </el-breadcrumb-item>
    </el-breadcrumb>
```

其中：

- `<el-breadcrumb-item v-for="(item, index) in $route.matched" :key='index' v-show="item.meta.title" :to="item.path">`为遍历当前数组
- icon是显示图标
- span是显示内容

#### 面包屑的跳转

面包屑组件中属性：`to`使用方法等同于router-link中的to，因此添加该属性后动态赋值路由的路径即可->`:to="item.path"`

## 四、小功能实现

### 1. 刷新功能

**使用v-if的方式来实现**：

- 设置flag = true，表示显示组件内容；设置settingPinia仓库中的变量refsh
- 当点击刷新的时候，refsh取反
- 在main组件中，监听refsh的变化
  - 回调函数：
  - flag = false，然后再nextTick中设置flag = true
- 如果变化设置flag = false，组件消失，等待Dom更新完毕，nextTick执行再将falg设置为true，显示组件。

**提问：能否使用v-show来实现组件的刷新？**

不能，因为v-show是通过CSS来实现的，因此组件并没有被销毁，组件的数据和状态都会保存。

### 2. 全屏模式

对全屏按钮设计点击事件，并配合document.fullscreenElement判断是否全屏，然后调用响应的全屏和退出全屏的方法。

```js
// 全屏功能
const fullScreen = () => {
    // document.fullscreenElement
    // DOM对象的属性，可以用判断是不是全屏模式
    let full = document.fullscreenElement
    if (!full) {
        // 文档根节点的方法，实现全屏
        document.documentElement.requestFullscreen()
    } else {
        // 退出全屏模式
        document.exitFullscreen()
    }
}
```

### 3. 退出登陆

组件来判断用户的登陆状态是通过Token来判断的，因此退出登陆实际上是删除Token的过程。

实际上，主要有以下三步：

- 点击退出登陆 -> 绑定事件 -> 回调函数

- 向服务器发送退出的请求，服务器知晓Token不可用了已经

  在userStore中，设置退出登陆的异步函数

- await 结果，收到服务器的Ok响应之后，清除pinia中的所有state

- 跳转到Login页面

  利用router.push('/login')，并且设置查询字符串

  ```js
  $router.push({
      name: 'login',
      query: { redirect: $route.path }
  })
  ```

### 4. 重登陆+重定向

在用户登陆时，如果登陆成功，判断route中是否存在查询字符串redirect，如果存在我们可以在路由跳转的时候，设置上path: redirect，表示跳转到指定路由。

从而实现，从哪里离开回到哪里。



# 路由鉴权

> **参考下文面试的时候进行扩展**
>
> - [Vue项目中的路由鉴权 - 掘金 (juejin.cn)](https://juejin.cn/post/6916135317397307400)
> - 

用户跳转指定路由，要判断是否有权限访问

## 一、权限分析

项目的功能结构按页面划分，分为两类

- 公共页面，包含登录页面，404页面，错误页面等。
- 权限页面，具体权限功能对应的页面。

如何根据每个用户的权限进行前端的鉴权，实现的思路是：

- 前端根据用户登录后获取到的权限表；
- 生成用户的路由表；
- 然后根据路由表生成一级菜单栏。
- 用户每次进行路由切换时，检查用户是否拥有对应路由的权限。

**权限验证流程**

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a54576ec25db47e2ac1d3c7d411a89c7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.image)



## 二、用户访问顺序

### 1. 登陆

- 获取到了Token信息
- 跳转到首页路由

### 2. 请求用户信息

获取到用户信息，以及用户权限表，存储到Pinia

### 3. 路由表信息

根据用户权限表，生成路由权限表，进而实现菜单组件的生成

## 三、路由鉴权功能实现

> [V3 Admin Vite - pany的专栏 - 掘金 (juejin.cn)](https://juejin.cn/column/7207659644487139387)
>
> [手摸手，带你用vue撸后台 系列二(登录权限篇) - 掘金 (juejin.cn)](https://juejin.cn/post/6844903478880370701#heading-6)

### 核心功能描述

在从任意路由跳转到任意路由之前，首先判断是否存在Token

- 没有：转到login路由

- 有：pinia中是否存在用户信息

  - 不存在，请求用户信息数据

    请求用户信息，返回该用户的数据中`result.data.routes`是一个数组，包含着用户可以访问哪些路由；

    该函数filterAsyncRoute，来筛选出满足条件的路由配置信息

    使用router.addRouter()更新路由

  - 存在进行跳转

    - 如果目标路由存在 -> 进入
    - 如果没有，404

### 1. 全局前置路由守卫

在从任意路由跳转到任意路由之前：

### 2. 全局后置路由钩子



# 商品管理

## 一、品牌管理

### 1. 商品管理静态

- el-dialog 对话框
- el-card包裹整个内容
- el-button 按钮
- el-table 设置属性名称等属性信息
- el-pagination 分页器组件

### 2. 分页器功能

#### 功能概述

点击页码可以跳转，并且可以修改每行展示的数目

#### 点击分页

- el-pagination上有个`@current-change`，页码变化时，会被触发。

- 绑定回调函数获取数据(页码)
- 发送请求：（当前页码，每页item数量）
- 获取之后，修改表格显示的数值

#### 修改每页数量

存在一个页面改变的事件监听，事件触发时，重新发送请求，并设置页面为1

### 3. 对话框

#### 功能描述

- 点击添加品牌之后，弹出对话框；
- 对话框中两个表单元素：
  - 商品名称
  - 上传框
- footer，具名插槽
  - 确定和取消

#### 对话框弹出

- 对话框用el-dialog表示
- 在添加商品按钮上，绑定事件，点击修改变量值
- 使用v-model，控制对话框的显示与否，dialogFormVisible这个变量来控制，应该时对话框的value就是是否显示对话框。

#### 对话框信息输入

- 对话框中商品名称，正常输入即可。规则是必填
- 对于上传模块：el-upload
  - action：上传地址，先将图片上传到后端，再在前端显示
  - 上传前，验证信息 :before-upload
  - 上传完毕之后，通过img来显示，img和el-icon通过v-if和v-else来显示
- 点击确认之后，验证数据
  - 将数据上传到后端，包括商品信息，以及图片链接

### 4. 修改商品信息

#### 功能概述

- 点击el-table中的修改属性按钮，弹出对话框，其中的数据为商品的名称和图片
- 修改之后上传，表中数据更新
- 取消修改，就不更新

#### 我的思路

- 点击编辑按钮，修改dialog的显示变量；
- 将当前一行的数据，赋值到dialog中的数据中，这样就被显示了；
- 上传之后，关闭dialog，然后重新获取列表信息；
- 每次关闭，都清空dialog的数据

#### 实际思路

基本类似

### 5. 删除商品

上传商品的Id，然后删除之后，接收promise的结果，然后重新获取信息。

## 二、属性管理

### 1. 静态搭建

- 上面一个el-card
  - 包裹着el-form，并排
- 下面一个el-card
  - 一个el-button
  - 一个el-table

# 权限管理

## 一、用户管理

### 1. 功能描述

- 点击输入用户名，搜索用户
- 

### 2. 静态搭建

用户搜索

- el-card
  - el-form，行内元素
    - el-input
    - el-button

用户信息

- el-card
  - el-button:添加，删除
  - el-table：用户信息
  - 分页符

### 3. 展示信息

#### 封装API和TS类型

#### 获取信息

- 组件挂载之后，onMounted，请求数据，参数：页码和每页个数
- 将收到的数据，赋值给一个ref数据，然后与el-table进行双向数据绑定
- table的列，设置好绑定的数据

### 4. 添加/修改用户

#### 功能描述

- 点击添加/修改按钮，弹出抽屉结构
- 对于添加来说，数据为空
  - 用户名
  - 用户昵称
  - 用户密码
- 对于修改来说，数据不为空：
  - 显示用户名
  - 显示角色信息

- 关闭抽屉之后，要将数据清空
- 页面添加一条数据

#### 我的思路

- 放置一个抽屉结构，绑定控制变量，是否显示
- 按钮添加点击事件，修改控制变量
- 抽屉中添加表单，用于添加信息
- 点击修改/添加之后，发送修改请求
- 重新获取第一页的数据，展示信息

#### 添加思路

1. 放置一个抽屉结构，绑定控制变量，是否显示
2. 按钮添加点击事件，修改控制变量，清空绑定的原有数据Object.assign()
3. 抽屉中添加表单，用于添加信息，表单信息要进行表单校验
4. 在抽屉接口的确认按钮上，点击确认
   - 根据添加还是修改按钮，来向不同的接口发送请求
   - 如果添加成功：重新获取第一页的数据，展示信息
5. 关闭页面

#### 修改思路

1. 点击按钮，打开页面
2. 将点击按钮回调的参数获取，也就是该行的信息
3. 将信息赋值给表单的数据，这时候点开表单数据更新
4. 其中只显示两项：
   - 用户名称和用户昵称
   - 对于用户密码来说，v-if判断，是否显示，依据表单的数据是否有ID来控制

5. 点击确定之后，发送修改请求
6. 请求为真之后，重新的请求数据，数据为当前页面和当前的页数限制

#### 修改当前账号

当修改当前账号的时候，如果点击刷新，token存在，但是用户信息没有，会向服务器发送请求，但是此时，token对应的用户名被修改了，因此无法获取到信息，所以要跳转到登陆页面。

因此在修改完用户信息之后，我们要进行window.location.reload()重新加载页面，如果能获取信息，就正常，如果加载完毕无法获取信息，那么就跳转到login了，这些都是在前置路由守卫中做的

### 5. 分配角色

#### 功能概述

- 点击分配角色之后，弹出抽屉框，显示的是复选框的内容
- 选中复选框，点击确认之后，用户的角色被分配

#### 预期思路

- 抽屉框的静态，el表单 + 复选框，双向数据绑定
- 点击确认之后，携带Id和复选框内容，发送异步请求

- 重新请求信息







