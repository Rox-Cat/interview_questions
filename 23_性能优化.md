# 性能优化指标

我的项目的FCP

![image-20240406205557408](https://one-dinosaur.oss-cn-hangzhou.aliyuncs.com/typora/image-20240406205557408.png)

# 缓存篇

```
git filter-branch --force --index-filter ^
"git rm --cached --ignore-unmatch '18_公司的了解.md' '19_HR面试总结.md' '13_主观面试题.md'" ^
--prune-empty --tag-name-filter cat -- --all
```



## 浏览器缓存

见协商缓存和强缓存

## 浏览器本地缓存

见Cookie，LocalStore，sessionStorage

## CDN缓存

CDN全称为Content Delivery Network（内容分发网络），是一组分布在多个不同地理位置的服务器，这些服务器协作使用户可以更快地获取数据。它主要用于快速、可靠地将内容分发给用户。

### CDN的原理

CDN的核心原理是地理位置上的优化。它通过将内容缓存在全球各地的代理服务器上，使内容更接近用户，从而减少内容传输的延时和速度。当用户尝试访问通过CDN提供的资源时，CDN的负载均衡系统会将用户的请求定向到离用户最近的服务器节点。这样，用户可以从邻近的数据中心下载内容，而不是从你的主服务器（通常距离用户遥远）上获取，这能够显著提高加载速度和用户体验。

### CDN的使用场景

CDN适用于任何需要快速向用户分发数据的情形。以下是一些常见的使用场景：

- **网站静态资源缓存**：网站上的静态资源（图片、CSS文件、JavaScript脚本等）可以被缓存到CDN。每当用户访问网站时，这些资源将通过CDN加速传递，以提高网站的加载速度。
- **音视频流媒体**：CDN能够处理大量的数据传输，并提供实时流媒体服务，确保低延迟和高清晰度。
- **软件分发**：用于分发更新和下载（包括APP或大型软件的新版本），避免主服务器被过多的并发请求压垮。
- **加速API**：如果你的应用依赖于API数据交换，CDN可以帮助缓存API的输出，减少服务器负载和延迟。
- **大型网站**：对于访问量很大的网站，通过CDN分摊流量，保证服务的稳定性。

### CDN的使用方法

1. **选择CDN提供商**：根据需求，选择合适的CDN提供商，常见的有Akamai、Cloudflare、Amazon CloudFront、Google CDN等。
2. **配置CDN**：在CDN提供商管理界面中，配置需要加速的域名和相关设置。
3. **改变资源链接**：将网站上资源的链接指向CDN的缓存链接，而不是原始服务器。
4. **DNS解析**：修改DNS设置，通过CNAME记录将域名指向CDN的域名。
5. **缓存和失效**：配置CDN缓存策略和内容失效策略，以控制内容的更新和缓存时间。

### CDN内容缓存策略

以下是一些内容相对适合使用CDN的情况：

- **不经常更改的内容**：如公司徽标、静态库文件等，这些文件很少有更新的需求。
- **高流量内容**：如流行的视频、图片，聚集了大量访问的内容。
- **公共库和框架**：如jQuery、Bootstrap等，许多网站会共用这些资源。

### CDN的优势

- **减少延迟**：CDN减少了信息传递的物理距离，显著降低延迟。
- **扩大带宽**：通过多节点分流用户的访问，提升网站能够处理的并发请求量。
- **增强安全性**：许多CDN提供商提供额外的安全性服务，如DDoS攻击保护、数据加密等。

### 注意事项

尽管CDN有显著的性能优势，但它不能完全替代主服务器。某些动态或个性化内容仍然需要从原始服务器加载。因此，CDN是与原始服务器共同工作，作为一种补充以提高性能和可靠性。在选择CDN服务时，还需考虑成本、配置复杂性以及与现有设施的兼容性



# 渲染篇

## 服务端渲染

### 服务端渲染的流程

### 服务端渲染的优缺点

### 对比客户端渲染

## CSS渲染优化

### 提高代码质量

#### 避免过多层数选择器的嵌套

复杂的 CSS 选择器会降低页面的渲染性能。浏览器解析选择器时是从右到左的，所以选择器越多越具体，其需要匹配的标签越多，性能开销越大。尽量避免多层嵌套，使用直接的类选择器、ID选择器可以提升样式计算的效率。【参见CSS匹配规则】

相关技巧：

- 不要在ID选择器前面进行嵌套其它选择器，因为ID选择器本身就可以精确地查找到元素，如果添加其他的选择器，反而增加了查找成本。
- 减少使用标签选择器，因为标签选择器能够能够匹配到的样式很多，如果要匹配某个标签，可以使用类选择器来替代。

#### 避免过多的通配符选择器的内容

因为它会使得浏览器遍历所有的元素，极大的消耗了资源，如果需要对样式进行清除，建议手动指定需要用到的样式。

#### 尽量使用CSS属性的简写

例如想设置四个方向的margin，可以直接使用margin来书写。这是因为：

1. 可以减少文件大小
2. 减少解析时间：简写属性减少了需要被浏览器解析的代码量。更少的代码意味着浏览器可以更快地读取和应用样式规则，从而减少渲染时间。
3. **减少渲染重绘和重流**：一条简写语句设置多个属性可能比多条独立的属性语句在浏览器渲染中引起更少的重绘和重流操作，有助于提高性能。

#### 减少提取代码量的方式

1. 多个元素存在共同的样式，我们可以提取公共的样式；

2. 利用属性的继承，减少CSS代码量。【哪些属性可以继承呢？】

### CSS文件优化

1. 通过压缩CSS文件大小来提高页面加载速度。现在的构建工具，如webpack、gulp/grunt、rollup等也都支持CSS压缩功能。压缩后的文件能够明显减小，可以大大降低了浏览器的加载时间。

2. 随着项目的成长，CSS 文件往往会越来越庞大，这些文件中可能包含了一些未使用到的样式规则。可以使用工具如 PurifyCSS 或 UnCSS 分析 HTML 和 CSS 文件，移除未使用过的样式，减小文件体积，提升加载速度。

### 其他 

1. 避免使用css import导入样式 ，而是使用link标签
   - CSS @import会阻塞页面的渲染，导致页面加载速度变慢。 这是因为浏览器在解析HTML时，如果遇到link标签，会并行下载外部CSS文件，而如果遇到@import规则，会等待当前CSS文件下载完毕后再下载引入的CSS文件。这样就造成了额外的网络延迟和渲染延迟。
   - CSS @import会影响CSS文件的缓存，导致页面性能下降。这是因为浏览器在缓存CSS文件时，会根据link标签的属性来判断是否需要缓存，而@import规则则不受这些属性的影响。这样就可能导致浏览器每次都需要重新下载引入的CSS文件，而不是从缓存中读取。
2. 尽量减少页面的重绘和重排

### CSS选择器匹配

#### 为什么CSS匹配从右到左

CSS 选择器的匹配规则是从右向左进行的，这种方式源于CSS选择器的匹配机制优化。这个过程称为“右向左解析”。以下是其背后的逻辑：

1. **效率优化**：浏览器在解析 DOM 时，对每个元素都会尝试查找匹配的 CSS 规则。由于最右侧的选择器称为关键选择器（key selector），它直接指明了要样式化的元素类型，在 DOM 树中通常存在大量相同类型的元素。开始匹配关键选择器可以迅速确定是不是潜在的匹配元素，然后再向上回溯其父元素进行进一步匹配，这样能更快排除大量不匹配的元素。
2. **最具体的选择器**：关键选择器通常是最具体的，它表示实际将被应用样式的元素。从这个选择器开始匹配，可以立即确定是否要对元素应用样式。如果关键选择器匹配失败，那么无需检查整个选择器链。
3. **较少的回溯**：如果从左向右解析，浏览器首先会找到匹配复杂选择器最左边部分的所有元素，然后尝试在它们的子孙中找到匹配剩余部分的元素，这样做不仅效率低下，还会引起大量的回溯，增加了计算的复杂性。
4. **DOM结构原因**：DOM树的结构是从上至下（从根元素到叶节点）构建的。在检查是否有CSS规则应用到某个元素时，浏览器已经有了从该元素到根元素的路径，相反的路径则需要额外的计算。从一个元素开始，并向上查找其父元素以匹配选择器的其他部分，符合 DOM 的自然流程。

需要注意的是，虽然选择器的向左解析可能在逻辑上感觉违反直觉，但在实践中它优化了匹配的效率，减少了不相关元素的检查，提高了CSS的解析性能。因此，了解这一机制对于优化 CSS 的选择器写法以及提高页面性能至关重要。

#### CSS选择器匹配过程

当CSS选择器从右向左匹配时，它会首先检查最右侧的关键选择器，然后按照选择器的顺序向左回溯，直到找到匹配所有选择器的元素为止。如果在某一点匹配失败，则不会继续向上或向左匹配。但要记住以下关键点：

1. **关键选择器匹配**：选择器的最右侧（关键选择器）首先与文档中的元素进行匹配。如果与某个元素匹配成功，则选择器的匹配过程将继续。

2. **逐级向上匹配**：匹配过程将继续，从匹配的元素开始，向上检查该元素的父元素、祖父元素等，以查看它们是否符合选择器中剩余部分的条件。如果成功匹配到最左侧的选择器，即整个选择器链从右向左都成功匹配了相应的元素，那么浏览器就不会继续对此选择器链进行匹配。这意味着该选择器链对应的样式规则将会应用到匹配的元素上，同时，浏览器将继续寻找其他元素，以检查它们是否也匹配该选择器链或其他选择器链。例如：

   以 `.parent .child .a` 为例，如果 `.a` 成功匹配某个元素，然后 `.child` 也匹配该元素的直接父元素，最后 `.parent` 匹配了 `.child` 的直接父元素，整个选择器链就完成了匹配，浏览器会应用相关样式。它不会继续检查 `.parent` 的上层元素，这是因为所有需要验证的条件都已经通过，进一步向上匹配已经无需再进行。

   因此，一旦到达一个选择器链中的最左侧，并且完成了匹配，浏览器就会停止对这个特定的选择器链继续向上的匹配过程，并且进行下一个元素的选择器匹配。

3. **不匹配立刻停止**：如果在选择器链的任何点上匹配失败，例如一个子代选择器的父级元素匹配不成功，那么浏览器不会继续向上检查该链，直接跳过，继续检查下一个同样符合关键选择器的元素。

4. **可能到文档的根元素**：匹配过程有可能一直逆向检查到HTML文档的根元素，也就是 `<html>` 标签。如果整个选择器链最终顺利匹配到根元素，那么这个选择器链对当前元素是有效的。

5. **尽早退出**：从性能的角度来看，如果能尽早确定选择器不匹配，那么效率将更高，因为不需要无谓地遍历整个DOM结构。这就是为什么浏览器会在知道剩余的选择器不再可能匹配任何元素时，立即停止匹配过程。

综上所述，匹配过程不一定总是到达HTML根标签，一旦在选择器链中出现不匹配，浏览器就会停止当前路径的匹配，并尝试下一个可能的元素。这个过程效率较高，可以避免不必要的DOM遍历，优化渲染性能。

## 页面渲染优化

### 减少回流和重绘的方式

减少重绘和重排主要关注点在于最小化和集中布局的更改，并且尽可能减少与布局更改有关的操作。如果必须执行这些操作，则采用一些可以避免或减轻回流和重绘代价的技术。

#### 批量修改 DOM

##### 未采用批量修改 DOM 的处理方式

假设我们需要向列表中逐个添加大量的列表项：

```javascript
// 假设我们要向列表中添加大量的列表项
const list = document.getElementById('myList');

for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = 'Item ' + i;
  list.appendChild(li); // 直接向DOM中添加元素
}
```

在上面的代码中，我们在循环体内部创建一个 `li` 元素，并将其直接添加到 `list` 列表中，这个过程重复1000次。

##### 带来的问题

1. **性能问题**：每次调用 `appendChild` 方法时，都会触发浏览器重新计算页面布局（重排/回流），然后再进行重绘操作。由于操作发生了1000次，浏览器就要执行1000次重排和重绘，这会大大降低页面渲染的性能。
2. **用户体验问题**：由于浏览器需要不断地进行重排和重绘，页面可能出现卡顿，用户在这段期间可能无法与页面进行交互，影响用户体验。

##### 使用 DocumentFragment

`DocumentFragment` 是一个轻量级的文档对象，可以作为一个临时容器，来存储将要添加到DOM树中的节点。对 `DocumentFragment` 的修改不会影响实际的DOM树，也不会引起页面的重绘或重排。当所有节点都添加到 `DocumentFragment` 中后，你可以将这个 `DocumentFragment` 一次性地添加到DOM树中，这样就只引起一次重排和重绘。

**例子**：

```javascript
// 假设我们要向列表中添加大量的列表项
const list = document.getElementById('myList');
const fragment = document.createDocumentFragment();

for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = 'Item ' + i;
  fragment.appendChild(li);
}

// 一次性将所有列表项添加到DOM中
list.appendChild(fragment);
```

在上面的例子中，我们通过创建一个 `li` 元素并添加到一个 `DocumentFragment` 中，而不是直接将它们添加到 `<ul>` 或 `<ol>` 元素。然后再将这个 `DocumentFragment` 添加到列表中，这样就最小化了重排和重绘。

##### 使用 innerHTML

使用 `innerHTML` 可以一次性向DOM中写入大量的HTML内容。这种方法比起通过创建单个节点并逐个添加它们进入DOM，可以减少重排和重绘的次数。

**例子**：

```javascript
// 假设我们要向一个容器内添加大量的HTML内容
const container = document.getElementById('myContainer');

let content = '';
for (let i = 0; i < 1000; i++) {
  content += '<div>Item ' + i + '</div>';
}

// 一次性将生成的HTML字符串设置为容器的内容
container.innerHTML = content;
```

在这个例子中，我们构建了一个包含1000个 `<div>` 的大型字符串，并将这个字符串作为HTML内容一次性赋值给 `container` 元素的 `innerHTML`。这样做相比于一次一次地添加单个元素，会触发更少的重排和重绘过程。

##### 总结

确切地说，在一个循环体内直接进行DOM操作，尤其是在大量操作时，会导致以下性能冲击：

- 过多的DOM操作：与内存中的 `DocumentFragment` 相比，直接在DOM上的操作更消耗资源。
- 频繁的回流：当你向页面添加或移除一个DOM节点时，浏览器需要重新计算页面布局。
- 频繁的重绘：当元素的外观发生变化时，比如尺寸大小或者颜色，浏览器需要重新绘制该元素。

因此，通过批量操作的方法可以大幅度减少这些问题的发生，只在所有DOM节点都准备好之后触发一次回流和重绘。这是为什么推荐使用 `DocumentFragment` 或 `innerHTML` 来批量处理DOM操作的原因。

- 使用 `documentFragment` 对象在内存中构建新的DOM结构，然后一次性添加到文档中。
- 使用 `innerHTML` 或 `textContent` 一次性写入大量的HTML内容，而不是逐个DOM元素地添加。虽然 `innerHTML` 非常方便，但它有时候可能会引起安全风险（比如XSS攻击），所以在处理不受信任的内容时需要特别小心。而 `DocumentFragment` 则是一种更为安全的方式来对DOM进行大量修改。

#### 合并多次样式更改

- 尽量避免分散的样式操作，改为一次性更改 `class` 或使用 `cssText` 属性。

  比如我们可以把这段单纯的代码：   

  ```javascript
  const container = document.getElementById('container')
  container.style.width = '100px'
  container.style.height = '200px'
  container.style.border = '10px solid red'
  container.style.color = 'red'
  ```

  优化成一个有 class 加持的样子：   

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
      .basic_style {
        width: 100px;
        height: 200px;
        border: 10px solid red;
        color: red;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script>
    const container = document.getElementById('container')
    container.classList.add('basic_style')
    </script>
  </body>
  </html>
  ```

  前者每次单独操作，都去触发一次渲染树更改，从而导致相应的回流与重绘过程。

  合并之后，等于我们将所有的更改一次性发出，用一个 style 请求解决掉了。 

#### 离线操作DOM

避免频繁地添加或删除DOM元素。如果需要，尽可能在离屏上进行，并最后一次性地将结果添加到DOM树中。

我们上文所说的回流和重绘，都是在“该元素位于页面上”的前提下会发生的。一旦我们给元素设置 display: none，将其从页面上“拿掉”，那么我们的后续操作，将无法触发回流与重绘——这个将元素“拿掉”的操作，就叫做 DOM 离线化。

仍以我们上文的代码片段为例： 

```javascript
const container = document.getElementById('container')
container.style.width = '100px'
container.style.height = '200px'
container.style.border = '10px solid red'
container.style.color = 'red'
...（省略了许多类似的后续操作）
```

离线化后就是这样：

```javascript
let container = document.getElementById('container')
container.style.display = 'none'
container.style.width = '100px'
container.style.height = '200px'
container.style.border = '10px solid red'
container.style.color = 'red'
...（省略了许多类似的后续操作）
container.style.display = 'block'
```

有的同学会问，拿掉一个元素再把它放回去，这不也会触发一次昂贵的回流吗？这话不假，但我们把它拿下来了，后续不管我操作这个元素多少次，每一步的操作成本都会非常低。当我们只需要进行很少的 DOM 操作时，DOM 离线化的优越性确实不太明显。一旦操作频繁起来，这“拿掉”和“放回”的开销都将会是非常值得的。   

#### 优化CSS选择器

- 避免使用复杂的CSS选择器，尤其是那些需要遍历多个DOM层次的选择器。

#### 利用现代布局技术

- 使用Flexbox或Grid布局可以减少不必要的DOM操作和计算。

- 当使用传统布局方法，例如浮动（floats）或定位（positioning），通常需要额外的包装元素或空白占位元素来实现所需的布局。这就意味着布局更改可能需要多个DOM元素的操作，这些操作都可能触发回流或重绘。

  与之相对，Flexbox 和 Grid 提供了基于容器的布局，这意味着大量的布局调整可以通过更改容器的属性而不是修改多个子元素的属性来实现，从而减少DOM操作。

- Flexbox 和 Grid 更加智能地处理空间分配和元素对齐。浏览器的布局引擎内部优化了对 Flexbox 和 Grid 布局的计算，这可以在更改布局时减少计算量，尤其是当处理复杂布局和响应式设计时。

#### 避免触摸`triggers`属性

在DOM中，某些属性的读取或修改会立即要求浏览器重新计算布局，因为这些属性的值是动态计算的，以确保它们是最新并且准确的。这些属性称为“触发”属性，因为它们可以触发回流和重绘。以下是一些常见的触发回流的属性：

- `offsetTop`、`offsetLeft`、`offsetWidth`、`offsetHeight`
- `scrollTop`、`scrollLeft`、`scrollWidth`、`scrollHeight`
- `clientTop`、`clientLeft`、`clientWidth`、`clientHeight`
- 以及许多其他属性和方法

当这些属性被访问时，浏览器必须确保其值是准确的。结合flush队列说明。

#### 缓存Layout信息

- 如果需要多次使用某些属性（例如元素的大小和位置等），在一次读取后将其缓存起来，避免后续引起回流。【可以用来解决上述问题】

#### 使用绝对定位

- 将**影响布局较少**的元素设置为`position: absolute`或`position: fixed`，这样它们的变化不会影响到其他元素。
- 当元素被设置成绝对定位或固定定位时，它们会从文档流中被移除。这意味着它们的布局变化（比如位置和尺寸）不会影响到其他元素的布局。因此，当你修改这些定位元素的属性时，只会影响它们自身，而不会导致其他元素或整个页面的布局重新计算。

#### 利用CSS3硬件加速

- 对于那些会引发视觉变化但不会影响布局的操作（例如动画），使用CSS3的`transform`和`opacity`属性来利用GPU加速。

#### 异步更新

- 使用`requestAnimationFrame`进行视觉更改，确保它们发生在正确的时机，以减少回流和重绘。

# 应用篇

## 懒加载

### 懒加载概述

懒加载是一种性能优化技术，避免一次性加载过多资源。常见应用场景包括图片重的页面、具有长滚动的网站、社交媒体平台、图像画廊和在线商店。使用懒加载，资源（如图片、iframe、脚本等）只有在用户即将看到它们时才开始加载，而不是在页面初次加载时就全部加载。这样可以加快首次页面加载速度，提高用户体验，减少未查看资源的加载，从而节省服务器和用户的带宽。

### 懒加载原理

#### 使用 `data-src` 属性

在懒加载技术中，使用 `data-src` 属性而不是直接设置 `src` 属性的原因是为了防止浏览器在页面加载时立即加载所有图片。传统的 `src` 属性在页面加载时会被浏览器解析，从而导致图片资源的下载，这可能会浪费不必要的带宽，尤其是对于用户并不会立刻查看的图片。

`data-*` 属性用于存储私有的自定义数据，不会被浏览器默认的加载机制处理。在这种情况下，它用来保存图片的真实路径，待图片出现在视口范围内时再通过 JavaScript 从 `data-src` 中读取并设置到 `src`，从而开始下载图片。

#### 如何使用 `data-src`

在 HTML 元素中，把图片的真实路径放在 `data-src` 属性中：

```html
<img data-src="real-image-src.jpg" alt="Lazy Loaded Image">
```

懒加载逻辑检测到该图片需要被加载时（例如，通过 `IntersectionObserver` 或滚动事件发现图片进入视口），则读取 `data-src` 的值，设置给 `src` 属性：

```javascript
const actualSrc = image.getAttribute('data-src');
image.setAttribute('src', actualSrc);
image.removeAttribute('data-src');
```

#### 原理

当 `src` 被设置后，浏览器会开始对该资源的请求和加载，显示图片。移除 `data-src` 同时避免了在未来的逻辑中重复加载同一个图片。

总结来说，使用 `data-src` 是延迟加载的一种常用手段，这样设计可以避免在页面初始加载时加载所有图片资源，从而实现性能优化。

### 实现懒加载的两种方式

#### 使用 `IntersectionObserver`

`IntersectionObserver` 是一个现代的 Web API，用于异步观察目标元素与其父容器或顶级文档视窗（viewport）的交叉状态。当被观察的元素进入视口内时，会执行回调函数。

**实现代码**：

```javascript
const images = document.querySelectorAll("img[data-src]");

const loadImage = (image) => {
    const src = image.getAttribute('data-src');
    if (src) {
        image.src = src;
        image.removeAttribute('data-src');
    }
};

const observer = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
        if (entry.isIntersecting) {
            loadImage(entry.target);
            observer.unobserve(entry.target);
        }
    });
});

images.forEach((image) => {
    observer.observe(image);
});
```

**原理**：

- 创建 `IntersectionObserver` 实例时，指定 `loadImage` 为其回调函数。
- `observer.observe(image)` 调用告诉观测器开始监听指定的元素（这里是图片）。
- 当某个图片进入视口范围内，`IntersectionObserver` 会执行回调。
- 回调函数在确认图片交叉视口（`entry.isIntersecting` 为真）时，用 `data-src` 的值设置 `src` 属性，触发图片加载，并停止监听该图片。

#### 监听滚动事件：

此方法通过监听全局滚动事件来判断图片位置是否到达视口范围，并据此加载图片。

**实现代码**：

```javascript
const onScroll = () => {
    images.forEach((image) => {
        const rect = image.getBoundingClientRect();
        if (rect.top <= window.innerHeight) {
            const src = image.getAttribute('data-src');
            if (src) {
                image.src = src;
                image.removeAttribute('data-src');
            }
        }
    });
};

window.addEventListener('scroll', onScroll);
```

**原理**：

- 监听 `scroll` 事件，为每次页面滚动事件指定处理函数 `onScroll`。
- 在处理函数中，遍历每张图片，使用 `getBoundingClientRect` 检测图片位置。
- 如果图片顶部（`rect.top`）小于或等于视口高度（`window.innerHeight`），表明图片已在视口内或即将进入视口。
- 如果图片处于视口范围内，设置其 `src` 启动图片加载，并移除 `data-src` 属性。

### 两种实现方式的对比

`IntersectionObserver` 方法提供了一个更为优雅和性能更高的懒加载实现，因原生 API 支持交叉检测，并且不需要频繁的事件监听和处理。而滚动事件监听方法虽可行，但每次滚动都会执行计算，这对于性能来说是一个缺点。

`IntersectionObserver` 方法减少了计算量和代码复杂度，提高了性能；但需要注意，它可能不在所有浏览器中都受支持。在使用前应进行特性检测，对不支持的环境提供回退方案。而滚动事件监听方法虽然兼容性更好，但建议采用节流（throttling）或防抖（debouncing）技术减少事件处理函数的调用频率，避免过度消耗资源。

### 判断元素进入视口的方式解析

判断元素是否进入视口（viewport）的两种主要方法有：使用 `IntersectionObserver` API 和通过计算元素位置。

#### 1. 使用 `IntersectionObserver` API

`IntersectionObserver` API 为开发者提供了一种异步检测元素是否进入视口的方法。这个 API 使用了浏览器的内置能力，性能优异，不需要监听滚动事件，并对完整页面或者页面中的某一部分（根元素）进行观察。

javascript

```javascript
const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
        if (entry.isIntersecting) {  // 如果元素和视口发生交叉
            // 元素已进入视口，可以加载内容或者进行其他操作
            // 比如加载图片：
            const img = entry.target;
            const src = img.getAttribute('data-src');
            img.setAttribute('src', src);
        }
    });
}, {
    root: null,   // null 意味着检测视口
    rootMargin: '0px', // Margin around root. 可以是像'10px 20px 30px 40px'这样的值
    threshold: 0.1   // 完全进入视口阈值(0-1)，可以是一个数组
});

// 开始观察一个元素
observer.observe(document.querySelector('#someElement'));
```

这种方法的优点是效率高，代码简洁，且当元素与视口交叉度达到某个阈值时，会触发回调。

#### 2. 通过计算元素位置

手动计算元素位置的方法是利用 `getBoundingClientRect()` 函数来确定元素的位置和大小，然后判断这些信息是否在视口范围内。

```javascript
function isElementInViewport(el) {
    const rect = el.getBoundingClientRect();

    return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
        rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    );
}
```

接下来，可以在 `scroll` 事件回调中使用这个函数：

```javascript
window.addEventListener('scroll', () => {
    const el = document.querySelector('#someElement');
    
    if (isElementInViewport(el)) {
        // 元素进入视口
        // 比如加载图片：
        const src = el.getAttribute('data-src');
        el.setAttribute('src', src);
    }
});
```

这种方法可以在所有支持 `getBoundingClientRect()` 的浏览器中工作，但手动监听滚动事件可能会影响性能，特别是当事件处理函数非常复杂或页面滚动很频繁时。这时建议使用防抖（debounce）或节流（throttle）函数来优化性能。

#### 对比

`IntersectionObserver` 方法更简单，性能更好，且更符合现代 Web 开发的标准。常规的位置计算方法则在 `IntersectionObserver` 不可用的情况下提供了良好的兼容性和后备选项，但需要更多的努力来处理性能问题。

总的来说，`IntersectionObserver` API 是实现元素进入视口检测的首选方式，尤其是在现代浏览器开发中。如果兼容性是一个重要考虑因素，则可能需要实现传统的位置计算方法，并确保适当地处理性能问题。

### 关于获取宽高的方式

#### 获取视口宽高

##### window.innerWidth和window.innerHeight

- 这两个属性提供了包括滚动条在内的整个视口的宽度和高度。

- 示例代码：

  ```javascript
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  ```

##### document.documentElement.clientWidth和document.documentElement.clientHeight

- 这两个属性提供了视口内容区域的尺寸，不包括滚动条。

- 与 `window.innerWidth` 和 `window.innerHeight` 不同的是，`clientWidth` 和 `clientHeight` 在包括滚动条的视图中可能会产生较小的值。

- 示例代码

  ```javascript
  const viewportWidth = document.documentElement.clientWidth;
  const viewportHeight = document.documentElement.clientHeight;
  ```

##### 注意

在现代浏览器及 IE9 以上的浏览器中，可以用 window.innerHeight 属性获取。在低版本 IE 的标准模式中，可以用 document.documentElement.clientHeight 获取，有时候需要进行兼容。   

#### 获取元素宽高

##### offsetWidth和offsetHeight

- 这两个属性提供了元素的宽度和高度，包括内边距（padding）、边框（border）和滚动条，但不包括外边距（margin）。

- 对于隐藏元素（display为none）此属性返回0。

- 示例代码

  ```javascript
  const el = document.querySelector('#element');
  const width = el.offsetWidth;
  const height = el.offsetHeight;
  ```

##### clientWidth和clientHeight

- 这两个属性和 `offsetWidth`、`offsetHeight` 类似，但不包括边框（border）。

- 它们只包含元素的内边距（padding）和内容宽度。

- 示例代码：

  ```javascript
  const el = document.querySelector('#element');
  const width = el.clientWidth;
  const height = el.clientHeight;
  ```

##### getBoundingClientRect()

- 此方法返回元素的大小及其相对于视口的位置信息（包括 top、right、bottom、left、width 和 height）。

- 这些值相对于视口，不包括外边距（margin），包括边框（border）。

- `width` 和 `height` 是元素内容区域加上内边距（padding）和边框（border）的总宽度和高度。

- 示例代码：

  ```javascript
  const el = document.querySelector('#element');
  const rect = el.getBoundingClientRect();
  const width = rect.width;
  const height = rect.height;
  ```

##### scrollWidth和scrollHeight

- 这两个属性包括了元素中的滚动内容尺寸，即使这些内容在视口中不可见。

- 它们可以帮助你知道元素内部内容是否超出了当前显示的界面，从而判断是否出现了滚动条。

- 示例代码：

  ```javascript
  const el = document.querySelector('#element');
  const scrollWidth = el.scrollWidth;
  const scrollHeight = el.scrollHeight;
  ```

#### 注意事项

- 当需要考虑到页面缩放时，应使用页面尺寸的相对单位而不是绝对像素值。
- 获取元素的尺寸可能会导致页面重新计算布局（回流），尤其是在获取布局相关的属性时。因此，在性能敏感的应用中谨慎处理这些操作，并尽可能减少它们的使用次数。
- 当使用 `getBoundingClientRect()` 和滚动属性时，需要考虑到滚动位置的影响。

以上是获取视口宽高以及元素宽高的主要方法和注意事项。这些信息可以帮助开发者实现更丰富的交互效果，并正确地布局页面元素。

## 节流和防抖

### 节流

```javascript
/* 
    节流：事件触发之后，n秒内再次触发无效

*/
function throttle(fn, delay) {
    let timer;
    return function(...args) {
        if (!timer) {
            timer = setTimeout(() => {
                fn.apply(this, args);
                timer = null;
            }, delay);
        }
    }
}

// 使用时的上下文
const obj = {
  value: 'object value',
  log: throttle(function(name) {
    console.log(this.value + name); // `this` 指向 `obj`
  }, 1000)
};

// 当 `log` 方法被调用时，`this` 指向 `obj`
// 1000ms后执行
obj.log("第一次");  

setTimeout(() => {
    // 500ms执行无效
    obj.log("第二次")
}, 500);

setTimeout(() => {
    // 1500ms后执行
    obj.log("第三次")
}, 1500);
```

### 防抖

```javascript
/* 
    事件触发n秒后执行，如果n秒内再次触发，那么重新执行
    - 判断执行了多久？
*/


function debounce(func, n) {
    let t1  = null 
    return function (...args) {
        if (t1) {
            clearTimeout(t1)
        }
        t1 = setTimeout(() => {
            func.call(this, ...args)
            clearTimeout(t1)
        }, n)
    }
}
let cons = function() {
    console.log('hello')
}
let obj = {
    name: 'li',
    print: function(name){
        console.log(this.name + name)
    }
}

obj.func1 = debounce(obj.print, 2000)

// 2000ms后执行
obj.func1('这是啥')

setTimeout(() => {
    obj.func1("第一次")
    // 更新为3000ms后执行
}, 1000);


setTimeout(() => {
    obj.func1('第二次')
    // 3500ms执行
}, 3500)
```

