# JavaScrip基础

### 1. 手写Object.create()

#### 描述用法

- 创建一个新的对象
- 第一个参数为新对象的原型，只能为null/function/object类型
- 第二个参数为新对象设置属性和方法，不能为null

#### 代码

```js
function _create(proto, obj = undefined) {
    // 1. 判断类型
    if (typeof proto !== "object" && typeof proto !== 'function') {
        throw new Error('proto may only be object or null')
    }
    if (obj === null) throw new Error('Cannot convert undefined or null to object')
    // 2. 设置原型
    let newObj = {}
    Object.setPrototypeOf(newObj, proto)
	// 3. 设置对象的属性和方法
    if (obj !== undefined)
        Object.defineProperties(newObj, obj)
    return newObj
}
```

其中2.设置原型可以用以下代码替换：

```js
function F() { }
F.prototype = proto;
let newObj = new F()
```

#### 测试样例

```js
        const person = {
            name: "Alice",
        };

        // 第一个参数传递null时，返回的实例原型为null
        // 第一个参数类型只能是object、function或者null，否则报错。
        // 第二个参数类型，不能是null，否则报错
        // 第二个参数如果不为 undefined ,需要将其挂载到实例的Object.defineProperties 上。

        function _create(proto, obj = undefined) {
            if (typeof proto !== "object" && typeof proto !== 'function') {
                throw new Error('proto may only be object or null')
            }
            if (obj === null) throw new Error('Cannot convert undefined or null to object')
            /* 
            function F() { }
            F.prototype = proto;
            let newObj = new F()
            */
            let newObj = {}
            Object.setPrototypeOf(newObj, proto)

            if (obj !== undefined)
                Object.defineProperties(newObj, obj)
            return newObj
        }
        let a = Object.create(null, {
            'hello': {
                value: 1
            }
        })
        let b = _create(null, {
            'hello': {
                value: 1
            }
        })
        console.log(a)
        console.log(b, typeof b)
```

### 3. new

> [JavaScript实现new - 搜索 - 掘金 (juejin.cn)](https://juejin.cn/search?query=JavaScript实现new&fromSeo=1&fromHistory=0&enterFrom=detail_page&type=0)
>
> [手写源码系列（三）：new操作符的实现 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904005223579655?searchId=20230718212329C8023B9D174858DF57F0)

##### 明确new的特性

1. 构造函数的内容一般是this.xxx = xxx，因此我们要创建一个对象
2. 构造函数创建的对象的原型对象来自于构造函数的prototype属性
3. 如果构造函数返回对象，那么new的对象就是该返回值，否则返回值为新建的对象

##### 实现功能步骤

1. 新建一个空的对象，并配置它的原型对象
2. 将this进行赋值，也就是修改构造函数的this执行，并传递参数
3. 检测返回值

##### 实现new

```js
function myNew(constructor, ...args) {
    // 0. 预处理，判断是不是一个函数
    if (typeof constructor !== "function") throw new Error

    // 1. 创建一个新的对象，对象的原型对象为constructor.prototype
    // create用于创建新对象并且为新对象设置原型对象
    let newObj = Object.create(constructor.prototype)

    // 2. 将参数传入到构造函数中，并且修改构造函数的this指向
    let res = constructor.call(newObj, ...args)

    // 判断返回值:如果是对象，则返回对象，反之返回新对象
    return Object.prototype.toString.call(res) === "[object Object]" ? res : newObj

}

```

##### 测试代码

```js
function Student(name, age) {
    this.class = '3.5';
    // return {
    //     name: name,
    //     age: age
    // }
}	
function myNew(constructor, ...args){....}

let newPerson = new Student('hanson', 18)
let newPerson1 = myNew(Student, 'hanson', 18)
console.log(newPerson)
console.log(newPerson1) 
```



#### 1. 手写防抖函数

> 参考：[ Javascript面试重点-手写防抖节流函数\_手写节流函数\_学全栈的灌汤包的博客-CSDN博客](https://blog.csdn.net/m0_71485750/article/details/125581466)

> 他叫做防抖，是因为他可以防止事件在短时间内被频繁触发，造成回调函数的抖动。就像一个开关，如果你不停地按，灯泡会不停地闪烁，这就是抖动。如果你想让灯泡稳定地亮或灭，你就需要在按开关后等一会儿，这就是防抖。

防抖函数是一种优化高频触发事件的技巧，它的原理是在事件触发后，延迟一段时间再执行回调函数，如果在这段时间内又触发了事件，就重新计算延迟时间。

防抖函数的作用是避免在短时间内重复执行相同的操作，比如搜索框输入、窗口大小改变、滚动条滚动等场景。

防抖函数的实现思路是使用 setTimeout 来延迟执行回调函数，如果在延迟时间内又触发了事件，就清除上一次的定时器，重新设置一个新的定时器。¹²³

防抖函数的一个简单示例代码如下：

```javascript
// 定义一个防抖函数
function debounce(fn, delay) {
  // 定义一个定时器变量
  let timer = null;
  // 返回一个新的函数
    
  // 这里利用了闭包的原理，也就是返回的函数是一个闭包函数
  // 他保存了原函数的中的局部变量timer
  return function(...args) {
    // 获取函数的执行上下文和参数
    // 在事件触发的回调函数中，this就是当前事件
    // 我们要记录当前事件触发的this，然后传递到要执行的函数fn中
    let context = this;   
    // 如果已经设置了定时器，就清除上一次的定时器
    if (timer) {
      clearTimeout(timer);
    }
    // 设置一个新的定时器，延迟执行回调函数
    timer = setTimeout(function() {
      fn.apply(context, args);
      timer = null  
    }, delay);
  };
}

// 定义一个测试用的函数
function log() {
  console.log("Hello");
}

// 给 window 对象绑定一个 resize 事件，使用防抖函数包装 log 函数
window.addEventListener("resize", debounce(log, 1000));
```

#### 2. 手写节流函数

节流函数是一种优化高频触发事件的技巧，它的原理是在事件触发后，一段时间内只执行一次回调函数，如果在这段时间内又触发了事件，就忽略它。

节流函数的作用是控制事件的执行频率，比如拖拽、滚动、动画等场景。

节流函数的实现思路是使用一个标志位来记录回调函数的执行状态，如果标志位为 true，就执行回调函数，并把标志位设为 false，然后设置一个定时器，在一段时间后把标志位设为 true。如果标志位为 false，就不执行回调函数。

节流函数的一个简单示例代码如下：

#### 3. 节流和防抖的区别

防抖和节流的区别主要有以下几点：

- 防抖是在事件触发后，延迟一段时间再执行回调函数，如果在这段时间内又触发了事件，就重新计算延迟时间。节流是在事件触发后，一段时间内只执行一次回调函数，如果在这段时间内又触发了事件，就忽略它。
- 防抖的效果是使得连续触发的事件只执行最后一次，节流的效果是使得连续触发的事件按照固定的频率执行。
- 防抖适用于连续的事件只需触发一次回调的场景，比如搜索框输入、窗口大小改变等。节流适用于控制事件的执行频率的场景，比如拖拽、滚动、动画等。

#### 4. 手写深拷贝

> [JS 从零手写一个深拷贝（进阶篇） - 听风是风 - 博客园](https://www.cnblogs.com/echolun/p/16157161.html)

```js
function deepCopy(obj,map =  new Map()){
    // 判断数据类型
    type = typeof obj
    if ( !obj || type !== "object" ){
        return obj
    }
    if (map.has(obj)){
        return map.get(obj)
    }
    const _obj = Array.isArray(obj) ? [] : {}
    map.set(obj, _obj)
    for (let i in obj){
        _obj[i] = deepCopy(obj[i], map)
    }
    return _obj
}
```

### 手写迭代器

可迭代对象中存在一个Symbol.iterator内置属性，当for...of该对象的时候，返回一个迭代器：iterator对象，该对象存在一个next()方法，用于确定每次迭代返回的数值。next()方法返回一个对象{done: Boolean, value: any}，如果done = true，表示继续迭代，反之停止迭代。

#### 基础使用

实现`for(let i of range)`，其中range中存在开始和停止的数值。

- `Symbol.iterator`：返回一个对象。
- 对象中存在一个next方法，用于检测值是不是结束。

```js
let range = {
    start: 1,
    end: 5
}
range[Symbol.iterator] = function(){
    return {
        cur: this.start,
        end: this.end,
        next(){
            if (this.cur <= this.end){
                return {done: false, value: this.cur++}
            } else {
                return { done: true }
            }
        }
    }
}
for (let i of range){
    console.log(i)
}
```

#### 进阶使用

直接在range函数中实现迭代器功能。

此处`Symbol.iterator`直接返回range对象，其中存在`next()`方法

```js
let range = {
    start: 1,
    end: 5,
    [Symbol.iterator]: function () {
        this.cur = this.start
        return this
    },
    next() {
        if (this.cur <= this.end) {
            return { done: false, value: this.cur++ }
        } else {
            return { done: true }
        }
    }
}
```

#### 测试代码

```js
for (let i of range) {
    console.log(i)
}
```

