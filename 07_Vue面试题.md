# 基础原理

> [前端面试必备 | Vue篇（P1-50）_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/519916612305027072?sourceSSR=search)

## 响应式原理/双向绑定原理

> 相关资源：
>
> - https://www.nowcoder.com/discuss/519916612305027072?sourceSSR=search
> - 三个部分特别详细：[vue3.0 响应式原理(超详细) - 掘金 (juejin.cn)](https://juejin.cn/post/6858899262596448270#heading-25)
> - 简洁版：[Vue3响应式的原理解析 - 掘金 (juejin.cn)](https://juejin.cn/post/7223645554860998711)
> - [Vue3 的 effect、 watch、watchEffect 的实现原理 - 掘金 (juejin.cn)](https://juejin.cn/post/7098303741278814221)
> - 介绍Vue2相关的[【vue】关于vue2和vue3响应式原理的区别_vue2和vue3响应式的区别_打代码能当饭吃？的博客-CSDN博客](https://blog.csdn.net/qq_51307413/article/details/128626092)

> - Vue 响应式是通过数据劫持和发布订阅者模式（重新看看）实现的。
> - Vue.js的双向绑定是通过响应式系统实现的
>

其原理可以概括为以下几个步骤：

1. 【**数据劫持**】Vue.js会在初始化时，通过`Proxy`方法为数据对象定义get和set方法，拦截对象的读取修改操作。
2. 【**依赖收集**】当使用了**模板**或**渲染函数**来定义视图时，Vue 会解析模板或渲染函数中的依赖项，也就是说这些内容要依赖 data 对象中的属性，进而触发代理对象的get方法，在get方法中将对象属性的依赖项收集到一个依赖集合。换句话说，这些依赖项是该属性的订阅者。
3. 【**派发更新**】当代理对象中的属性被修改时，会触发set方法，set方法会通知依赖列表中的所以依赖项进行更新【通知订阅者】。
4. 【**更新视图**】当订阅者依赖项更新通知后，会触发更新函数。更新函数会重新计算虚拟DOM并与实际DOM进行对比，找到差异并进行更新。

通过这种方式，Vue.js实现了数据和视图之间的双向绑定，当数据发生变化时，视图会自动更新；反之，当用户与视图进行交互时，数据也会相应地进行更新。

### Vue中的副作用函数

## 数据劫持实现

### Vue2数据劫持

#### 过程

- Vue2 使用 Object.defineProperty 方法来实现数据代理，Vue2 在初始化时，会遍历 data 对象中的所有属性，使用 Object.defineProperty 把这些属性转化为 getter/setter 形式，这样就可以实现对数据的监听和通知。

#### 缺点

- Object.defineProperty 只能对对象的属性进行拦截，无法**拦截对象本身的操作**，比如新增或删除属性。
- Object.defineProperty 无法监听数组的变化，只能通过**重写数组的原型方法**来实现。
- Object.defineProperty 需要递归遍历 data 对象中的所有属性，并为每个属性创建一个依赖列表，这会消耗一定的性能和内存。 ==？？==

### Vue3数据劫持

在Vue3.x版本中，使用Proxy这个API来实现数据劫持。Proxy可以创建一个对象的代理，对代理对象的访问和修改都会被拦截和处理。

Vue3 实现数据代理的方法有以下几个优点：

- Proxy 可以拦截对象本身的操作，比如新增或删除属性。
- Proxy 可以监听数组的变化，无需重写数组的原型方法。
- Proxy 只需要对 data 对象进行一层代理，无需递归遍历所有属性。

缺点

- [Proxy 的兼容性不太好，它只能在支持 ES6 的浏览器或环境中使用](https://zhuanlan.zhihu.com/p/60791215)[2](https://zhuanlan.zhihu.com/p/60791215)。
- [Proxy 的性能可能不如 Object.defineProperty，因为它需要额外的时间和资源来处理拦截器](https://www.bing.com/search?form=MY0291&OCID=MY0291&q=Bing+AI&showconv=1&rdr=1&rdrig=BE6B748A75CA463CB85944740013F72D#)[3](https://bing.com/search?q=数据劫持使用proxy有什么缺点)。
- [Proxy 的使用可能会引起一些意料之外的问题或错误，比如循环引用，死循环，内存泄漏等](https://blog.csdn.net/CHLing19971130/article/details/124101312)[4](https://blog.csdn.net/CHLing19971130/article/details/124101312)。

## 响应式函数

ref和reactive可以直接替换吗

### Reactive

实现引用数据类型的响应式 

#### 原理

proxy实现的

### ref

基本数据类型的响应式

#### 原理

先新建一个对象，然后value值为需要代理的响应式数据。再使用proxy进行代理，返回proxy对象。

```js
function ref(value) {
  // 创建一个原始值的副本
  let _value = value;
  // 创建一个代理对象
  let proxy = new Proxy({}, {
    // 拦截get操作
    get(target, key, receiver) {
      // 如果访问的是value属性，就返回原始值的副本
      if (key === 'value') {
        return _value;
      }
      // 否则，就按照正常的get操作进行
      return Reflect.get(target, key, receiver);
    },
    // 拦截set操作
    set(target, key, value, receiver) {
      // 如果修改的是value属性，就更新原始值的副本，并触发依赖更新
      if (key === 'value') {
        _value = value;
        trigger(proxy, 'set', key, value);
        return true;
      }
      // 否则，就按照正常的set操作进行
      return Reflect.set(target, key, value, receiver);
    }
  });
  // 返回代理对象
  return proxy;
}

```

### 面试题

- 为什么不使用reactive来监听基本数据类型？

  因为Proxy不能直接代理基本数据类型，每次都要使用创建新的对象使用proxy代理，所以使用ref，利用defineProperty实现响应式。

## 三种数据相关方法对比

### 计算属性

计算属性是基于响应式数据进行缓存的。只有当响应式依赖发生变化的时候，计算属性才会重新计算。也就是说，当响应式数据未发生变化，我们读取计算属性的时候，是从缓存中读取的。

##### 应用场景

- 同步
- 简单计算一个属性

##### Tips

- 响应式数据发生变化并且读取计算属性的时候，才会重新计算。响应式数据变化，计算属性并不会立刻重新计算。

##### 实现原理

- 计算属性被包裹在副作用函数中，并被在调度选项中设置了lazy标签，只有读取该值的时候，才会计算。
- 计算属性的副作用函数中有个缓存布尔值，表示是否需要重新计算。
- 默认为false，但是当响应数据变化时，在调度选项中设置为True。
- 当获取数据的时候，如果为True，那么重新计算，并设置为false

### methods

methods本身是一个Vue实例中的函数，每次调用都会被执行。

##### 场景

当做一个函数来看待，封装重复使用的代码

### watch

Vue中的监听器，当数据发生变化的时候，执行响应的回调。

##### 场景

异步操作：网络请求，复杂计算

##### 实现原理

手动为监听对象，添加了一个副作用函数，也就是依赖项。当数据发生变化，触发trigger。

## 常见的修饰符

- v-on: 单向数据绑定

- v-model: 双向数据绑定

- v-slot="data"： 接收子组件插槽传递的数据

- v-bind/@事件名: 绑定事件

  | 修饰符名称 | 作用                                                         |
  | ---------- | ------------------------------------------------------------ |
  | .stop      | 停止事件的传播，这里的事件指的是，事件在此处执行完毕后停止传播，包括冒泡和捕获，如果使用捕获，那么要用.capture。【1】 |
  | .capture   | 该事件在捕获阶段触发（默认是冒泡阶段），冒泡阶段不会再次触发； |
  | .prevent   | 取消默认行为；【2】                                          |
  | .self      | 仅当 event.target 是元素本身时才会触发事件处理器，可以理解为该标签的事件触发，只能是本事的时候触发，对于冒泡或者捕获来的事件并不会触发。 |
  | .once      | 绑定一个一次性的事件，也就是事件只会被最多触发一次。         |
  | .passive   | 主要用与提升滚动事件的性能 ※，这里没实践                     |

  #### 案例

  ```js
  function clickHandler(text, event){
      // event.stopPropagation();
      console.log(text)
  }
  ```

  【1】停止捕获的传递

  ```vue
      <div class="box1" @click.capture.stop="clickHandler('box1', $event)">
          <div class="box2" @click="clickHandler('box2', $event)">
              <div class="box3" @click="clickHandler('box3', $event)"></div>
          </div>
      </div>
  ```

  点击box3，只会打印box1，事件到达box1之后，因为在捕获阶段触发，并且加了stop，那么事件就不会继续传递了

  【2】默认行为有哪些？

  取消默认行为是指阻止浏览器执行某些事件的自动响应，比如跳转链接、提交表单、弹出右键菜单等 。

  常见的默认行为有以下几种¹：

  - 点击一个链接 —— 触发导航（navigation）到该 URL。
  - 点击表单的提交按钮 —— 触发提交到服务器的行为。
  - 在文本上按下鼠标按钮并移动 —— 选中文本。
  - 在 <input> 字段上的 mousedown 会导致在其中获得焦点，以及 focus 事件。
  - 在网页上滚动鼠标滚轮 —— 网页的滚动条会动。
  - 在网页上点鼠标右键 —— 弹出右键菜单。

  如果我们想要阻止这些默认行为，我们可以使用 .prevent 修饰符或者在事件处理器中调用 event.preventDefault() 方法。例如：

  ```html
  <!-- 阻止链接跳转 -->
  <a href="/html" @click.prevent>HTML</a>
  
  <!-- 阻止表单提交 -->
  <form @submit.prevent="onSubmit">...</form>
  
  <!-- 阻止右键菜单 -->
  <div @contextmenu.prevent="showMenu">...</div>
  ```

## 修饰符原理

### v-if/show

#### v-if

- v-if是根据条件来渲染的，如果为假，不会被渲染为虚拟dom，进而不会出现在渲染树上。
- v-if有更高的切换开销，因为每次切换都需要销毁和重建元素及其内部的事件监听器和子组件。
- v-if适合运行时条件很少改变的场景，例如根据用户权限来显示不同的内容

#### v-show

- v-show是通过修改元素的display样式属性来控制元素的显示和隐藏，无论条件是否为真，元素都会出现在DOM树中，只是简单地切换CSS。
- v-show有更高的初始渲染开销，因为即使元素不可见，也需要占用DOM空间。
- v-show适合需要非常频繁地切换的场景，例如根据用户操作来切换标签页或折叠面板。


### v-model的语法糖

#### 作用在表单上

```html
<input v-model="message">
<input 
       :value = "message"
       @input="message=$event.target.value"
/>
```

- input输入框中的value，表示的事输入框显示的内容，因此将其绑定到了"message"身上，所以message被修改之后，输入框的值也会变化。
- input输入框绑定了input事件，当该事件触发时，执行代码；
- 代码内容为将事件对象的value赋值给message，这样input输入框的值就变化了。

#### 作用在组件上

> [组件 v-model | Vue.js (vuejs.org)](https://cn.vuejs.org/guide/components/v-model.html)

#### 用途

子组件绑定v-model的用途是为了实现==父子组件之间的双向数据绑定==，也就是说，当父组件中的数据变化时，子组件中的表单元素也会自动更新；当子组件中的表单元素变化时，父组件中的数据也会自动更新。这样，我们就可以在父子组件之间共享和同步数据，而不需要手动地传递属性和监听事件。

例如，假设我们有一个子组件`<CustomInput>`，它封装了一个输入框，并且接收一个modelValue属性和发射一个update:modelValue事件。我们可以在父组件中使用v-model来绑定一个message数据到子组件上：

```vue
<custom-input v-model="message" />
```

这样，当我们在输入框中输入内容时，message会自动更新；当我们在父组件中修改message时，输入框中的内容也会自动更新。

#### 原理

**父组件**

```vue
<CustomInput v-model="searchText" />
```

等价于

```vue
<CustomInput
  :modelValue="searchText"
  @update:modelValue="newValue => searchText = newValue"
/>
```

**子组件**

处理传递的props以及事件

```vue
<!-- CustomInput.vue -->
<script setup>
defineProps(['modelValue'])
defineEmits(['update:modelValue'])
</script>

<template>
  <input
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  />
</template>
```

### v-if和v-for优先级

## 特殊函数、方法

### nextTick

> [你真的理解$nextTick么 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903843197616136?searchId=20230911160625EC8C82FCDBC1BB0FFB6A)
>
> [Vue.$nextTick你真的懂了吗？？？ - 掘金 (juejin.cn)](https://juejin.cn/post/7007328894621581349?searchId=20230911160625EC8C82FCDBC1BB0FFB6A)

#### 概念

vue中的nextTick是一个方法，它的作用是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，可以获取更新后的DOM。

#### 原理

- 当Vue检测到响应式数据变化时，Vue不会立即更新DOM，而是将所有的副作用放入一个异步更新队列（async update queue），并在下一个事件循环（event loop）的tick中批量执行它们。这样可以避免多次重复渲染，提高性能和一致性。

  一种简单的实现方式如下：

  ```js
  const jobQueue = new Set()
  const p = Promise.resolve()
  
  let isFlushing = false
  
  function flushJob() {
      if (isFlushing) return
  
      // 一旦 flushJob 函数开始执行，isFlushing 标志就会设置为
      // true，意思是无论调用多少次 flushJob 函数，在一个周期内都只会执行一次.
      // 其实就是这个函数本身具有去重抵御机制。
      isFlushing = true
      p.then(() => {
          jobQueue.forEach(job => job())
      }).finally(() => {
          isFlushing = false
      })
  
      //  这个功能有点类似于在 Vue.js 中连续多次修改响应式数据但只会触发一次更新
  }
  
  effect(() => {
      console.log(obj.foo)
  }, {
      scheduler(fn) {
          // 强行将 fn 放到宏任务 (Macro task) 队列中，等待下一次事件轮询
          // setTimeout(fn)
  
          jobQueue.add(fn)
          flushJob()
      }
  })
  ```

- 而nextTick(callback)，它可以让我们在异步更新队列被清空，也就是DOM被更新之后执行回调函数。这样可以让我们在合适的时机**操作更新的DOM或执行其他逻辑**。

- Vue内部使用了Promise.then()或MutationObserver等API来实现nextTick函数，它们都属于微任务（microtask）。微任务会在当前事件循环结束时执行，优先于宏任务（macrotask），如setTimeout或setInterval等。这样可以保证nextTick函数尽可能早地执行，而不会被其他异步任务阻塞。

  

#### 场景

- 当需要在数据变化后操作更新后的DOM时，例如获取某个元素的高度或宽度，或者滚动到某个位置等。
- 当需要在组件渲染完毕后执行一些操作时，例如设置焦点或者触发一些动画效果等 。
- 当需要在父子组件通信时保证子组件已经更新完毕时，例如父组件通过\$emit触发子组件的事件，然后通过$refs访问子组件的方法或数据等。

### scoped的原理

当你在style标签上添加了scoped属性时，Vue会为你的组件生成一个唯一的哈希ID，比如data-v-12e4e11e。然后，Vue会在编译template标签时，为每个元素添加这个ID作为一个属性，比如`<div data-v-12e4e11e>`。同时，Vue也会在编译style标签时，为每个CSS选择器添加这个ID作为一个属性选择器，比如div[data-v-12e4e11e]。这样，就实现了样式的隔离和模块化，只有拥有相同ID的元素和选择器才能匹配。

## Vue2经典问题

### 为什么组件对象中的data是个函数而不是对象

组件对象中的data是被代理的数据。

如果写成对象，那么组件实例的数据代理的对象都是同一个对象，因此如果该组件的多个组件实例存在，就会导致一个组件实例对该数据修改，会影响到其他的组件实例。

如果写成函数，每次返回的都是一个新的对象，是对新的对象的代理，因此不会造成上述问题。

使用外部对象的情况，和上述相同！

# 生命周期

## Vue的生命周期

### 精简版

Vue的生命周期是指Vue实例从创建到销毁的过程，其中包含了一些特定的阶段，称为生命周期钩子。生命周期钩子是一些函数，可以在特定的阶段执行自定义的代码。

Vue的生命周期主要有以下几个阶段：

**beforeCreate**

> 数据观测和事件配置还未初始化。

这个钩子通常用于执行一些全局的设置或配置，比如引入插件、设置过滤器、注册指令等。

**注**：

- 数据观测，是指Vue对数据对象进行数据劫持的过程，也就是给每个属性添加getter和setter，实现数据的响应式变化。

- 事件配置就是让Vue实例能够监听和触发一些自定义的事件，比如你可以在一个组件里面发出一个叫做"hello"的事件，然后在另一个组件里面监听这个事件，当这个事件发生时，就执行一些操作，比如弹出一个对话框。

- 事件配置是在Vue实例创建完成后就已经设置好了，也就是说你可以在任何时候使用$on、$emit、\$off这些方法来操作事件。\$on是用来监听事件的，\$emit是用来触发事件的，$off是用来取消监听事件的。

**created**

> 在实例创建完成后，数据观测和事件配置已经初始化，但是模板编译和挂载还未开始。

这个钩子通常用于执行一些与数据相关的操作，比如发送AJAX请求、初始化状态、设置定时器等。

**beforeMount**

> 在模板编译完成后，实例准备挂载到DOM之前。Vue已经完成了模板编译，生成了虚拟DOM，但是还没有将它们插入到真实的DOM节点中，也就是说页面还没有渲染出来。

**mounted**

> 在实例挂载到DOM之后，可以访问到DOM节点，并且可以进行一些依赖于DOM的操作。

在mounted阶段，我们一般可以进行一些依赖于DOM的操作，比如获取DOM元素，绑定DOM事件，使用第三方库或插件等。

**beforeUpdate**

> 在响应式数据发生变化时，重新渲染之前。

**updated**

> 在响应式数据发生变化后，重新渲染完成后，可以获取到更新后的DOM节点。

**beforeUnmount**

> 在实例销毁之前，可以进行一些清理工作，如移除事件监听器或定时器等。

**unmounted**

> 在实例销毁之后，所有的数据绑定和事件监听器都被移除，子组件也被销毁。

这些生命周期钩子可以让我们在不同的时机执行不同的逻辑，比如发送请求、操作DOM、添加动画等。

**额外的两个生命周期钩子**

1. 路由组件所独有的两个钩子，用于捕获路由组件的激活状态。
2. 因为这个路由使用keep-alive，对组件进行缓存——在组件切换过程中将状态保留在内存中， 防止重复渲染 DOM  

- 当组件被换掉时，会被缓存到内存中， 触发 deactivated 生命周期；

- 当组件被切回来时，再去缓存里找这个组件， 触发 activated 钩子函数  



### 详细版

你好，这是Bing。我很高兴你对Vue的生命周期感兴趣。😊

Vue的生命周期是指一个组件实例从创建到销毁的过程中，经历的一系列阶段和事件。在每个阶段和事件中，Vue会提供一些特殊的函数，叫做生命周期钩子（lifecycle hooks），让开发者可以在特定的时机执行自己的代码，从而实现一些自定义的功能或逻辑。

Vue的生命周期可以分为以下几个阶段：

- 创建阶段：这个阶段是在组件实例被创建之前和之后进行的，包括以下几个步骤：

  - 创建Vue实例：这是在组件实例被创建之前进行的，Vue会先从组件的**配置对象**中获取一些数据或选项，比如props、inject、mixins、extends等，并将它们合并到组件实例的\$options属性中。这些数据或选项可以在组件的其他钩子中通过this.$options来访问，但是它们不是响应式的，也不会影响组件的渲染和更新。这些数据或选项通常用于定义一些全局的配置或功能，比如插件、过滤器、指令等。

  - beforeCreate钩子：这是在组件实例被创建之前调用的第一个钩子函数，此时组件还没有初始化数据、方法、计算属性、侦听器等，也没有挂载到DOM上。这个钩子通常用于执行一些全局的设置或配置，比如引入插件、设置过滤器、注册指令等。

  - 初始化数据和方法：这是在组件实例被创建之后进行的，Vue会从组件的配置对象中获取一些数据或选项，比如data、methods、computed、watch等，并将它们**初始化为响应式的数据或状态**，并**添加到组件实例上**。这些数据或状态可以在组件的模板或其他钩子中通过this来访问，而且它们会影响组件的渲染和更新。这些数据或状态通常用于定义一些与业务逻辑相关的功能，比如发送AJAX请求、初始化状态、设置定时器等。

  - created钩子：这是在组件实例被创建之后调用的第二个钩子函数，此时组件已经初始化了数据、方法、计算属性、侦听器等，但还没有挂载到DOM上。这个钩子通常用于执行一些与数据相关的操作，比如发送**AJAX请求、初始化状态、设置定时器**等。

    注：这里初始化状态可以理解为：修改响应式数据等。

- 挂载阶段：这个阶段是在组件实例被挂载到DOM之前和之后进行的，包括以下几个步骤：

  - 编译模板：这是在组件实例被挂载到DOM之前进行的，Vue会将组件的模板（template）编译成渲染函数（render function），渲染函数会返回一个虚拟DOM树（virtual DOM tree），虚拟DOM树是对真实DOM树（real DOM tree）的抽象和模拟，它可以让我们用JavaScript对象来描述UI界面，而不需要直接操作真实DOM。虚拟DOM树可以提高性能和跨平台能力，因为它可以避免不必要的真实DOM操作，并且可以在任何支持JavaScript的环境中运行。
  - beforeMount钩子：这是在组件实例被挂载到DOM之前调用的第三个钩子函数，此时组件已经编译了模板，但还没有渲染到页面上。这个钩子通常用于执行一些与DOM相关的操作，比如添加事件监听器、操作DOM元素等。
  - 渲染和打补丁：这是在组件实例被挂载到DOM之后进行的，Vue会将渲染函数返回的虚拟DOM树转换为真实DOM树，并添加到页面中。这个过程叫做渲染（rendering）。同时，Vue会在虚拟DOM树和真实DOM树之间建立一个映射关系，当数据发生变化时，Vue会重新执行渲染函数，生成一个新的虚拟DOM树，并和旧的虚拟DOM树进行比较，找出差异，并根据差异更新真实DOM树。这个过程叫做打补丁（patching）。
  - mounted钩子：这是在组件实例被挂载到DOM之后调用的第四个钩子函数，此时组件已经渲染到页面上，并且可以访问到DOM节点。这个钩子通常用于执行一些与DOM相关的操作，比如**添加事件监听器、操作DOM元素**等。

- 更新阶段：这个阶段是在组件实例由于响应式数据变化而更新之前和之后进行的，包括以下几个步骤：

  - 数据变化：这是在组件实例由于响应式数据变化而更新之前进行的，Vue会检测到数据的变化，并触发**组件的重新渲染和打补丁**。
  - beforeUpdate钩子：这是在组件实例由于响应式数据变化而更新之前调用的第五个钩子函数，此时组件还没有重新渲染和打补丁。这个钩子通常用于执行一些与数据相关的操作，比如**比较新旧数据、获取快照**等。
  - 重新渲染和打补丁：这是在组件实例由于响应式数据变化而更新之后进行的，Vue会重新执行渲染函数，生成一个新的虚拟DOM树，并和旧的虚拟DOM树进行比较，找出差异，并根据差异更新真实DOM树。
  - updated钩子：这是在组件实例由于响应式数据变化而更新之后调用的第六个钩子函数，此时组件已经重新渲染和打补丁，并且可以访问到更新后的DOM节点。这个钩子通常用于执行一些与DOM相关的操作，比如添加事件监听器、操作DOM元素等。

- 卸载阶段：这个阶段是在组件实例被卸载之前和之后进行的，包括以下几个步骤：

  - 卸载组件：这是在组件实例被卸载之前进行的，Vue会将组件从父组件或者页面中移除，并解绑所有的事件监听器、侦听器、计算属性等。
  - beforeUnmount钩子：这是在组件实例被卸载之前调用的第七个钩子函数，此时组件还没有从DOM中移除，并且仍然可以访问到它。这个钩子通常用于执行一些清理工作，比如**移除事件监听器、取消定时器、关闭连接**等。
  - 从DOM中移除：这是在组件实例被卸载之后进行的，Vue会将组件从DOM中移除，并释放所有的内存空间。
  - unmounted钩子：这是在组件实例被卸载之后调用的第八个钩子函数，此时组件已经从DOM中移除，并且无法再访问到它。这个钩子通常用于执行一些清理工作，比如移除事件监听器、取消定时器、关闭连接等。

以上就是Vue的生命周期及其各个阶段和事件的介绍，你

## created和mounted的区别

created是实现了初始化数据的观测以及事件的注册，还未渲染为虚拟DOM，更没渲染到页面上，因此在该部分，我们主要是来操作数据，也就是做的事情是依赖数据的。例如：发送异步请求，并且不会阻塞页面。

mounted生命周期时DOM已经挂载完毕，视图被渲染。再此处的操作主要是与DOM相关的。

## 一般在什么时候请求异步数据

请求异步数据的最佳生命周期钩子是created。这是因为：

- created钩子会在组件实例被创建之后调用，这时已经初始化了数据和事件等选项，但是还没有挂载到页面上。这个钩子可以用来初始化数据，设置响应式依赖，注册事件监听器等。1
- created钩子比beforeMount和mounted钩子更早执行，所以可以尽快地触发异步请求，可以提高首屏渲染的速度。

如果需要DOM的信息(大小、位置)来请求数据，就可以在mounted生命周期：

- 在mounted生命周期，Vue已经完成了DOM的挂载和渲染，所以我们可以访问到真实的DOM节点。如果我们需要根据DOM的大小或位置来请求数据，就可以在mounted生命周期进行。

## keep-alive中的生命周期

场景 ， 原理 ，实现

13vue的生命周期（页面切出再切入在哪个阶段？http请求在哪个阶段）

# 组件

## 组件原理

### 组件的表示

组件就是一个对象（通过Vue2的角度考虑），其中data是对应的数据，render是模板转化为的渲染函数。同时组件的虚拟DOM的类型就是该对象。

```js
const MyComponernt = {
	name: "xxx",
    data(){
        return {}
    },
    render(){
        return 虚拟DOM
    }
}
const vnode = {
    type: MyComponent
}
```

### 组件的渲染逻辑

#### 组件基本挂载

判断是组件之后，会进入到mountComponent函数中，获取组件对象，解构组件对象，获取date、render等内容，通过render获取组件内部的虚拟DOM，进入patch操作。

#### 组件的响应式

因为render函数中可能会用到this，也就是data中的数据，我们通过`render.call`方法将this指向state的返回值。

再通过`effect`将render和patch作为副作用函数，当数据发生变化时就会重新执行render和patch进行DOM的更新。

同时为了防止频繁更新，可以在effect添加调度器，等到同步任务执行完毕后，再执行副作用函数更新页面。

#### 组件实例

组件实例包含着组件的信息，有组件中的数据（data）、组件是否被挂载（isMounted）以及组件的子树（组件对应的虚拟DOM），组件中数据更新的时候，执行副作用函数时，判断组件是否挂载，如果未挂载，那么旧子节点为null，反之为实例的子树。

#### 组件生命周期

通过解构的方式来获取组件的生命周期，通常来说，生命周期分为beforecreated、created、beforeMounted、mounted、beforeUpdate，updated。那么结合代码来说：

1. 组件实例创建前调用beforecreated；
2. 组件实例创建后，存在响应式数据后，执行created；
3. 在effect副作用函数中，挂载之前执行beforeMounted；
4. patch挂载完毕之后，执行mounted；
5. 当响应式数据发生变化后，此时实例中的isMounted为True，执行patch更新操作，操作之前，执行beforeUpdated；
6. 更新完毕之后，执行uodatad。

#### 组件的props属性

### 组件特性的原理

#### setup的实现

`setup`函数是Vue 3.0新增的一个关键字，它是在组件创建时执行的函数。该函数接收两个参数：`props`和`context`。其中，`props`是一个对象，包含了组件接收到的所有props属性；`context`是一个对象，包含了一些与组件实例相关的属性和方法，例如插槽、事件和组件属性等。在`setup`函数中，我们可以使用这两个参数来访问并设置组件的状态和行为。

在挂载组件的时候，我们执行如下步骤：

1. 调用`setup`函数，获取其返回值。
2. 如果`setup`返回一个对象，该对象为setup定义的响应式数据等，这样我们可以访问`setup`中返回的状态和方法。
3. 如果`setup`返回一个函数，Vue将会认为这个函数是`render`函数，并在每次需要更新组件时调用它。

在setup中我们还可以定义生命周期的内容，setup执行的时候，对应的生命周期函数例如`onMounted`，该函数会将对应的回调函数添加到组件实例对应的生命周期数组中，等到合适的时机来执行。

#### 插槽实现原理

##### 编译阶段

当Vue处理组件模板时，它会对每个`<slot>`元素和插槽内容进行编译：

1. 父级模板编译
   Vue解析父组件模板时，识别到`v-slot`指令，然后它会保留这部分模板作为一个函数（或VNode创建函数），该函数返回这部分内容实际的虚拟DOM，这允许在父作用域中延迟执行这里面的任何绑定或表达式。注意，这个模板片段还没有被插入DOM。
2. 子级模板编译
   在子组件的`<slot>`元素上，编译器会创建一个插槽的出口位置，具体来说，它指的是对于上述插槽函数的调用。在这个`<slot>`位置，Vue知道它需要填充父组件传递的内容。

##### 数据解析和渲染阶段

在组件实例化后：

1. 父组件解析
   当父组件被解析时，会获得父组件模板的Vnode，其中就包含着对于子组件选项对象以及对应的插槽函数，他们会进入到patch，进入子组件渲染。
2. 子组件渲染
   子组件在渲染过程中，会将插槽函数作为子组件实例的属性，并对子组件的实例进行代理为渲染上下文，执行render函数，会调用插槽函数，这时候插槽函数会返回对应的Vnode，这样就实现了父组件的设置的内容，在子组件中显示。

## 内建组件和模块

### KeepAlive组件

#### 使用场景

`<keep-alive>` 组件在Vue中通常用于以下场景：

**数据保留**：
当你希望保持组件状态（例如滚动位置、表单内容或复杂的组件状态）时，特别是在用户在应用的不同视图之间切换时。

**性能优化**：
在应用程序中有些重量级组件的初始化可能特别消耗性能（比如数据的拉取、图表的渲染等）。`<keep-alive>` 可以避免重复的初始化过程，因此可以显著提升性能。

**用户体验提升**：
在多标签界面（例如标签页或者向导）和列表详细信息界面之间切换，用户希望返回时保持之前的浏览状态不变。

#### 使用方法

#### 原理

- **首次渲染**：当 `<keep-alive>` 包裹的组件首次渲染时，它会像任何普通组件一样进行创建和挂载。在此过程中，`<keep-alive>` 指令添加`__isKeepAlive`标识符，并将组件实例及其状态、子组件树以及一些用于内部管理的标识符保存在内部缓存中。
- **缓存机制**：当组件不再被渲染（例如，在使用 `v-if` 控制显示隐藏时），如果判断组件存在`__isKeepAlive`标识符，它不会被销毁。相反，`<keep-alive>` 会保留该组件实例，并将其标记为非活动状态。这一缓存机制确保了组件状态和重要的上下文信息得以保留。
- **生命周期管理**：非活动组件会触发一个 `deactivated` 生命周期事件，而当组件再次被渲染时，则会触发一个 `activated` 生命周期事件。这两个额外的生命周期钩子允许开发者执行一些当组件进入或离开活动状态时的特定逻辑。
- **缓存策略**：通过配置 `<keep-alive>` 的 `include` 和 `exclude` 属性，可以精细控制哪些组件应当被缓存。此策略使得开发者可以根据组件名称来决定哪些组件实例需要被保留或排除。
- **缓存淘汰**：为了维护内存效率，`<keep-alive>` 实现了一个最近最少使用（LRU）的缓存淘汰策略。这意味着长时间未被访问的组件实例可能会从缓存中移除，以释放内存给其他组件实例使用。

### 常见面试题

#### 如何实现数据修改实际页面并不会立即修改？

effect的第二个配置项是调度器渲染，每次数据发生变化的时候，副作用函数并不会立即执行，而是被压入微任务队列，等待同步代码执行完毕之后，再执行对应的副作用函数。





## 组件通讯

### props

在父组件的子组件标签上，来书写要传递的属性值，属性值可以通过v-bind:绑定也可以是静态的属性值。

```vue
<MyBox :count=count></MyBox>
```

在子组件中使用`defineProps`来接收传递的来的props属性

```js
const props = defineProps(["count"])
```

props被传递来不允许被修改。

### $emit 自定义事件 

子 -> 父

### 事件总线

### 依赖注入 

祖 -> 孙

provide提供数据

inject接收数据

这里不止是父子组件还可以是祖孙组件之间。

### ref

[模板引用 | Vue.js (vuejs.org)](https://cn.vuejs.org/guide/essentials/template-refs.html#ref-on-component)

```vue
<script setup>
import { ref, onMounted } from 'vue'
import Child from './Child.vue'

const child = ref(null)

onMounted(() => {
  // child.value 是 <Child /> 组件的实例
})
</script>

<template>
  <Child ref="child" />
</template>
```

### pinia

### Vuex

上面两个的原理



# 路由

## 路由的两种模式

[前端路由](E:\研究生\自我学习\前端学习\前端小知识.md)

## 前端路由和后端路由的理解

### 后端路由

> 什么是后端路由？
>
> 产生前端路由的原因？

后端路由是指在服务器端根据URL的不同来返回不同的HTML文件给浏览器，浏览器再根据HTML文件来渲染页面。这样可以实现SEO优化，保证页面的安全性，适用于**多页面应用（MPA）**。每次发起请求都要刷新页面，用户体验不好，服务器压力大。

### 单页面应用

进而出现了单页面应用

优点：不用每次加载，提高用户体验

缺点：第一次请求会加载大量文件，不能记录用户的前进后退刷新等。

### 前端路由

进而出现了前端路由

## Vue-Router中的路由守卫

### vue中的组件怎么在浏览器中展现的，结合Vue Router、

Vue组件的原理

### 全局路由守卫

- 全局前置路由守卫router.beforeEach -> 进入路由之前执行
- 全局解析路由守卫router.beforeResolve -> 
- 全局后置路由钩子router.afterEach -> 进入路由之后执行

### 路由独享守卫

beforeEach

### 组件内钩子

- `beforeRouteEnter`:渲染组件之前调用
- `beforeRouteUpdate`：地址改变，但是组件被复用的时候调用
- `beforeRouteLeave`：离开组件时被调用

```js
const UserDetails = {
  template: `...`,
  beforeRouteEnter(to, from) {
    // 在渲染该组件的对应路由被验证前调用
    // 不能获取组件实例 `this` ！
    // 因为当守卫执行时，组件实例还没被创建！
  },
  beforeRouteUpdate(to, from) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，
    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`
  },
  beforeRouteLeave(to, from) {
    // 在导航离开渲染该组件的对应路由时调用
    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`
  },
}
```

## Vue-router 动态路由

用法 和 场景

- 

#### 3. Vue渲染的过程

**编译：**Vue模板被编译为渲染函数，即用来返回虚拟DOM树的函数。

**挂载：**运行时渲染器调用渲染函数，遍历返回的虚拟DOM树，并基于它创建实际的DOM节点。这一步会作为响应式副作用执行，因此它会追踪其中所用到的所有响应式依赖。

**更新：**当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟DOM树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实DOM上去。

当Vue渲染一个组件时，它会调用组件的渲染函数，这个函数会返回一个虚拟DOM树，表示组件的视图结构。在这个过程中，渲染函数会访问到一些响应式数据，例如data、props、computed等。这些数据就是渲染函数的响应式依赖，因为它们的变化会影响渲染函数的输出。

Vue会在调用渲染函数时，把它（渲染函数）包装在一个响应式副作用中，这个副作用会记录下所有访问到的响应式依赖，并把自己添加到这些依赖的订阅者列表中。这样，当某个依赖发生变化时，就会触发这个副作用重新执行，从而重新渲染组件。

# Vue3 VS Vue2

4.vue3结合ts的使用
5.为什么vue3 支持ts,他是有什么特性吗

## Vue3的更新

> - [盘点 Vue3 与 Vue2 的区别 - 掘金 (juejin.cn)](https://juejin.cn/post/7067413380922867725)

主要是大面上的：

### 性能提升

Vue3使用了重新编写的响应式系统，Vue2 响应式原理基础是 Object.defineProperty；Vue3 响应式原理基础是 Proxy， 有效的避免了上面的不足。

### 组合式API

Vue3引入了Composition API，它是一种新的编写组件逻辑的方式，可以让开发者更灵活地组织和复用代码，避免了Vue2中Options API带来的代码分散和难以维护的问题。

Composition API还提供了更好的TypeScript支持和自定义Hooks的能力。

### 生命周期

beforeCreate和created合并为了setup生命周期，beforeDestroy、destroyed修改为了onBeforeUnmount、onUnmounted。

在Vue3组合式API中，如果使用生命周期钩子要手动引入。

### 新的模板语法

Vue3支持了一些新的模板语法，比如`<script setup>`、`<style vars>`、`<teleport>`、`<suspense>`等，可以让开发者更方便地编写组件。

其中`<script setup>`可以让开发者在单文件组件中直接使用Composition API；

`<teleport>`可以让开发者将组件渲染到任意位置；`<suspense>`可以让开发者处理异步组件的加载状态。

### 新的状态管理库

Vue3推荐使用Pinia作为状态管理库，它是一个基于Composition API的轻量级替代方案，可以替代Vuex4。Pinia有以下几个优点：API设计更简单直观；完全支持TypeScript；可以轻松地在任何地方使用多个store对象；可以自动追踪任何对state的变更；可以通过插件机制来扩展store对象的功能4。

## Vue3与Vue2原理的差异

setup的实现

ref的底层变化

## 组合式API的优势

#### 代码组织

组合式API可以让开发者按照逻辑关注点来组织和分割代码，而不是按照选项类型来划分代码，从而提高了代码的可读性和可维护性。

#### 逻辑复用

组合式API可以让开发者将组件的逻辑抽象成可复用的函数，从而避免了Vue2中使用混入（mixins）带来的命名冲突、数据来源不明、逻辑分散等问题。组合式API可以让开发者创建自定义的Hooks函数，从而实现一些通用的功能或效果，比如数据获取、表单验证、鼠标跟踪等。

#### 类型支持

组合式API完全支持TypeScript，可以让开发者享受到类型检查、自动补全、重构等优势，而不需要额外的类型声明或断言。



# Vue高级

## 渲染器

DOM渲染的流程

## 虚拟DOM

### 虚拟DOM概念

虚拟DOM是用来描述真实DOM的方式，在JavaScript中，虚拟DOM本身是一个树形结构的对象，对象的属性用来描述真实DOM的内容，并且树形结构的层级关系用来描述真实DOM的层级关系。

### 虚拟DOM结构

Vue中的虚拟DOM是由虚拟节点（Virtual Node，简称VNode）构成的树状结构。VNode是对真实DOM的简洁表示，它是一个普通的JavaScript对象，包含了对应真实DOM节点的描述信息。

一个VNode对象通常包含如下内容：

1. **`tag`**：表示对应的真实DOM标签名，比如`'div'`、`'span'`等。
2. **`data`**：一个包含了该节点的属性、指令、事件监听器等对象。
3. **`children`**：该节点的子节点数组，每个子节点也是一个VNode。
4. **`text`**：如果节点是文本节点，这里会包含其文本内容。
5. **`elm`**：指向该VNode对应的真实DOM节点的引用。
6. **`key`**：当进行列表渲染时，`key`被作为节点的唯一标识使用，用于优化重新渲染过程。
7. **`componentOptions`**：如果VNode是一个Vue组件的实例，这里会包含与组件相关的选项，如props值和事件监听器等。
8. **`componentInstance`**：如果VNode是一个Vue组件的实例，这里将是组件实例的引用。
9. **`context`**：该节点对应的Vue实例，表示创建此节点的上下文。

这个VNode的结构使得Vue能够在内部对生成的DOM树执行优化的渲染和更新操作。VNode作为一个轻量级的对象，比起直接操作真实的DOM要快得多，并且VNode还可以在服务器端渲染（SSR）或跨平台解决方案中使用，提高了Vue应用程序的灵活性和性能。

### 虚拟DOM优势

#### 提高渲染能力

我们知道真实DOM的操作是很耗费资源的，每次修改DOM都会可能会引起浏览器的重绘和重排，影响用户体验。

##### 批处理更新

虚拟DOM允许我们在内存中进行所有的更新，这本身是非常快速的，因为它仅仅是普通的JavaScript对象操作。然后，在一个更新周期内，所有的更改都会被收集并一次性应用到真实的DOM中。这个批处理过程减少了DOM操作的次数，从而提高了性能。

##### 高效地差异比较（Diffing）

当状态变化时，虚拟DOM算法会计算当前虚拟DOM树与上一个虚拟DOM树的差异（Diff）。然后只将差异部分应用到真实的DOM上。这种方法避免了不必要的DOM更新。

#### 跨平台兼容

虚拟DOM可以作为一个中间层，来适配不同的平台和环境，比如浏览器、移动端、桌面端、服务端等。这样可以让开发者使用相同的代码来构建不同的应用，提高代码的复用性和可移植性。在同构渲染中，实际上我们就是使用了同一套的虚拟DOM，其用来描述Vue模板的结构，在服务端层面，我们利用虚拟DOM生成对应的HTML字符并进行拼接，在客户端层面，我们利用虚拟DOM来建立与真实DOM的联系，实现框架的响应式。

但是也会存在问题：

### 虚拟DOM的不足

#### 影响首次渲染

首次渲染时，多了一层虚拟DOM的计算，所以会比不使用虚拟DOM慢一些，但是能够在DOM更新或者修改时更快。

虚拟DOM可以没有吗(回去再看看)

### 虚拟DOM算法

#### 简单diff算法

1. 两层循环

   - 第一层是新节点的子节点

   - 第二层是旧节点的子节点

2. 遇到 类型 和 key 相同的节点， 首先patch更新他们的子节点，算作是使得两节点内容相同

3. 然后根据新旧节点所在的索引，更新位置，如果当前节点的旧节点小于前面最大的旧节点的索引就移动位置。

#### 双端diff算法

当进行子节点更新时，Vue的diff算法做了如下优化：

1. **移动指针**：
   在更新过程中，有四个指针被移动，分别对应旧子节点和新子节点的开始和结束位置。通过比较这四个指针所指向的节点，算法可以快速识别出不需要变动的节点。
2. **头头（头部与头部）比较**：
   如果新旧两个子节点的开始节点（头部节点）相同，就直接跳过。
3. **尾尾（尾部与尾部）比较**：
   如果新旧两个子节点的结束节点（尾部节点）相同，也跳过。
4. **头尾（头部与尾部）比较**：
   如果旧的开始节点和新的结束节点相同，说明旧的开始节点需要移动到尾部。
5. **尾头（尾部与头部）比较**：
   如果旧的结束节点和新的开始节点相同，说明旧的结束节点需要移动到开始的位置。

如果上述过程中，发现没有可复用的节点，那么就从旧头开始遍历直到找到下个与新头相同的节点，然后复用，再执行上述操作。

#### 快速diff算法

快速diff算法是一种用来比较两棵虚拟DOM树的差异，并且根据差异来更新真实DOM的技术。它的核心思想是只比较同一层级的节点，而不是逐层遍历所有节点，这样可以降低时间复杂度从O(n^3)到O(n)。

快速diff算法的过程可以分为以下几个步骤：

1. 首先，从根节点开始，比较新旧两棵虚拟DOM树的根节点，如果它们的类型或者key不同，就直接替换整个树；如果它们的类型和key相同，就进行patch操作，即更新节点的属性和事件等。
2. 然后，比较根节点的子节点序列。
   - 如果新子节点序列为空，就移除所有旧子节点；
   - 如果旧子节点序列为空，就添加所有新子节点。
   - 如果都不为空，在子节点比较的循环中，使用双端比较的方法，也就是同时从子节点序列的头部和尾部进行比较，如果发现相同类型和key的节点，就进行patch操作，并且移动指针；如果发现不同类型或者key的节点，就跳出循环。
   - 然后，在跳出循环后，判断剩余的子节点是否存在乱序或交换的情况，如果存在，就使用最长递增子序列（LIS）的方法来找出最长递增子序列，并且保证通过最小的移动或patch操作实现节点复用；
   - 如果不存在，就直接移动或卸载剩余的子节点。
3. 最后，在完成子节点比较后，递归地对每个有子节点的节点进行相同的过程，直到遍历完整棵虚拟DOM树，并且将所有差异应用到真实DOM上。

### key的用处

#### 概述

核心作用是标记虚拟DOM，通过key以及虚拟DOM的类型，可以判断两个虚拟DOM是否相同，如果相同，我们就可以进行复用，也就是通过对虚拟DOM打补丁，更新节点属性，然后将该节点移动到指定位置，而不用新建DOM，进而实现DOM的复用。

#### 为什么v-for的时候不建议使用index作为key？

v-for的时候不建议使用index作为key，是因为这样可能会导致渲染性能下降，或者出现隐藏的bug。具体的原因和解释如下：

##### 问题1：性能问题

1. 使用索引作为`key`值时，如果数组中的数据顺序改变（如排序操作），或者在数组的中间插入、删除项，Vue将不得不重新渲染更多的组件实例，因为由于`key`的改变，Vue认为这些元素也发生了变化。这导致不必要的DOM更新操作，降低了程序性能。

2. 使用index作为key，也可能会造成数据和视图不一致的问题。例如，如果列表中的每个项都包含一个输入框，并且我们通过输入框修改了列表项的数据，然后我们删除了某个列表项，Vue可能会复用原来的输入框节点，使得输入框中显示的数据和实际的数据不匹配。

为了避免这些问题，我们应该使用与数据相关的唯一值作为key，如id或item本身（前提是item不会重复）。这样Vue就能正确地跟踪每个节点的身份，在节点顺序发生变化时，仅移动/更新变化的节点，而不是重新渲染整个列表

#### 应用

你可以举例说明一下使用key可以带来的性能优化和用户体验提升。

比如，在一个列表渲染中，如果列表的顺序发生了变化，但是列表项的内容没有变化，那么使用key可以避免重新创建和销毁列表项的DOM元素，而只需要移动它们的位置。这样可以减少渲染时间和内存消耗，并且保持列表项的状态和动画效果。

### 最长递增子序列

你好，这是Bing。我可以帮你解答你的问题。😊

Vue3的最长递增子序列体现了什么？这是一个关于Vue3的dom-diff算法的问题，它是用来比较两个虚拟DOM树的差异，并将这些差异应用到真实的DOM上的。Vue3在dom-diff算法上进行了优化，其中就用到了最长递增子序列的概念¹²。

最长递增子序列是一个经典的动态规划问题，它是指在一个数组中找到一个最长的子序列，使得这个子序列中的元素都是严格递增的²³。例如，对于数组[10,9,2,5,3,7,101,18]，它的最长递增子序列是[2,3,7,101]，长度为4。

那么，最长递增子序列在Vue3的dom-diff算法中有什么作用呢？简单来说，它可以帮助我们找到两个虚拟DOM树中相同位置的节点，并且尽可能地减少节点的移动次数，从而提高性能¹²。

具体来说，当我们要比较两个列表中的节点时，我们首先会去除相同前置和后置元素，然后对剩余的元素进行diff。为了找到相同位置的节点，我们会根据节点的key属性来判断它们在原列表中的位置，并得到一个位置数组。例如，原列表为[a,b,c,d,e,f]，新列表为[a,d,b,c,e,f]，则位置数组为[0,3,1,2,4,5]。接下来，我们就要计算这个位置数组的最长递增子序列，因为这个子序列表示了不需要移动的节点。在这个例子中，最长递增子序列为[0,1,2,4,5]，对应的节点为[a,b,c,e,f]。那么，我们只需要移动d节点到b和c之间即可完成diff¹²。

通过这种方式，我们可以避免不必要的节点移动，并且保证最终渲染出来的DOM树和新列表一致。这就是Vue3的最长递增子序列体现了什么。

## 编译器

首先，当我们在Vue中写一个组件模板时，Vue.js的模板编译器用于把模板编译为渲染函数，渲染函数用于生成虚拟DOM，然后进入到渲染器里工作。

它的工作流程大致分为三个步骤。

1) 分析模板，将其解析为模板 AST

2. 将模板 AST 转换为用于描述渲染函数的 JavaScript AST。

3) 据 JavaScript AST 生成渲染函数代码。

Vue.js的编译器主要负责上述任务，并分为三个阶段：`parse`、`transform`和`generate`。

### Parse阶段

在**解析阶段**，编译器会将我们写的模板字符串解析成一个抽象的语法树，这个树我们简称为AST。

具体来说首先将Vue模板转化为一个个Token用来表示标签信息。

然后通过栈的方式，来将Token数组转换为对应的模板AST。

这个AST代表了我们模板的结构，其中包含了诸如标签、属性、文本和其他指令等信息。

```html
<!-- 示例模板 -->
<template>
  <div class="alert" v-if="showAlert">{{ message }}</div>
</template>
```

编译器会读取这个模板，并创建一个描述它的AST。这个过程类似于将我们的源代码转换成一系列JavaScript对象。

### Transform阶段

接下来在**变换阶段**，编译器遍历模板AST并针对不同的标签内容执行不同的转换操作，转化为JavaScriptAST。

识别并优化Vue的指令，如`v-if`、`v-for`等。例如，它会处理条件渲染（`v-if="showAlert"`），将它转化为JavaScript的条件语句。同时，它也会标记静态节点，这样在页面重绘时，Vue可以跳过这些节点，提高更新效率。

### Generate阶段

最后，在**代码生成阶段**，编译器会将优化后的AST转换成渲染函数。渲染函数是实际创建VNode（虚拟DOM节点）的地方，Vue在运行时会利用这些VNode来创建对应的真实DOM。

面试官，就拿刚刚的模板来举例，最后生成的渲染函数可能是这样的：

```javascript
render() {
  return this.showAlert ? h('div', { attrs: { class: 'alert' } }, this.message) : null;
}
```

这个函数体现了逻辑上的等价性：如果`showAlert`为true，我们创建了一个`div`元素，并附上一个文本节点为`this.message`。如果为false，则不渲染任何东西（返回`null`）。`h`是创建VNode的帮助程序（也称为`createElement`）。

## 相关面试题

### vue编译到渲染的原理

Vue模板 -> 真实DOM的过程

1. 首先讲解编译器的作用，干了什么？
2. 再讲解渲染器的作用，干了什么？

### Vue设计到Vue代码转化为js等

### 说一下render

# 实战

1. 写一个验证手机号的vue组件，要求点击之后出现倒计时60s，帮我挑出了很多代码规范问题



# 相关概念

## 1. MVVM、MVC、MVP之间的区别吗？

MVVM、MVC、MVP都是软件架构设计模式，它们通过分离数据、视图和逻辑来组织代码，提高开发效率和可维护性。它们的区别主要在于数据和视图之间的通信方式和数据流方向。

MVC表示模型-视图-控制器，它将应用程序抽象为数据层（Model）、视图层（View）和逻辑层（Controller）。Model负责存储和操作数据，View负责显示数据，Controller负责处理用户交互和业务逻辑。在MVC中，Model和View可能有耦合，即它们可以直接通信，也可以通过Controller通信。数据流的方向是双向的，即Model和View都可以影响对方。

MVP表示模型-视图-演示者，它是对MVC的改进，它将应用程序抽象为数据层（Model）、视图层（View）和逻辑层（Presenter）。Model负责存储和操作数据，View负责显示数据，Presenter负责处理用户交互和业务逻辑。在MVP中，Model和View之间不直接通信，而是通过Presenter通信。Presenter是View和Model之间的桥梁，它将Model的变化同步到View上，也将View的操作反馈到Model上。数据流的方向是单向的，即只有Model可以影响View，而View不能影响Model。

MVVM表示模型-视图-视图模型，它是对MVP的改进，它将应用程序抽象为数据层（Model）、视图层（View）和逻辑层（ViewModel）。Model负责存储和操作数据，View负责显示数据，ViewModel负责处理用户交互和业务逻辑。在MVVM中，Model和View之间也不直接通信，而是通过ViewModel通信。ViewModel是一种特殊的Presenter，它使用双向数据绑定技术来自动将Model的变化同步到View上，也将View的操作反馈到Model上。数据流的方向是双向的，但是由框架自动管理，开发者不需要手动操作。

## 单页面和多页面

# 其他

## 1. 副作用函数

副作用函数是指在执行函数的过程中，除了返回函数值之外，还对函数外部的环境或数据产生了影响的函数。副作用函数通常会改变全局变量、修改参数、打印输出、抛出异常、调用其他有副作用的函数等。

在Vue中，副作用函数指的是根据数据对页面内容进行修改的函数，这类函数执行组成了页面的渲染。

## 2. 一个组件存在多个副作用函数？

假如说，组件中的数据是响应式的，那么对于该组件，会用到几个副作用函数呢？这要根据具体的情况而定，但一般来说，至少会有以下几个副作用函数：

- 一个渲染副作用函数，用来渲染和更新组件的视图：render + patch
- 一个生命周期副作用函数，用来执行onMounted、onUpdated等钩子
- 一个或多个自定义副作用函数，用来执行watchEffect或watch等自定义逻辑
  当然，如果组件中还有其他的响应式数据或逻辑，可能还会有更多的副作用函数。









