# Vue原理

> [前端面试必备 | Vue篇（P1-50）_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/519916612305027072?sourceSSR=search)

## 1、Vue响应式原理/双向绑定原理

> 相关资源：
>
> - https://www.nowcoder.com/discuss/519916612305027072?sourceSSR=search
> - 三个部分特别详细：[vue3.0 响应式原理(超详细) - 掘金 (juejin.cn)](https://juejin.cn/post/6858899262596448270#heading-25)
> - 简洁版：[Vue3响应式的原理解析 - 掘金 (juejin.cn)](https://juejin.cn/post/7223645554860998711)
> - [Vue3 的 effect、 watch、watchEffect 的实现原理 - 掘金 (juejin.cn)](https://juejin.cn/post/7098303741278814221)
> - 介绍Vue2相关的[【vue】关于vue2和vue3响应式原理的区别_vue2和vue3响应式的区别_打代码能当饭吃？的博客-CSDN博客](https://blog.csdn.net/qq_51307413/article/details/128626092)

> - Vue 响应式是通过数据劫持和发布订阅者模式实现的。
> - Vue.js的双向绑定是通过响应式系统实现的
>
> 其原理可以概括为以下几个步骤：

1. 【**数据劫持**】Vue.js会在初始化时，通过`Proxy`方法为数据对象定义get和set方法，拦截对象的读取修改操作。
2. 【**依赖收集**】当使用了**模板**或**渲染函数**来定义视图时，Vue 会解析模板或渲染函数中的依赖项，也就是说这些内容要依赖 data 对象中的属性，进而触发代理对象的get方法，在get方法中将对象属性的依赖项收集到一个依赖集合。换句话说，这些依赖项是该属性的订阅者。
3. 【**派发更新**】当代理对象中的属性被修改时，会触发set方法，set方法会通知依赖列表中的所以依赖项进行更新【通知订阅者】。
4. 【**更新视图**】当订阅者依赖项更新通知后，会触发更新函数。更新函数会重新计算虚拟DOM并与实际DOM进行对比，找到差异并进行更新。

通过这种方式，Vue.js实现了数据和视图之间的双向绑定，当数据发生变化时，视图会自动更新；反之，当用户与视图进行交互时，数据也会相应地进行更新。

### Vue中的副作用函数

## 2. OdefineProperty与Proxy

### Vue2数据劫持

#### 过程

- Vue2 使用 Object.defineProperty 方法来实现数据代理，Vue2 在初始化时，会遍历 data 对象中的所有属性，使用 Object.defineProperty 把这些属性转化为 getter/setter 形式，这样就可以实现对数据的监听和通知。

#### 缺点

- Object.defineProperty 只能对对象的属性进行拦截，无法**拦截对象本身的操作**，比如新增或删除属性。
- Object.defineProperty 无法监听数组的变化，只能通过**重写数组的原型方法**来实现。
- Object.defineProperty 需要递归遍历 data 对象中的所有属性，并为每个属性创建一个依赖列表，这会消耗一定的性能和内存。 ==？？==

### Vue3数据劫持

在Vue3.x版本中，使用Proxy这个API来实现数据劫持。Proxy可以创建一个对象的代理，对代理对象的访问和修改都会被拦截和处理。

Vue3 实现数据代理的方法有以下几个优点：

- Proxy 可以拦截对象本身的操作，比如新增或删除属性。
- Proxy 可以监听数组的变化，无需重写数组的原型方法⁵。
- Proxy 只需要对 data 对象进行一层代理，无需递归遍历所有属性。

缺点

- [Proxy 的兼容性不太好，它只能在支持 ES6 的浏览器或环境中使用](https://zhuanlan.zhihu.com/p/60791215)[2](https://zhuanlan.zhihu.com/p/60791215)。
- [Proxy 的性能可能不如 Object.defineProperty，因为它需要额外的时间和资源来处理拦截器](https://www.bing.com/search?form=MY0291&OCID=MY0291&q=Bing+AI&showconv=1&rdr=1&rdrig=BE6B748A75CA463CB85944740013F72D#)[3](https://bing.com/search?q=数据劫持使用proxy有什么缺点)。
- [Proxy 的使用可能会引起一些意料之外的问题或错误，比如循环引用，死循环，内存泄漏等](https://blog.csdn.net/CHLing19971130/article/details/124101312)[4](https://blog.csdn.net/CHLing19971130/article/details/124101312)。

## 3. Vue3中的reactive和ref的原理

### Reactive

实现引用数据类型的响应式 

#### 原理

proxy实现的

### ref

基本数据类型的响应式

#### 原理

先新建一个对象，然后value值为需要代理的响应式数据。再使用proxy进行代理，返回proxy对象。

```js
function ref(value) {
  // 创建一个原始值的副本
  let _value = value;
  // 创建一个代理对象
  let proxy = new Proxy({}, {
    // 拦截get操作
    get(target, key, receiver) {
      // 如果访问的是value属性，就返回原始值的副本
      if (key === 'value') {
        return _value;
      }
      // 否则，就按照正常的get操作进行
      return Reflect.get(target, key, receiver);
    },
    // 拦截set操作
    set(target, key, value, receiver) {
      // 如果修改的是value属性，就更新原始值的副本，并触发依赖更新
      if (key === 'value') {
        _value = value;
        trigger(proxy, 'set', key, value);
        return true;
      }
      // 否则，就按照正常的set操作进行
      return Reflect.set(target, key, value, receiver);
    }
  });
  // 返回代理对象
  return proxy;
}

```



### 面试题

- 为什么不使用reactive来监听基本数据类型？

  因为Proxy不能直接代理基本数据类型，每次都要使用创建新的对象使用proxy代理，所以使用ref，利用defineProperty实现响应式。

## 5. 计算属性/methods/Watch的区别

### 计算属性

计算属性是基于响应式数据进行缓存的。只有当响应式依赖发生变化的时候，计算属性才会重新计算。也就是说，当响应式数据未发生变化，我们读取计算属性的时候，是从缓存中读取的。

##### 应用场景

- 同步
- 简单计算一个属性

##### Tips

- 响应式数据发生变化并且读取计算属性的时候，才会重新计算。响应式数据变化，计算属性并不会立刻重新计算。

##### 实现原理

- 计算属性被包裹在副作用函数中，并被在调度选项中设置了lazy标签，只有读取该值的时候，才会计算。
- 计算属性的副作用函数中有个缓存布尔值，表示是否需要重新计算。
- 默认为false，但是当响应数据变化时，在调度选项中设置为True。
- 当获取数据的时候，如果为True，那么重新计算，并设置为false

### methods

methods本身是一个Vue实例中的函数，每次调用都会被执行。

##### 场景

当做一个函数来看待，封装重复使用的代码

### watch

Vue中的监听器，当数据发生变化的时候，执行响应的回调。

##### 场景

异步操作：网络请求，复杂计算

##### 实现原理

手动为监听对象，添加了一个副作用函数，也就是依赖项。当数据发生变化，触发trigger。

## 11. v-if/v-show/v-html

### v-if

- v-if是根据条件来渲染的，如果为假，不会被渲染为虚拟dom，进而不会出现在渲染树上。
- v-if有更高的切换开销，因为每次切换都需要销毁和重建元素及其内部的事件监听器和子组件。
- v-if适合运行时条件很少改变的场景，例如根据用户权限来显示不同的内容

### v-show

- v-show是通过修改元素的display样式属性来控制元素的显示和隐藏，无论条件是否为真，元素都会出现在DOM树中，只是简单地切换CSS。
- v-show有更高的初始渲染开销，因为即使元素不可见，也需要占用DOM空间。
- v-show适合需要非常频繁地切换的场景，例如根据用户操作来切换标签页或折叠面板。

## 10. Vue常见的修饰符

- v-on: 单向数据绑定
- v-model: 双向数据绑定

- v-slot="data"： 接收子组件插槽传递的数据

- v-bind/@事件名: 绑定事件

  | 修饰符名称 | 作用                                                         |
  | ---------- | ------------------------------------------------------------ |
  | .stop      | 停止事件的传播，这里的事件指的是，事件在此处执行完毕后停止传播，包括冒泡和捕获，如果使用捕获，那么要用.capture。【1】 |
  | .capture   | 该事件在捕获阶段触发（默认是冒泡阶段），冒泡阶段不会再次触发； |
  | .prevent   | 取消默认行为；【2】                                          |
  | .self      | 仅当 event.target 是元素本身时才会触发事件处理器，可以理解为该标签的事件触发，只能是本事的时候触发，对于冒泡或者捕获来的事件并不会触发。 |
  | .once      | 绑定一个一次性的事件，也就是事件只会被最多触发一次。         |
  | .passive   | 主要用与提升滚动事件的性能 ※，这里没实践                     |

  #### 案例

  ```js
  function clickHandler(text, event){
      // event.stopPropagation();
      console.log(text)
  }
  ```

  【1】停止捕获的传递

  ```vue
      <div class="box1" @click.capture.stop="clickHandler('box1', $event)">
          <div class="box2" @click="clickHandler('box2', $event)">
              <div class="box3" @click="clickHandler('box3', $event)"></div>
          </div>
      </div>
  ```

  点击box3，只会打印box1，事件到达box1之后，因为在捕获阶段触发，并且加了stop，那么事件就不会继续传递了

  【2】默认行为有哪些？

  取消默认行为是指阻止浏览器执行某些事件的自动响应，比如跳转链接、提交表单、弹出右键菜单等 。

  常见的默认行为有以下几种¹：

  - 点击一个链接 —— 触发导航（navigation）到该 URL。
  - 点击表单的提交按钮 —— 触发提交到服务器的行为。
  - 在文本上按下鼠标按钮并移动 —— 选中文本。
  - 在 <input> 字段上的 mousedown 会导致在其中获得焦点，以及 focus 事件。
  - 在网页上滚动鼠标滚轮 —— 网页的滚动条会动。
  - 在网页上点鼠标右键 —— 弹出右键菜单。

  如果我们想要阻止这些默认行为，我们可以使用 .prevent 修饰符或者在事件处理器中调用 event.preventDefault() 方法。例如：

  ```html
  <!-- 阻止链接跳转 -->
  <a href="/html" @click.prevent>HTML</a>
  
  <!-- 阻止表单提交 -->
  <form @submit.prevent="onSubmit">...</form>
  
  <!-- 阻止右键菜单 -->
  <div @contextmenu.prevent="showMenu">...</div>
  ```


## 11. v-model的语法糖

### 作用在表单上

```html
<input v-model="message">
<input 
       :value = "message"
       @input="message=$event.target.value"
/>
```

- input输入框中的value，表示的事输入框显示的内容，因此将其绑定到了"message"身上，所以message被修改之后，输入框的值也会变化。
- input输入框绑定了input事件，当该事件触发时，执行代码；
- 代码内容为将事件对象的value赋值给message，这样input输入框的值就变化了。

### 作用在组件上

> [组件 v-model | Vue.js (vuejs.org)](https://cn.vuejs.org/guide/components/v-model.html)

#### 用途

子组件绑定v-model的用途是为了实现==父子组件之间的双向数据绑定==，也就是说，当父组件中的数据变化时，子组件中的表单元素也会自动更新；当子组件中的表单元素变化时，父组件中的数据也会自动更新。这样，我们就可以在父子组件之间共享和同步数据，而不需要手动地传递属性和监听事件。

例如，假设我们有一个子组件`<CustomInput>`，它封装了一个输入框，并且接收一个modelValue属性和发射一个update:modelValue事件。我们可以在父组件中使用v-model来绑定一个message数据到子组件上：

```vue
<custom-input v-model="message" />
```

这样，当我们在输入框中输入内容时，message会自动更新；当我们在父组件中修改message时，输入框中的内容也会自动更新。

#### 原理

**父组件**

```vue
<CustomInput v-model="searchText" />
```

等价于

```vue
<CustomInput
  :modelValue="searchText"
  @update:modelValue="newValue => searchText = newValue"
/>
```

**子组件**

处理传递的props以及事件

```vue
<!-- CustomInput.vue -->
<script setup>
defineProps(['modelValue'])
defineEmits(['update:modelValue'])
</script>

<template>
  <input
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  />
</template>
```



## 16. 为什么组件对象中的data是个函数而不是对象

组件对象中的data是被代理的数据。

如果写成对象，那么组件实例的数据代理的对象都是同一个对象，因此如果该组件的多个组件实例存在，就会导致一个组件实例对该数据修改，会影响到其他的组件实例。

如果写成函数，每次返回的都是一个新的对象，是对新的对象的代理，因此不会造成上述问题。

使用外部对象的情况，和上述相同！

## 18. nextTick

> [你真的理解$nextTick么 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903843197616136?searchId=20230911160625EC8C82FCDBC1BB0FFB6A)
>
> [Vue.$nextTick你真的懂了吗？？？ - 掘金 (juejin.cn)](https://juejin.cn/post/7007328894621581349?searchId=20230911160625EC8C82FCDBC1BB0FFB6A)

#### 概念

vue中的nextTick是一个方法，它的作用是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，可以获取更新后的DOM。

#### 原理

- 当Vue检测到响应式数据变化时，Vue不会立即更新DOM，而是将所有的副作用放入一个异步更新队列（async update queue），并在下一个事件循环（event loop）的tick中批量执行它们。这样可以避免多次重复渲染，提高性能和一致性。

  一种简单的实现方式如下：

  ```js
    const jobQueue = new Set()
    const p = Promise.resolve()
  
    let isFlushing = false
  
    function flushJob() {
      if (isFlushing) return
  
      // 一旦 flushJob 函数开始执行，isFlushing 标志就会设置为
      // true，意思是无论调用多少次 flushJob 函数，在一个周期内都只会执行一次.
      // 其实就是这个函数本身具有去重抵御机制。
      isFlushing = true
      p.then(() => {
        jobQueue.forEach(job => job())
      }).finally(() => {
        isFlushing = false
      })
  
      //  这个功能有点类似于在 Vue.js 中连续多次修改响应式数据但只会触发一次更新
    }
  
    effect(() => {
      console.log(obj.foo)
    }, {
      scheduler(fn) {
        // 强行将 fn 放到宏任务 (Macro task) 队列中，等待下一次事件轮询
        // setTimeout(fn)
  
        jobQueue.add(fn)
        flushJob()
      }
    })
  ```

- 而nextTick(callback)，它可以让我们在异步更新队列被清空，也就是DOM被更新之后执行回调函数。这样可以让我们在合适的时机**操作更新的DOM或执行其他逻辑**。

- Vue内部使用了Promise.then()或MutationObserver等API来实现nextTick函数，它们都属于微任务（microtask）。微任务会在当前事件循环结束时执行，优先于宏任务（macrotask），如setTimeout或setInterval等。这样可以保证nextTick函数尽可能早地执行，而不会被其他异步任务阻塞。

  

#### 场景

- 当需要在数据变化后操作更新后的DOM时，例如获取某个元素的高度或宽度，或者滚动到某个位置等。
- 当需要在组件渲染完毕后执行一些操作时，例如设置焦点或者触发一些动画效果等 。
- 当需要在父子组件通信时保证子组件已经更新完毕时，例如父组件通过\$emit触发子组件的事件，然后通过$refs访问子组件的方法或数据等。

## 48. scoped的原理

当你在style标签上添加了scoped属性时，Vue会为你的组件生成一个唯一的哈希ID，比如data-v-12e4e11e。然后，Vue会在编译template标签时，为每个元素添加这个ID作为一个属性，比如<div data-v-12e4e11e>。同时，Vue也会在编译style标签时，为每个CSS选择器添加这个ID作为一个属性选择器，比如div[data-v-12e4e11e]。这样，就实现了样式的隔离和模块化，只有拥有相同ID的元素和选择器才能匹配。



# 生命周期

## 1. Vue的生命周期

### 精简版

Vue的生命周期是指Vue实例从创建到销毁的过程，其中包含了一些特定的阶段，称为生命周期钩子。生命周期钩子是一些函数，可以在特定的阶段执行自定义的代码。

Vue的生命周期主要有以下几个阶段：

**beforeCreate**

> 数据观测和事件配置还未初始化。

这个钩子通常用于执行一些全局的设置或配置，比如引入插件、设置过滤器、注册指令等。

**注**：

- 数据观测，是指Vue对数据对象进行数据劫持的过程，也就是给每个属性添加getter和setter，实现数据的响应式变化。

- 事件配置就是让Vue实例能够监听和触发一些自定义的事件，比如你可以在一个组件里面发出一个叫做"hello"的事件，然后在另一个组件里面监听这个事件，当这个事件发生时，就执行一些操作，比如弹出一个对话框。

- 事件配置是在Vue实例创建完成后就已经设置好了，也就是说你可以在任何时候使用$on、$emit、\$off这些方法来操作事件。\$on是用来监听事件的，\$emit是用来触发事件的，$off是用来取消监听事件的。

**created**

> 在实例创建完成后，数据观测和事件配置已经初始化，但是模板编译和挂载还未开始。

这个钩子通常用于执行一些与数据相关的操作，比如发送AJAX请求、初始化状态、设置定时器等。

**beforeMount**

> 在模板编译完成后，实例准备挂载到DOM之前。Vue已经完成了模板编译，生成了虚拟DOM，但是还没有将它们插入到真实的DOM节点中，也就是说页面还没有渲染出来。

**mounted**

> 在实例挂载到DOM之后，可以访问到DOM节点，并且可以进行一些依赖于DOM的操作。

在mounted阶段，我们一般可以进行一些依赖于DOM的操作，比如获取DOM元素，绑定DOM事件，使用第三方库或插件等。

**beforeUpdate**

> 在响应式数据发生变化时，重新渲染之前。

**updated**

> 在响应式数据发生变化后，重新渲染完成后，可以获取到更新后的DOM节点。

**beforeUnmount**

> 在实例销毁之前，可以进行一些清理工作，如移除事件监听器或定时器等。

**unmounted**

> 在实例销毁之后，所有的数据绑定和事件监听器都被移除，子组件也被销毁。

这些生命周期钩子可以让我们在不同的时机执行不同的逻辑，比如发送请求、操作DOM、添加动画等。

**额外的两个生命周期钩子**

1. 路由组件所独有的两个钩子，用于捕获路由组件的激活状态。
2. 因为这个路由使用keep-alive，对组件进行缓存——在组件切换过程中将状态保留在内存中， 防止重复渲染 DOM  

- 当组件被换掉时，会被缓存到内存中， 触发 deactivated 生命周期；

- 当组件被切回来时，再去缓存里找这个组件， 触发 activated 钩子函数  



### 详细版

你好，这是Bing。我很高兴你对Vue的生命周期感兴趣。😊

Vue的生命周期是指一个组件实例从创建到销毁的过程中，经历的一系列阶段和事件。在每个阶段和事件中，Vue会提供一些特殊的函数，叫做生命周期钩子（lifecycle hooks），让开发者可以在特定的时机执行自己的代码，从而实现一些自定义的功能或逻辑。

Vue的生命周期可以分为以下几个阶段：

- 创建阶段：这个阶段是在组件实例被创建之前和之后进行的，包括以下几个步骤：

  - 创建Vue实例：这是在组件实例被创建之前进行的，Vue会先从组件的**配置对象**中获取一些数据或选项，比如props、inject、mixins、extends等，并将它们合并到组件实例的\$options属性中。这些数据或选项可以在组件的其他钩子中通过this.$options来访问，但是它们不是响应式的，也不会影响组件的渲染和更新。这些数据或选项通常用于定义一些全局的配置或功能，比如插件、过滤器、指令等。

  - beforeCreate钩子：这是在组件实例被创建之前调用的第一个钩子函数，此时组件还没有初始化数据、方法、计算属性、侦听器等，也没有挂载到DOM上。这个钩子通常用于执行一些全局的设置或配置，比如引入插件、设置过滤器、注册指令等。

  - 初始化数据和方法：这是在组件实例被创建之后进行的，Vue会从组件的配置对象中获取一些数据或选项，比如data、methods、computed、watch等，并将它们**初始化为响应式的数据或状态**，并**添加到组件实例上**。这些数据或状态可以在组件的模板或其他钩子中通过this来访问，而且它们会影响组件的渲染和更新。这些数据或状态通常用于定义一些与业务逻辑相关的功能，比如发送AJAX请求、初始化状态、设置定时器等。

  - created钩子：这是在组件实例被创建之后调用的第二个钩子函数，此时组件已经初始化了数据、方法、计算属性、侦听器等，但还没有挂载到DOM上。这个钩子通常用于执行一些与数据相关的操作，比如发送**AJAX请求、初始化状态、设置定时器**等。

    注：这里初始化状态可以理解为：修改响应式数据等。

- 挂载阶段：这个阶段是在组件实例被挂载到DOM之前和之后进行的，包括以下几个步骤：

  - 编译模板：这是在组件实例被挂载到DOM之前进行的，Vue会将组件的模板（template）编译成渲染函数（render function），渲染函数会返回一个虚拟DOM树（virtual DOM tree），虚拟DOM树是对真实DOM树（real DOM tree）的抽象和模拟，它可以让我们用JavaScript对象来描述UI界面，而不需要直接操作真实DOM。虚拟DOM树可以提高性能和跨平台能力，因为它可以避免不必要的真实DOM操作，并且可以在任何支持JavaScript的环境中运行。
  - beforeMount钩子：这是在组件实例被挂载到DOM之前调用的第三个钩子函数，此时组件已经编译了模板，但还没有渲染到页面上。这个钩子通常用于执行一些与DOM相关的操作，比如添加事件监听器、操作DOM元素等。
  - 渲染和打补丁：这是在组件实例被挂载到DOM之后进行的，Vue会将渲染函数返回的虚拟DOM树转换为真实DOM树，并添加到页面中。这个过程叫做渲染（rendering）。同时，Vue会在虚拟DOM树和真实DOM树之间建立一个映射关系，当数据发生变化时，Vue会重新执行渲染函数，生成一个新的虚拟DOM树，并和旧的虚拟DOM树进行比较，找出差异，并根据差异更新真实DOM树。这个过程叫做打补丁（patching）。
  - mounted钩子：这是在组件实例被挂载到DOM之后调用的第四个钩子函数，此时组件已经渲染到页面上，并且可以访问到DOM节点。这个钩子通常用于执行一些与DOM相关的操作，比如**添加事件监听器、操作DOM元素**等。

- 更新阶段：这个阶段是在组件实例由于响应式数据变化而更新之前和之后进行的，包括以下几个步骤：

  - 数据变化：这是在组件实例由于响应式数据变化而更新之前进行的，Vue会检测到数据的变化，并触发**组件的重新渲染和打补丁**。
  - beforeUpdate钩子：这是在组件实例由于响应式数据变化而更新之前调用的第五个钩子函数，此时组件还没有重新渲染和打补丁。这个钩子通常用于执行一些与数据相关的操作，比如**比较新旧数据、获取快照**等。
  - 重新渲染和打补丁：这是在组件实例由于响应式数据变化而更新之后进行的，Vue会重新执行渲染函数，生成一个新的虚拟DOM树，并和旧的虚拟DOM树进行比较，找出差异，并根据差异更新真实DOM树。
  - updated钩子：这是在组件实例由于响应式数据变化而更新之后调用的第六个钩子函数，此时组件已经重新渲染和打补丁，并且可以访问到更新后的DOM节点。这个钩子通常用于执行一些与DOM相关的操作，比如添加事件监听器、操作DOM元素等。

- 卸载阶段：这个阶段是在组件实例被卸载之前和之后进行的，包括以下几个步骤：

  - 卸载组件：这是在组件实例被卸载之前进行的，Vue会将组件从父组件或者页面中移除，并解绑所有的事件监听器、侦听器、计算属性等。
  - beforeUnmount钩子：这是在组件实例被卸载之前调用的第七个钩子函数，此时组件还没有从DOM中移除，并且仍然可以访问到它。这个钩子通常用于执行一些清理工作，比如**移除事件监听器、取消定时器、关闭连接**等。
  - 从DOM中移除：这是在组件实例被卸载之后进行的，Vue会将组件从DOM中移除，并释放所有的内存空间。
  - unmounted钩子：这是在组件实例被卸载之后调用的第八个钩子函数，此时组件已经从DOM中移除，并且无法再访问到它。这个钩子通常用于执行一些清理工作，比如移除事件监听器、取消定时器、关闭连接等。

以上就是Vue的生命周期及其各个阶段和事件的介绍，你

## 3. created和mounted的区别

created是实现了初始化数据的观测以及事件的注册，还未渲染为虚拟DOM，更没渲染到页面上，因此在该部分，我们主要是来操作数据，也就是做的事情是依赖数据的。例如：发送异步请求，并且不会阻塞页面。

mounted生命周期时DOM已经挂载完毕，视图被渲染。再此处的操作主要是与DOM相关的。

## 4. 一般在什么时候请求异步数据

请求异步数据的最佳生命周期钩子是created。这是因为：

- created钩子会在组件实例被创建之后调用，这时已经初始化了数据和事件等选项，但是还没有挂载到页面上。这个钩子可以用来初始化数据，设置响应式依赖，注册事件监听器等。1
- created钩子比beforeMount和mounted钩子更早执行，所以可以尽快地触发异步请求，可以提高首屏渲染的速度。

如果需要DOM的信息(大小、位置)来请求数据，就可以在mounted生命周期：

- 在mounted生命周期，Vue已经完成了DOM的挂载和渲染，所以我们可以访问到真实的DOM节点。如果我们需要根据DOM的大小或位置来请求数据，就可以在mounted生命周期进行。

## 5. keep-alive中的生命周期

# 组件通信

### props

在父组件的子组件标签上，来书写要传递的属性值，属性值可以通过v-bind:绑定也可以是静态的属性值。

```vue
<MyBox :count=count></MyBox>
```

在子组件中使用`defineProps`来接收传递的来的props属性

```js
const props = defineProps(["count"])
```

props被传递来不允许被修改。

### $emit 自定义事件 

子 -> 父

### 事件总线

### 依赖注入 

祖 -> 孙

provide提供数据

inject接收数据

这里不止是父子组件还可以是祖孙组件之间。

### ref

[模板引用 | Vue.js (vuejs.org)](https://cn.vuejs.org/guide/essentials/template-refs.html#ref-on-component)

```vue
<script setup>
import { ref, onMounted } from 'vue'
import Child from './Child.vue'

const child = ref(null)

onMounted(() => {
  // child.value 是 <Child /> 组件的实例
})
</script>

<template>
  <Child ref="child" />
</template>
```

### pinia

### Vuex





# 路由

## 2. 路由的两种模式

[前端路由](E:\研究生\自我学习\前端学习\前端小知识.md)

## 3. 前端路由和后端路由的理解

### 后端路由

> 什么是后端路由？
>
> 产生前端路由的原因？

后端路由是指在服务器端根据URL的不同来返回不同的HTML文件给浏览器，浏览器再根据HTML文件来渲染页面。这样可以实现SEO优化，保证页面的安全性，适用于**多页面应用（MPA）**。每次发起请求都要刷新页面，用户体验不好，服务器压力大。

### 单页面应用

进而出现了单页面应用

优点：不用每次加载，提高用户体验

缺点：第一次请求会加载大量文件，不能记录用户的前进后退刷新等。

### 前端路由

进而出现了前端路由

## 4. Vue-Router中的路由守卫

### 全局路由守卫

- 全局前置路由守卫router.beforeEach -> 进入路由之前执行
- 全局解析路由守卫router.beforeResolve -> 
- 全局后置路由钩子router.afterEach -> 进入路由之后执行

### 路由独享守卫

beforeEach

### 组件内钩子

- `beforeRouteEnter`:渲染组件之前调用
- `beforeRouteUpdate`：地址改变，但是组件被复用的时候调用
- `beforeRouteLeave`：离开组件时被调用

```js
const UserDetails = {
  template: `...`,
  beforeRouteEnter(to, from) {
    // 在渲染该组件的对应路由被验证前调用
    // 不能获取组件实例 `this` ！
    // 因为当守卫执行时，组件实例还没被创建！
  },
  beforeRouteUpdate(to, from) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，
    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`
  },
  beforeRouteLeave(to, from) {
    // 在导航离开渲染该组件的对应路由时调用
    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`
  },
}
```



### 1. MVVM、MVC、MVP之间的区别吗？

MVVM、MVC、MVP都是软件架构设计模式，它们通过分离数据、视图和逻辑来组织代码，提高开发效率和可维护性。它们的区别主要在于数据和视图之间的通信方式和数据流方向。

MVC表示模型-视图-控制器，它将应用程序抽象为数据层（Model）、视图层（View）和逻辑层（Controller）。Model负责存储和操作数据，View负责显示数据，Controller负责处理用户交互和业务逻辑。在MVC中，Model和View可能有耦合，即它们可以直接通信，也可以通过Controller通信。数据流的方向是双向的，即Model和View都可以影响对方。

MVP表示模型-视图-演示者，它是对MVC的改进，它将应用程序抽象为数据层（Model）、视图层（View）和逻辑层（Presenter）。Model负责存储和操作数据，View负责显示数据，Presenter负责处理用户交互和业务逻辑。在MVP中，Model和View之间不直接通信，而是通过Presenter通信。Presenter是View和Model之间的桥梁，它将Model的变化同步到View上，也将View的操作反馈到Model上。数据流的方向是单向的，即只有Model可以影响View，而View不能影响Model。

MVVM表示模型-视图-视图模型，它是对MVP的改进，它将应用程序抽象为数据层（Model）、视图层（View）和逻辑层（ViewModel）。Model负责存储和操作数据，View负责显示数据，ViewModel负责处理用户交互和业务逻辑。在MVVM中，Model和View之间也不直接通信，而是通过ViewModel通信。ViewModel是一种特殊的Presenter，它使用双向数据绑定技术来自动将Model的变化同步到View上，也将View的操作反馈到Model上。数据流的方向是双向的，但是由框架自动管理，开发者不需要手动操作。

- 

#### 3. Vue渲染的过程

**编译：**Vue模板被编译为渲染函数，即用来返回虚拟DOM树的函数。

**挂载：**运行时渲染器调用渲染函数，遍历返回的虚拟DOM树，并基于它创建实际的DOM节点。这一步会作为响应式副作用执行，因此它会追踪其中所用到的所有响应式依赖。

**更新：**当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟DOM树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实DOM上去。

当Vue渲染一个组件时，它会调用组件的渲染函数，这个函数会返回一个虚拟DOM树，表示组件的视图结构。在这个过程中，渲染函数会访问到一些响应式数据，例如data、props、computed等。这些数据就是渲染函数的响应式依赖，因为它们的变化会影响渲染函数的输出。

Vue会在调用渲染函数时，把它（渲染函数）包装在一个响应式副作用中，这个副作用会记录下所有访问到的响应式依赖，并把自己添加到这些依赖的订阅者列表中。这样，当某个依赖发生变化时，就会触发这个副作用重新执行，从而重新渲染组件。

# Vue3

## 1. Vue3的更新

> [盘点 Vue3 与 Vue2 的区别 - 掘金 (juejin.cn)](https://juejin.cn/post/7067413380922867725)

### 性能提升

Vue3使用了重新编写的响应式系统，Vue2 响应式原理基础是 Object.defineProperty；Vue3 响应式原理基础是 Proxy， 有效的避免了上面的不足。



### 组合式API

Vue3引入了Composition API，它是一种新的编写组件逻辑的方式，可以让开发者更灵活地组织和复用代码，避免了Vue2中Options API带来的代码分散和难以维护的问题。

Composition API还提供了更好的TypeScript支持和自定义Hooks的能力。

### 生命周期

beforeCreate和created合并为了setup生命周期，beforeDestroy、destroyed修改为了onBeforeUnmount、onUnmounted。

在Vue3组合式API中，如果使用生命周期钩子要手动引入。

### 新的模板语法

Vue3支持了一些新的模板语法，比如`<script setup>`、`<style vars>`、`<teleport>`、`<suspense>`等，可以让开发者更方便地编写组件。

其中`<script setup>`可以让开发者在单文件组件中直接使用Composition API；

`<teleport>`可以让开发者将组件渲染到任意位置；`<suspense>`可以让开发者处理异步组件的加载状态。

### 新的状态管理库

Vue3推荐使用Pinia作为状态管理库，它是一个基于Composition API的轻量级替代方案，可以替代Vuex4。Pinia有以下几个优点：API设计更简单直观；完全支持TypeScript；可以轻松地在任何地方使用多个store对象；可以自动追踪任何对state的变更；可以通过插件机制来扩展store对象的功能4。

## 2. 组合式API的优势

#### 代码组织

组合式API可以让开发者按照逻辑关注点来组织和分割代码，而不是按照选项类型来划分代码，从而提高了代码的可读性和可维护性。

#### 逻辑复用

组合式API可以让开发者将组件的逻辑抽象成可复用的函数，从而避免了Vue2中使用混入（mixins）带来的命名冲突、数据来源不明、逻辑分散等问题。组合式API可以让开发者创建自定义的Hooks函数，从而实现一些通用的功能或效果，比如数据获取、表单验证、鼠标跟踪等。

#### 类型支持

组合式API完全支持TypeScript，可以让开发者享受到类型检查、自动补全、重构等优势，而不需要额外的类型声明或断言。



# 虚拟DOM

## 1. 虚拟DOM算法

快速diff算法是一种用来比较两棵虚拟DOM树的差异，并且根据差异来更新真实DOM的技术。它的核心思想是只比较同一层级的节点，而不是逐层遍历所有节点，这样可以降低时间复杂度从O(n^3)到O(n)。

快速diff算法的过程可以分为以下几个步骤：

1. 首先，从根节点开始，比较新旧两棵虚拟DOM树的根节点，如果它们的类型或者key不同，就直接替换整个树；如果它们的类型和key相同，就进行patch操作，即更新节点的属性和事件等。
2. 然后，比较根节点的子节点序列。
   - 如果新子节点序列为空，就移除所有旧子节点；
   - 如果旧子节点序列为空，就添加所有新子节点。
   - 如果都不为空，在子节点比较的循环中，使用双端比较的方法，也就是同时从子节点序列的头部和尾部进行比较，如果发现相同类型和key的节点，就进行patch操作，并且移动指针；如果发现不同类型或者key的节点，就跳出循环。
   - 然后，在跳出循环后，判断剩余的子节点是否存在乱序或交换的情况，如果存在，就使用最长递增子序列（LIS）的方法来找出最长递增子序列，并且保证通过最小的移动或patch操作实现节点复用；
   - 如果不存在，就直接移动或卸载剩余的子节点。
3. 最后，在完成子节点比较后，递归地对每个有子节点的节点进行相同的过程，直到遍历完整棵虚拟DOM树，并且将所有差异应用到真实DOM上。

## 2. 虚拟DOM

#### 什么是虚拟DOM

虚拟DOM是用来描述真实DOM的方式，在JavaScript中，虚拟DOM本身是一个树形结构的对象，对象的属性用来描述真实DOM的内容，并且树形结构的层级关系用来描述真实DOM的层级关系。

我们使用虚拟DOM的过程是这样的：

当我们想要修改真实DOM的时候，首先修改的是虚拟DOM，然后比较新旧的虚拟DOM之间的差异，最后更新真实DOM。

对于前端来说，最明显的好处就是：

#### 提高渲染能力

我们知道真实DOM的操作是很耗费资源的，每次修改DOM都会可能会引起浏览器的重绘和重排，影响用户体验。

而虚拟DOM是用JavaScript对象来模拟真实DOM，操作虚拟DOM的速度远快于操作真实DOM。

虚拟DOM还可以通过diff算法来比较新旧虚拟节点之间的差异，只更新必要的部分，避免了无用的DOM操作。

因此虚拟DOM可以减少对真实DOM的操作次数，从而提高页面的渲染性能。

其他方面来说，可以：

#### 跨平台兼容

虚拟DOM可以作为一个中间层，来适配不同的平台和环境，比如浏览器、移动端、桌面端、服务端等。这样可以让开发者使用相同的代码来构建不同的应用，提高代码的复用性和可移植性。

但是也会存在问题：

#### 影响首次渲染

首次渲染时，多了一层虚拟DOM的计算，所以会比不使用虚拟DOM慢一些，但是能够在DOM更新或者修改时更快。



## 3. key的用处

#### 概述

核心作用是标记虚拟DOM，通过key以及虚拟DOM的类型，可以判断两个虚拟DOM是否相同，如果相同，我们就可以进行复用，也就是通过对虚拟DOM打补丁，更新节点属性，然后将该节点移动到指定位置，而不用新建DOM，进而实现DOM的复用。

#### 应用

你可以举例说明一下使用key可以带来的性能优化和用户体验提升。比如，在一个列表渲染中，如果列表的顺序发生了变化，但是列表项的内容没有变化，那么使用key可以避免重新创建和销毁列表项的DOM元素，而只需要移动它们的位置。这样可以减少渲染时间和内存消耗，并且保持列表项的状态和动画效果。

# 其他

## 1. 副作用函数

副作用函数是指在执行函数的过程中，除了返回函数值之外，还对函数外部的环境或数据产生了影响的函数。副作用函数通常会改变全局变量、修改参数、打印输出、抛出异常、调用其他有副作用的函数等。

在Vue中，副作用函数指的是根据数据对页面内容进行修改的函数，这类函数执行组成了页面的渲染。

## 2. 一个组件存在多个副作用函数？

假如说，组件中的数据是响应式的，那么对于该组件，会用到几个副作用函数呢？这要根据具体的情况而定，但一般来说，至少会有以下几个副作用函数：

- 一个渲染副作用函数，用来渲染和更新组件的视图：render + patch
- 一个生命周期副作用函数，用来执行onMounted、onUpdated等钩子
- 一个或多个自定义副作用函数，用来执行watchEffect或watch等自定义逻辑
  当然，如果组件中还有其他的响应式数据或逻辑，可能还会有更多的副作用函数。









