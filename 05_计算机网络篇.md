#### 问一问自己，如何回答问题，才能够让面试官满意？

1. 尽量别磕磕绊绊或者说错了再纠错的情况，可以有思考时间，慢点说!

#### 问xxx和xxx的区别

1. 首先说相同点
2. 不同点：分为不同的方面/角度，说不同点，最好能够理解出现区别的原因

#### 问标准答案

从一个例子/背景 来理解这个内容

> [面渣逆袭（计算机网络面试题八股文）必看👍 | Java程序员进阶之路 (tobebetterjavaer.com)](https://tobebetterjavaer.com/sidebar/sanfene/network.html#_18-说说-http-与-https-有哪些区别)

# 〇、其他问题

1. OSI七层模型

   名称 + 概念

2. TCP/IP 五层模型

   名称 + 概念

3. 

# 一、HTTP协议

## 1. get和post的请求区别

- 都是http的请求

- ##### 不同点

  - 从含义来说：post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是get提交），目的是资源的获取，读取数据
  - 从表达形式来看：传递参数的方式的不同
  - 是否缓存？
  - 安全性：
  - 发送的数据的大小：url的长度限制
  - 发送的数据类型：post支持二进制数据，json，xml等

## 2. post和put请求

- put请求：强调的是修改和更新数据
- post请求：强调的是创建数据，会增加额外的数据种类

## 3. 常见的请求头和响应头

##### 3.1 请求头 

浏览器发请求给服务器，要告诉服务器哪个域Host发的，哪个页面Refer发的，哪个浏览器代理User-Agent我发的，我和服务器怎么连接类型（connection），连接了我能拿到的文件（accept）是怎么样的（类型（accept），字符集（accept-charset），编码（accept-encoding），语言（accept-language））。我们是否有cookie缓存

##### 3.2 响应头

服务器响应浏览器，告诉浏览器我是从哪个服务器（server）来的，时间是多少（date），我们之间的链接类型connection，控制http的缓存(cache-control)，告知响应文件的类型(content-type)。

##### content-type的类型

json、xml、html、表单、表单文件

##### cache-control响应头的作用？

Cache-Control响应头用于指示客户端（如浏览器）和中间缓存如何缓存响应。它可以控制缓存的行为，例如：

- 最大缓存时间
- 允许使用的缓存类型（如私有缓存、共享缓存）
- 是否允许缓存响应被修改后重新使用

Cache-Control可用于减少网络流量和提高性能，因为它可以告诉浏览器何时从缓存中获取内容，而不是通过网络获取。

什么叫做缓存？举个例子，说一下缓存的内容放到了哪里？

缓存是指在某个位置（通常是客户端或中间节点）存储数据的过程，以便将来可以快速访问该数据。缓存通常用于减少网络流量、提高性能和减轻服务器负载。

一个例子是浏览器缓存。当您首次访问一个网站时，浏览器会下载并显示该网站的内容。但是，如果您稍后再次访问同一网站，浏览器可能会使用先前下载的副本而不是从该网站下载新的内容。这是因为浏览器已经将该网站的内容缓存到本地硬盘驱动器上，以便更快地呈现该网站。

缓存的内容可以放在各种位置，包括浏览器、操作系统、代理服务器和内容分发网络（CDN）。具体取决于缓存的类型和用途。

## 5. 常见的Http请求方法

- 增 post
- 删 delete
- 改 put 更新数据
- 查 get
- head：返回报文的头部，不返回报文的主题
- options： 询问支持的请求方式

## 6. Options请求方法和使用场景

Options请求方法是一种HTTP方法，它用于获取当前URL所支持的其他HTTP方法，比如GET, POST, PUT, DELETE等。Options请求方法的使用场景有以下两种：

- 一种是用于检测服务器的性能，比如服务器支持哪些HTTP版本，哪些扩展等。
- 另一种是用于跨域资源共享（CORS）的预检请求，当浏览器发起一个可能对服务器数据产生副作用的跨域请求时（比如非GET或者搭配某些MIME类型的POST请求），浏览器会先发送一个Options请求，询问服务器是否允许这样的请求，以及需要满足哪些条件（比如请求头，Cookie等）。

#### options请求头

预检请求会发送Access-Control-Request-Method和Access-Control-Request-Headers标头，告知服务器实际请求所使用的HTTP方法和自定义标头。

#### options响应头

服务器可以回应是否接受这些条件，通过发送：

- Access-Control-Allow-Origin：允许跨域请求的域名
- Access-Control-Allow-Methods：允许客户端使用什么方法发起请求
- Access-Control-Allow-Headers：用于预检测请求响应，告诉浏览器实际请求中允许携带的字段
- 和Access-Control-Max-Age：预检请求的结果被缓存多久

#### 复杂请求

- 使用了下面任一 HTTP 方法，PUT/DELETE/CONNECT/OPTIONS/TRACE/PATCH
- 人为设置了以下集合之外首部字段，即简单请求外的字段
- Content-Type 的值不属于下列之一，即application/x-www-form-urlencoded、multipart/form-data、text/plain

## 8. HTTP协议状态码

好的，我会尽力帮您整理成一个markdown表格。请看下面的内容：

| 状态码 | 类别           | 含义                                                         |
| :----- | :------------- | :----------------------------------------------------------- |
| 200    | 成功响应       | 请求成功。一般用于GET和POST请求。                            |
| 301    | 重定向响应     | 资源（网页等）被永久转移到其他URL。返回信息会包含新的URL，浏览器会自动定向到新的URL。 |
| 302    | 重定向响应     | 资源（网页等）被临时转移到其他URL。与301类似，但资源只是暂时被移动。客户端应继续使用原有URL。 |
| 304    | 成功响应       | 资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。 |
| 400    | 客户端错误响应 | 客户端请求的语法错误，服务器无法理解。                       |
| 401    | 客户端错误响应 | 请求要求用户的身份认证。                                     |
| 403    | 客户端错误响应 | 服务器理解请求客户端的请求，但是拒绝执行此请求。与401不同，服务器知道客户端的身份。 |
| 404    | 客户端错误响应 | 服务器无法根据客户端的请求找到资源（网页等）。通过此代码，网站设计人员可以设置“您所请求的资源无法找到”的个性页面。 |
| 500    | 服务器错误响应 | 服务器内部错误，无法完成请求。                               |
| 501    |                | 不支持当前功能的请求                                         |
| 503    | 服务器错误响应 | 由于超载或系统维护，服务器暂时无法处理客户端的请求。         |



## 9. HTTP协议对比

> - [HTTP/1.1，HTTP/2和HTTP/3的区别\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1vv4y1U77y/?spm_id_from=333.337.search-card.all.click&vd_source=7ce3f834cb0c7108338f1996b4436d48)
> - [一文总结http1.0，http1.1，http2，http3，面试强心剂 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/469988032)

### HTTP 1.0

#### 主要描述

1. HTTP 1.0是最早的HTTP版本，默认是非持久连接，每次请求都需要建立和断开TCP连接；
2. 它只支持GET方法；

#### 存在问题

1. 无法复用TCP连接
2. 队头阻塞，HTTP 1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。

#### 其他不重要的

1. 缓存相关的请求头：If-Modified-Since，Expires，存在一些问题，详情见==浏览器部分==
2. 未描述的一般就是没有的

### HTTP 1.1

#### 主要特点

1. 它支持长连接，可以在一个TCP连接上发送多个请求和响应，减少了连接的开销。
2. 它支持管道化，可以同时发送多个请求，不需要等待每个请求的响应，提高了效率。
3. 丰富了缓存处理，增添了请求/响应头Cache-Control，ETag。
4. 它支持多种方法，如POST, PUT, DELETE等，扩展了功能。
5. 它支持Host字段，可以让一个服务器创建多个Web站点。

#### 存在问题

1. **长连接存在队头阻塞**。因为 HTTP1.1 遵循 FIFO（先进先出）的原则，也就是说，客户端必须等待上一个请求的响应返回后，才能发送下一个请求。这样就会导致队头阻塞（Head-of-line blocking）的问题，即如果某个请求的处理时间较长，那么它后面的请求就会被阻塞，无法及时得到响应。
2. **管道化未能解决队头阻塞。**它仍然遵循 FIFO 的原则，也就是说，服务器必须按照请求的顺序来返回响应。这样也会导致队头阻塞的问题，即如果某个响应的返回时间较长，那么它后面的响应就会被阻塞，无法及时发送给客户端。【造成服务端的队头阻塞】
3. **HTTP/1.1是基于文本的协议**，头部信息和数据都是以明文形式传输，容易被窃听或篡改，而且头部信息冗长，占用了大量的带宽。

### HTTP 2.0

#### 主要特点

1. 使用二进制分帧机制，将头信息和数据体分割为帧，称为头信息帧和数据帧，并对它们采用二进制格式进行编码和解码，提高了传输的安全性和效率。

2. 支持多路复用，即在一个TCP连接上可以同时发送和接收多个请求和响应，而且可以乱序发送和接收，避免了队头阻塞问题，提高了传输的并发性和效率。【==解决队头阻塞==】
   - **例如**，如果要同时请求一个网页的HTML、CSS、JS和图片文件，HTTP/1.1需要建立四个TCP连接，或者在一个连接上按顺序发送四个请求，等待每个响应到达后再发送下一个请求。而HTTP/2.0只需要建立一个TCP连接，然后在同一个连接上并行发送四个请求，并且可以按任意顺序接收响应。这样就减少了建立和关闭连接的开销，以及等待响应的时间。

3. 支持头部压缩，即使用HPACK算法对头部信息进行压缩和解压缩，减少了头部信息的大小和重复性，节省了带宽和数据量。

4. 支持服务器推送，即服务器可以在客户端请求之前（例如请求HTML，服务器不止会发送html，还会响应相应的css，js等）主动发送一些资源给客户端，预先加载一些可能需要的内容，提高了用户体验和响应速度。

   - 例如，如果客户端请求一个网页的HTML文件，服务器可以在返回HTML文件的同时，主动推送该网页所需的CSS、JS和图片文件给客户端，而不需要等待客户端再次请求这些资源。这样就减少了请求的次数和延迟，提高了网页的加载速度


   - 存在的问题：

     - 用户误点，会带来额外的信息	

     - DDoS攻击，一对多

5. HTTP/2.0支持流优先级，即客户端可以指定不同请求之间的优先级，让服务器根据优先级分配资源和带宽，优先处理更重要或更紧急的请求。

#### 缺陷

- HTTP2.0仍然基于TCP协议，而TCP协议本身有一些缺陷，比如慢启动、重传机制、队头阻塞等，这些会影响HTTP2.0的性能和效率。
- HTTP2.0的多路复用可能导致服务器的压力增大，因为同一个连接上可以发送多个请求，而服务器需要同时处理这些请求，可能会造成资源的竞争和超时的风险。
- HTTP2.0的服务端推送可能造成资源的浪费，因为服务器可能会推送一些客户端已经缓存或者不需要的资源，而客户端无法拒绝这些推送。

#### 拓展

##### 多路复用与二进制分帧

HTTP2.0 如何实现的多路复用？原理是什么？

HTTP2.0 实现多路复用的原理是，它使用二进制分帧（Binary Framing）来将请求和响应分为多个帧（Frame），并在每个帧的**头部添加一个标识符**（Stream Identifier），用来区分这个帧属于哪个请求或响应。服务器和客户端可以根据这个标识符来组装和解析不同的请求和响应，而不需要按照顺序来返回响应。

二进制分帧的优点是，它可以在一个 TCP 连接上同时传输多个请求和响应，并且不受 HTTP 消息本身的结构和语义的限制，从而实现了真正的并行传输。二进制分帧还可以支持流优先级和依赖，可以让服务器根据流的重要性和关系来调整资源分配。

##### 头部压缩

HTTP2.0中进行头部压缩的原因是为了减少请求和响应的大小，提高传输的效率和性能。HTTP协议中的请求和响应都包含一些头部字段，用于携带一些元数据信息，比如方法、路径、状态码、内容类型等。这些头部字段往往是重复的或者冗余的，占用了不必要的带宽和资源，影响了传输的速度和质量。通过对头部进行压缩，可以减少头部的大小，节省网络流量，提高网页的加载速度。

- 头部字段可能包含一些不必要或无用的信息，比如User-Agent表示客户端的类型或版本，Referer表示请求来源的网址，Cookie表示客户端保存的一些数据等。这些信息对于服务器处理请求或返回响应并没有太大的影响，只是增加了请求和响应的大小和复杂度。
- 头部字段可能包含一些相同或相似的信息，比如Accept和Accept-Encoding都表示客户端可以接受的数据类型或编码方式，Content-Length和Transfer-Encoding都表示响应的数据长度或传输方式等。这些信息对于服务器处理请求或返回响应可能有一定的作用，但也可能造成冲突或混淆。

### HTTP 3.0

> HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。

#### 核心点

1. HTTP3.0基于UDP协议，支持快速握手，可以在第一次握手时就建立加密连接，而不需要像TCP+TLS那样进行多次握手，从而避免了TCP协议带来的一些问题，比如慢启动、重传机制、队头阻塞等，同时也减少了延迟和开销。
2. HTTP3.0在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。

2. HTTP3.0支持加密传输，它集成了TLS 1.3协议，可以保证数据的安全性和隐私性。

#### 了解

- HTTP3.0支持请求优先级，它可以让客户端指定不同请求的优先级，从而让服务器优先处理重要的请求，提高用户体验。
- HTTP3.0支持连接迁移，它可以让客户端在网络环境变化时（比如从Wi-Fi切换到4G）保持原有的连接，而不需要重新建立连接，从而提高了可靠性和连续性。

#### 补充

##### TCP的重传机制和HTTP3.0

- TCP协议中的重传机制是基于连接（connection）的，也就是说，当一个数据包在传输过程中丢失或者延迟时，TCP会暂停整个连接的数据传输，直到这个数据包被重新发送并且确认收到为止。这样会导致整个连接的传输效率降低，尤其是在网络环境不稳定的情况下 。
- HTTP3.0中的重传机制是基于流（stream）的，也就是说，当一个数据包在传输过程中丢失或者延迟时，HTTP3.0只会暂停这个数据包所属的流（stream）的数据传输，而不会影响其他流（stream）的数据传输。这样可以避免一个数据包的问题影响整个连接的传输效率，提高了网络的容错性和灵活性 。

### 常见面试题

#### 请求接口错误，即状态码非200的请求错误怎么捕获？



# 二、HTTPS协议

> [HTTPS是什么？加密原理和证书。SSL/TLS握手过程\_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.999.0.0&vd_source=7ce3f834cb0c7108338f1996b4436d48)





## 1. 什么是HTTPS协议？

### 概述

超文本传输安全协议(Hypertext Transfer Protocol Secure，简称: HTTPS) 是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS协议来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

### 产生原因

产生本质原因是HTTP协议的安全性问题：

- 【**数据窃听**】HTTP是一种**明文传输**的协议，也就是说，它传输的数据没有经过任何加密，这就意味着任何人都可以在网络上截获或监听这些数据，从而窃取或利用用户的隐私和敏感信息，比如用户名、密码、银行卡号、身份证号等。这就是数据的窃听问题。
- 【**数据的篡改**】HTTP是一种**无状态**的协议，也就是说，它不会保存任何关于用户或会话的信息，这就意味着任何人都可以在网络上修改或替换这些数据，从而改变或破坏用户收到的信息，比如插入广告、恶意链接、虚假内容等。这就是数据的篡改问题。
- 【**数据的伪装**】HTTP是一种**无法验证数据来源**的协议，也就是说，它不会检查数据发送者或接收者的身份，这就意味着任何人都可以在网络上伪造或冒充这些数据，从而欺骗或攻击用户，比如假冒网站、钓鱼邮件、中间人攻击等。这就是数据的伪装问题。

## 2. TLS/SSL原理

### 原理概述

HTTPS的原理是在应用层和传输层之间，加入了一个独立的协议层，实现了数据的加密、认证和完整性保护。TLS的原理可以分为以下几个步骤：

- 客户端和服务器之间进行TLS握手，通过非对称加密算法，数字证书和签名，交换公钥和预主密钥，来生成会话密钥，并确认双方的身份和数据的完整性。
- 客户端和服务器之间使用会话密钥进行对称加密通信，保证数据的保密性和效率。
- 客户端和服务器之间结束TLS连接，释放会话密钥和相关资源。

### 对称加密

#### 概念

加密和解密使用相同的密钥

#### 特点

- 速度快，效率高
- 密钥分发管理容易被劫持

### 非对称加密

#### 概念

非对称加密是一种加密算法，它使用一对不同的密钥，即公钥和私钥，来进行数据的加密和解密。公钥是公开的，任何人都可以用它来加密数据，但只有拥有私钥的人才能用它来解密数据。非对称加密可以实现数据的保密性、完整性和身份认证。

#### 特点

非对称加密的优点是安全性高，可以实现数字签名和身份认证。非对称加密的缺点是速度慢，效率低，不适合于大量数据的加解密。

## 3. 数字证书是什么

数字证书是一种用来证明**公钥拥有者**身份的**电子文件**，它包含了**公钥**的内容和一些其他的信息，如证书颁发者、有效期、主体名称等。数字证书还有一个重要的特征，就是它是由一个可信的第三方机构，即**证书认证机构（CA）签发**的，CA会用自己的私钥对数字证书进行签名，以保证数字证书的真实性和完整性。任何人都可以用CA的公钥来验证数字证书的签名，从而确认数字证书的有效性。

## 4. TLS握手过程

非对称加密实现，会话密钥的传递，再通过对称加密的方式，来进行数据逇通讯

- 客户端向服务器发送一个 **ClientHello** 消息，包含客户端支持的TLS版本，加密套件，压缩方法，**随机数(1)**等信息。
- 服务器向客户端发送一个 **ServerHello** 消息，包含服务器选择的TLS版本，加密套件，压缩方法，**随机数(2)**等信息。同时，服务器也会发送自己的 **数字证书** 和 **签名** 给客户端，用于验证服务器的身份和公钥。【==公钥存在于数字证书中==】
- 客户端收到服务器的消息后，会验证服务器的数字证书和签名，如果通过，则会生成一个 **预主密钥（3）**，并用服务器的公钥加密后发送给服务器。这个预主密钥是用于生成对称加密的 **会话密钥** 的。
- 服务器收到客户端的消息后，会用自己的私钥解密得到预主密钥，并用预主密钥和双方的随机数生成**会话密钥**。同时，服务器会向客户端发送一个 **ChangeCipherSpec** 消息，表示后续的通信将使用会话密钥进行加密。
- 客户端收到服务器的消息后，也会生成**会话密钥**，并向服务器发送一个 **ChangeCipherSpec** 消息，表示同意使用会话密钥进行加密。
- 客户端和服务器都会发送一个 **Finished** 消息，用于验证双方是否正确地生成了会话密钥，并结束握手过程。

## 5. HTTPS的特点

> 见第1条和第7条

主要是回答，HTTPS的优点

## 6. HTTPS如何保证安全

HTTPS的概念，以及TLS的原理

## 7. HTTPS相对于HTTP做了哪些优化？

### 优化之处

HTTPS使用了SSL/TLS协议，可以对数据进行加密，防止被窃听或篡改，保证了数据的机密性和完整性12。
HTTPS可以通过证书来验证服务器的身份，防止遭受中间人攻击，保证了通信的安全性12。
HTTPS可以提高网站的信誉和排名，因为搜索引擎会优先收录HTTPS网站，而浏览器也会给予HTTPS网站更好的显示效果 。

### 不足之处

HTTPS需要申请和维护证书，这可能会带来一定的成本和麻烦。
HTTPS会增加服务器的负担，因为加密和解密需要消耗更多的CPU和内存资源。
HTTPS会降低网页的加载速度，因为建立连接和传输数据都需要额外的时间。

## 8. HTTPS和HTTP的区别

1. 安全方面的区别

   回答HTTP的不足之处（参考第1条），以及参考第8条HTTPS的优势之处

2. 其他方面的区别

   - 端口号等
   - 见面经

# 三、请求响应

## 0. 拓展面试题

> 主要是一些在牛客上见到的，常见面试题的扩展

### 301和302除了重定向的区别还有其他区别吗？



## 1. 状态码

见面经

## 2. 

真实面试题

# 网络模型

## 1. OSI七层模型

- 物理层：负责在物理媒介上传输比特流，定义了物理设备的接口标准，如电缆、光纤、电压等。物理层的数据单位是比特。
- 数据链路层：负责在物理层提供的不可靠的信道上建立可靠的数据传输，定义了数据帧的格式和传输规则，实现了错误检测和流量控制。数据链路层的数据单位是帧。
- 网络层：负责在多个网络之间寻找最佳的传输路径，定义了网络地址和路由协议，实现了分组交换和拥塞控制。网络层的数据单位是分组或报文。
- 传输层：负责在端到端之间提供可靠或不可靠的数据传输服务，定义了端口号和传输协议，实现了数据分割和重组、差错恢复和流量控制。传输层的数据单位是段或报文。
- 会话层：负责在应用程序之间建立、管理和终止会话，定义了会话标识和同步协议，实现了对话控制和数据交换管理。会话层的数据单位是消息。
- 表示层：负责对数据进行编码、解码、加密、解密等转换，定义了数据格式和表示协议，实现了数据压缩和解压缩、字符集转换等功能。表示层的数据单位是消息。
- 应用层：负责为用户或应用程序提供各种网络服务，定义了应用程序接口和服务协议，实现了文件传输、电子邮件、远程登录等功能。应用层的数据单位是消息。

## 2. TCP/IP五层模型





## 3. TCP协议与UDP协议

TCP和UDP是两种常用的传输层协议，它们都是用于在网络中传输数据的协议，实现端到端的数据传输，但是它们有不同的概念，特点和区别。

### TCP

TCP（Transmission Control Protocol）是一种**面向连接的**、**可靠的**、**基于字节流**的传输层协议。它的概念是在发送数据之前，先建立一个虚拟的连接通道，然后在通道中按顺序发送和接收数据，最后关闭连接。它的特点是：

- 它可以保证数据的可靠性，即数据不会丢失、重复或乱序。
- 它可以保证数据的完整性，即数据不会被截断或损坏。
- 它可以保证数据的有序性，当发送方将数据分成多个TCP报文段发送时，TCP会为每个报文段分配一个序列号，并在接收方进行排序和组装。
- 它可以实现流量控制（flow control），即根据接收方的处理能力和网络状况来调节发送方的发送速率。
- 它可以实现拥塞控制（congestion control），即根据网络拥塞程度来调节发送方的发送窗口大小和重传策略。

TCP的优点是可以提供高质量的数据传输服务，适合于对可靠性要求高的应用，如文件传输、电子邮件、远程登录等。

TCP的缺点是由于需要建立连接、维护状态、确认应答、重传丢失等操作，会增加额外的开销和延迟，降低传输效率，不适合于对实时性要求高的应用，如语音通话、视频会议、在线游戏等。

### UDP

UDP（User Datagram Protocol）是一种无连接的、不可靠的、基于数据报的传输层协议。

它的概念是在发送数据时，不需要建立连接，只需要将数据打包成一个个独立的数据报（datagram），然后直接发送给目标地址。它的特点是：

- 它不保证数据的可靠性，即数据可能会丢失、重复或乱序。
- 它不保证数据的完整性，即数据可能会被截断或损坏。
- 它不保证数据的有序性，即数据可能会按照任意顺序到达接收方。
- 它不实现流量控制和拥塞控制，即发送方不考虑接收方的处理能力和网络状况，只管尽可能快地发送数据。

UDP的优点是由于不需要建立连接、维护状态、确认应答、重传丢失等操作，减少了额外的开销和延迟，提高了传输效率，适合于对实时性要求高的应用，如语音通话、视频会议、在线游戏等。UDP的缺点是不能提供高质量的数据传输服务，适合于对可靠性要求低或可以自行处理错误恢复的应用。

## 4. TCP的握手和挥手

### TCP三次握手的过程

- 第一次握手：客户端将TCP报文的同步位SYN置为1，随机生成一个序号seq=x，并将该报文发送给服务器，表示客户端请求建立连接。客户端进入SYN_SENT状态，等待服务器的回应。【==客户端向服务器发送连接请求==】
- 第二次握手：服务器收到客户端的SYN报文后，如果同意建立连接，则将TCP报文的同步位SYN和确认位ACK都置为1，确认号ack=x+1，随机生成一个序号seq=y，并将该报文发送给客户端，表示服务器接受连接请求。服务器进入SYN_RCVD(syn_received)状态。【==服务器确认客户端的链接请求==】
- 第三次握手：客户端收到服务器的SYN+ACK报文后，检查确认号是否为x+1，ACK是否为1，如果正确，则将TCP报文的确认位ACK置为1，确认号ack=y+1，并将该报文发送给服务器，表示客户端确认连接建立。客户端进入ESTABLISHED状态。服务器收到客户端的ACK报文后，检查确认号是否为y+1，ACK是否为1，如果正确，则也进入ESTABLISHED状态。此时，TCP连接建立成功，双方可以开始数据传输。【==客户端确认服务器连接接受==】

**序列号seq的作用**

- 第一次携带时，表示起始序号。

**确认序列号ack的作用**

- ack表示期望的下次seq序号的值，告诉目标方，我知道你下次发的seq是多少了

序列号和确认号可以让发送方和接收方知道对方发送和接收了哪些数据，以及是否有数据丢失、重复或乱序。

如果客户端接受的确认序号ack不等于发送时的序号seq+1，说明连接有误。换句话说，服务端发送的ack为下次客户端发送的seq。

+1的原因是，syn报文，会消耗一个序号，所以，下次再发送序号为x+1，如果数据更多，x会+得更多

### TCP四次挥手的过程

- 第一次挥手：客户端向服务器发送一个FIN报文段，表示请求断开连接，并携带一个序列号x。
- 第二次挥手：服务器收到FIN报文段后，向客户端发送一个ACK报文段，表示确认收到请求，并携带一个确认号ack=x+1。这时候，客户端到服务器的方向已经断开，但是服务器还可以向客户端发送数据。
- 第三次挥手：服务器发送完所有数据后，向客户端发送一个FIN报文段，表示请求断开连接，并携带一个序列号y。
- 第四次挥手：客户端收到FIN报文段后，向服务器发送一个ACK报文段，表示确认收到请求，并携带一个确认号y+1，表示期望收到服务器的下一个字节的编号。这时候，服务器到客户端的方向也已经断开，双方都不再发送数据。

注：

客户端关闭了通道，但并不是说客户端不能发送任何数据，而是说客户端不再发送数据体，即不再发送携带有效载荷（payload）的数据帧（DATA frame）。客户端仍然可以发送一些控制帧（control frame），如确认帧（ACK frame）、窗口更新帧（WINDOW_UPDATE frame）等，用于维护和管理连接的状态。这些控制帧不占用有效载荷的空间，只包含一些必要的头部信息，如类型、标志、长度、流标识符等。因此，当客户端收到服务器的FIN报文段时，它可以发送一个ACK报文段来确认收到请求，并关闭服务器到客户端的方向的连接

### 为什么要TCP连接3次，两次不行吗？

#### 两次握手产生的问题

两次握手的过程是，客户端发送连接请求报文，服务端确认连接请求并返回确认报文，即可完成连接。

**问题1**：两次握手无法防止已失效的连接请求报文段被服务器端接收并响应。

如果客户端发送了一个连接请求后，由于网络拥塞或其他原因，这个报文段在网络中滞留了很长时间，导致客户端超时重传。但是如果这个滞留的报文段最终还是到达了服务器端，并且恰好与服务器端的某个监听端口匹配，那么服务器端就会误认为这是一个新的连接请求，并发送回复。这样就会造成服务器端建立了一个错误的连接，并等待客户端发送数据。

**三次握手的解决方案**

因此客户端已经不再需要这个连接了，所以不会发送第三次握手的ACK报文段。因此，服务器端就会一直等待客户端的确认，直到超时放弃。这样就避免了服务器端建立了一个错误的连接，并等待客户端发送数据。

**问题2**：无法确认双方都能正常地发送和接收数据

在三次握手后，双方都能确认对方的初始序列号，并且都能正常地发送和接收数据，在二次握手后，服务器端并没有收到客户端的确认信息，所以不知道客户端是否已经准备好接收数据。同样，客户端也不知道服务器端是否已经准备好发送数据。如果其中一方出现了故障或异常，另一方就会一直等待或发送数据，导致资源的浪费或错误的结果。

### 为什么TCP要挥手四次？

TCP的连接是双向的，即客户端和服务器之间有两个单向的连接，分别用于发送和接收数据。因此，在断开连接之前，双方都需要发送一个FIN报文段，表示请求断开连接，并收到对方的ACK报文段，表示确认收到请求。这样就需要四次挥手，即两次FIN+ACK的交换。

## 5. TCP的重传机制

- 超时重传：发送方在发送数据后设置一个计时器，如果在一定时间内没有收到接收方的确认报文（ACK），就认为数据包丢失，然后重新发送数据包，直到收到ACK或达到最大重传次数为止。
- 快速重传：发送方在收到接收方连续三个相同的ACK后，就认为该ACK之后的数据包丢失，然后立即重发该数据包，而不等待计时器超时。

## 6. TCP的拥塞控制机制

